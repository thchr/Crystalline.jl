<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bravais types &amp; bases · Crystalline.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://thchr.github.io/Crystalline.jl/bravais/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Crystalline.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Crystalline.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Crystalline.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../operations/">Symmetry operations</a></li><li><a class="tocitem" href="../groups/">Groups</a></li><li><a class="tocitem" href="../irreps/">Irreps</a></li><li class="is-active"><a class="tocitem" href>Bravais types &amp; bases</a><ul class="internal"><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Crystalline.jl-extensions-of-Bravais.jl-functions"><span>Crystalline.jl extensions of Bravais.jl functions</span></a></li></ul></li><li><a class="tocitem" href="../bandreps/">Band representations</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Bravais types &amp; bases</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bravais types &amp; bases</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/thchr/Crystalline.jl/blob/master/docs/src/bravais.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Bravais.jl"><a class="docs-heading-anchor" href="#Bravais.jl">Bravais.jl</a><a id="Bravais.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Bravais.jl" title="Permalink"></a></h1><p>Bravais types, basis systems, and transformations between conventional and primitive settings.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Bravais.DirectBasis" href="#Bravais.DirectBasis"><code>Bravais.DirectBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DirectBasis{D} &lt;: AbstractBasis{D}</code></pre><p>A wrapper type over <code>D</code> distinct <code>D</code>-dimensional vectors (given as a <code>SVector{D, SVector{D,Float64}}</code>), defining a lattice basis in direct space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/types.jl#LL10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.ReciprocalBasis" href="#Bravais.ReciprocalBasis"><code>Bravais.ReciprocalBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReciprocalBasis{D} &lt;: AbstractBasis{D}</code></pre><p>A wrapper type over <code>D</code> distinct <code>D</code>-dimensional vectors (given as a <code>SVector{D, SVector{D,Float64}}</code>), defining a lattice basis in reciprocal space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/types.jl#LL10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.DirectPoint" href="#Bravais.DirectPoint"><code>Bravais.DirectPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bravais.DirectPoint{D} &lt;: AbstractPoint{D}</code></pre><p>A wrapper type over an <code>SVector{D, Float64}</code>, defining a single point in <code>D</code>-dimensional direct space. </p><p>The coordinates of a Bravais.DirectPoint are generally assumed specified relative to an associated DirectBasis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/types.jl#LL84-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.ReciprocalPoint" href="#Bravais.ReciprocalPoint"><code>Bravais.ReciprocalPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bravais.ReciprocalPoint{D} &lt;: AbstractPoint{D}</code></pre><p>A wrapper type over an <code>SVector{D, Float64}</code>, defining a single point in <code>D</code>-dimensional reciprocal space. </p><p>The coordinates of a Bravais.ReciprocalPoint are generally assumed specified relative to an associated ReciprocalBasis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/types.jl#LL84-L92">source</a></section></article><h3 id="Crystal-systems-and-Bravais-types"><a class="docs-heading-anchor" href="#Crystal-systems-and-Bravais-types">Crystal systems &amp; Bravais types</a><a id="Crystal-systems-and-Bravais-types-1"></a><a class="docs-heading-anchor-permalink" href="#Crystal-systems-and-Bravais-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Bravais.crystalsystem" href="#Bravais.crystalsystem"><code>Bravais.crystalsystem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crystalsystem(Rs::DirectBasis{D})  --&gt;  String</code></pre><p>Determine the crystal system of a point lattice <code>Rs</code>, assuming the conventional setting choice defined in the International Tables of Crystallography <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>.</p><p>There are 4 crystal systems in 2D and 7 in 3D (see Section 2.1.2(iii) of <sup class="footnote-reference"><a id="citeref-ITA5" href="#footnote-ITA5">[ITA5]</a></sup>):</p><table><tr><th style="text-align: left"><code>D</code></th><th style="text-align: right">System</th><th style="text-align: right">Conditions</th><th style="text-align: right">Free parameters</th></tr><tr><td style="text-align: left"><strong>1D</strong></td><td style="text-align: right">linear</td><td style="text-align: right">none</td><td style="text-align: right">a</td></tr><tr><td style="text-align: left"><strong>2D</strong></td><td style="text-align: right">square</td><td style="text-align: right">a=b &amp; γ=90°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">rectangular</td><td style="text-align: right">γ=90°</td><td style="text-align: right">a,b</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">hexagonal</td><td style="text-align: right">a=b &amp; γ=120°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">oblique</td><td style="text-align: right">none</td><td style="text-align: right">a,b,γ</td></tr><tr><td style="text-align: left"><strong>3D</strong></td><td style="text-align: right">cubic</td><td style="text-align: right">a=b=c &amp; α=β=γ=90°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">hexagonal</td><td style="text-align: right">a=b &amp; α=β=90° &amp; γ=120°</td><td style="text-align: right">a,c</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">trigonal</td><td style="text-align: right">a=b &amp; α=β=90° &amp; γ=120°</td><td style="text-align: right">a,c (a,α for hR)</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">tetragonal</td><td style="text-align: right">a=b &amp; α=β=γ=90°</td><td style="text-align: right">a,c</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">orthorhombic</td><td style="text-align: right">α=β=γ=90°</td><td style="text-align: right">a,b,c</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">monoclinic</td><td style="text-align: right">α=γ=90°</td><td style="text-align: right">a,b,c,β≥90°</td></tr><tr><td style="text-align: left"></td><td style="text-align: right">triclinic</td><td style="text-align: right">none</td><td style="text-align: right">a,b,c,α,β,γ</td></tr></table><p>The <code>Rs</code> must specify a set of conventional basis vectors, i.e., not generally primitive. For primitive basis vectors, the crystal system can be further reduced into 5 Bravais types in 2D and 14 in 3D (see <a href="@ref"><code>@bravaistype</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/systems.jl#LL81-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.bravaistype" href="#Bravais.bravaistype"><code>Bravais.bravaistype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bravaistype(sgnum::Integer, D::Integer=3; normalize::Bool=false)  --&gt;  String</code></pre><p>Return the Bravais type of <code>sgnum</code> in dimension <code>D</code> as a string (as the concatenation of the single-character crystal abbreviation and the centering type).</p><p><strong>Keyword arguments</strong></p><ul><li><p><strong><code>normalize</code>:</strong> If the centering type associated with <code>sgnum</code> is <code>&#39;A&#39;</code>, we can choose (depending on the keyword argument <code>normalize</code>, defaulting to <code>false</code>) to &quot;normalize&quot; to the centering type <code>&#39;C&#39;</code>, since the difference between <code>&#39;A&#39;</code> and <code>&#39;C&#39;</code> centering only amounts to a basis change. With <code>normalize=true</code> we then have only the canonical 14 Bravais type, i.e.  <code>unique(bravaistype.(1:230, 3), normalize=true)</code> returns only 14 distinct types, rather than 15.</p><p>This only affects space groups 38-41 (normalizing their conventional Bravais types from <code>&quot;oA&quot;</code> to <code>&quot;oC&quot;</code>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/systems.jl#LL319-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.centering" href="#Bravais.centering"><code>Bravais.centering</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centering(sg_or_lg::Union{SpaceGroup, LittleGroup}) --&gt; Char</code></pre><p>Return the conventional centering type of a <code>SpaceGroup</code> or <code>LittleGroup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/notation.jl#LL40-L45">source</a></section><section><div><pre><code class="nohighlight hljs">centering(sgnum::Integer, D::Integer=3)  --&gt;  Char</code></pre><p>Return the conventional centering type <code>cntr</code> of the space group with number <code>sgnum</code> and dimension <code>D</code>.</p><p>The centering type is equal to the first letter of the Hermann-Mauguin notation&#39;s label, i.e., <code>centering(sgnum, D) == first(Crystalline.iuc(sgnum, D))</code>. Equivalently, the centering type is the second and last letter of the Bravais type (<a href="@ref"><code>bravais</code></a>), i.e., <code>centering(sgnum, D) == bravaistype(sgnum, D)</code>.</p><p>Possible values of <code>cntr</code>, depending on dimensionality <code>D</code>, are (see ITA Sec. 9.1.4):</p><ul><li><code>D = 1</code>:<ul><li><code>cntr = &#39;p&#39;</code>: no centering (primitive)</li></ul></li><li><code>D = 2</code>:<ul><li><code>cntr = &#39;p&#39;</code>: no centring (primitive)</li><li><code>cntr = &#39;c&#39;</code>: face centered</li></ul></li><li><code>D = 3</code>: <ul><li><code>cntr = &#39;P&#39;</code>: no centring (primitive)</li><li><code>cntr = &#39;I&#39;</code>: body centred (innenzentriert)</li><li><code>cntr = &#39;F&#39;</code>: all-face centred</li><li><code>cntr = &#39;A&#39;</code> or <code>&#39;C&#39;</code>: one-face centred, (b,c) or (a,b)</li><li><code>cntr = &#39;R&#39;</code>: hexagonal cell rhombohedrally centred</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/systems.jl#LL359-L383">source</a></section></article><h3 id="Basis-construction"><a class="docs-heading-anchor" href="#Basis-construction">Basis construction</a><a id="Basis-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-construction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Bravais.crystal" href="#Bravais.crystal"><code>Bravais.crystal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">crystal(a, b, c, α, β, γ)  --&gt;  DirectBasis{3}</code></pre><p>Calculate basis vectors <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span>, <span>$\mathbf{R}_3$</span> in a 3D Cartesian basis for a right-handed coordinate system with specified basis vector lengths <code>a</code>, <code>b</code>, <code>c</code> (associated with <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span>, &amp; <span>$\mathbf{R}_3$</span>, respectively) and specified interaxial angles  <code>α</code> <span>$= ∠(\mathbf{R}_2,\mathbf{R}_3)$</span>, <code>β</code> <span>$= ∠(\mathbf{R}_3,\mathbf{R}_1)$</span>,  <code>γ</code> <span>$= ∠(\mathbf{R}_1,\mathbf{R}_2)$</span>, with <span>$∠$</span> denoting the angle between two vectors.</p><p>For definiteness, the <span>$\mathbf{R}_1$</span> basis vector is oriented along the <span>$x$</span>-axis of the Cartesian coordinate system, and the <span>$\mathbf{R}_2$</span> axis is placed in the <span>$xy$</span>-plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/systems.jl#LL1-L13">source</a></section><section><div><pre><code class="nohighlight hljs">crystal(a, b, γ)  --&gt;  DirectBasis{2}</code></pre><p>Calculate basis vectors <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span> in a 2D Cartesian basis for a  right-handed coordinate system with specified basis vector lengths <code>a</code>, <code>b</code> (associated with <span>$\mathbf{R}_1$</span> &amp; <span>$\mathbf{R}_2$</span>, respectively) and specified interaxial angle <code>γ</code> <span>$= ∠(\mathbf{R}_1,\mathbf{R}_2)$</span>.</p><p>For definiteness, the <span>$\mathbf{R}_1$</span> basis vector is oriented along the <span>$x$</span>-axis of the Cartesian coordinate system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/systems.jl#LL37-L47">source</a></section><section><div><pre><code class="nohighlight hljs">crystal(a)  --&gt;  DirectBasis{1}</code></pre><p>Return a one-dimensional crystal with lattice period <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/systems.jl#LL55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.directbasis" href="#Bravais.directbasis"><code>Bravais.directbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">directbasis(sgnum, D=3;    abclims, αβγlims)
directbasis(sgnum, Val(D); abclims, αβγlims) --&gt; DirectBasis{D}</code></pre><p>Return a random (conventional) <code>DirectBasis</code> for a crystal compatible with the space group number <code>sgnum</code> and dimensionality <code>D</code>. Free parameters in the lattice vectors are chosen randomly, with limits optionally supplied in <code>abclims</code> (lengths) and <code>αβγlims</code> (angles). By convention, the length of the first lattice vector (<code>a</code>) is set to unity, such that the second and third (<code>b</code> and <code>c</code>) lattice vectors&#39; lengths are relative to the first.</p><p>Limits on the relative uniform distribution of lengths <code>b</code> and <code>c</code> can be specified as  2-tuple kwarg <code>abclims</code>; similarly, limits on the angles <code>α</code>, <code>β</code>, <code>γ</code> can be set via αβγlims (only affects oblique, monoclinic, &amp; triclinic lattices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/systems.jl#LL190-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.reciprocalbasis" href="#Bravais.reciprocalbasis"><code>Bravais.reciprocalbasis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reciprocalbasis(Rs)  --&gt;  Gs::ReciprocalBasis{D}</code></pre><p>Return the reciprocal basis <code>Gs</code> of a direct basis <code>Rs</code> in <code>D</code> dimensions, provided as a <code>DirectBasis{D}</code> or a <code>D</code>-dimensional <code>NTuple</code> or <code>StaticVector</code> of <code>AbstractVector</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL185-L190">source</a></section></article><h3 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivebasismatrix" href="#Bravais.primitivebasismatrix"><code>Bravais.primitivebasismatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">primitivebasismatrix(cntr::Char, ::Val{D}=Val(3)) --&gt; SMatrix{D,D,Float64}</code></pre><p>Return the transformation matrix <code>P</code> that transforms a conventional unit cell with centering <code>cntr</code> to the corresponding primitive unit cell (in dimension <code>D</code>) in CDML setting.</p><p><strong>Transformations in direct and reciprocal space</strong></p><p><strong>Bases</strong></p><p>The returned transformation matrix <span>$\mathbf{P}$</span> transforms a direct-space conventional basis <span>$(\mathbf{a}\ \mathbf{b}\ \mathbf{c})$</span> to the direct-space primitive basis</p><p class="math-container">\[    (\mathbf{a}&#39;\ \mathbf{b}&#39;\ \mathbf{c}&#39;) =
    (\mathbf{a}\ \mathbf{b}\ \mathbf{c})\mathbf{P}.\]</p><p>Analogously, <span>$\mathbf{P}$</span> transforms a reciprocal-space conventional basis <span>$(\mathbf{a}^*\ \mathbf{b}^*\ \mathbf{c}^*)$</span> to </p><p class="math-container">\[(\mathbf{a}^{*\prime}\ \mathbf{b}^{*\prime}\ \mathbf{c}^{*\prime}) =
(\mathbf{a}^*\ \mathbf{b}^*\ \mathbf{c}^*)(\mathbf{P}^{-1})^{\text{T}}.\]</p><p>see also <a href="../api/#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{var&quot;#s145&quot;} where var&quot;#s145&quot;&lt;:Real}"><code>transform(::DirectBasis, ::AbstractMatrix{&lt;:Real})</code></a> and <a href="../api/#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{var&quot;#s145&quot;} where var&quot;#s145&quot;&lt;:Real}"><code>transform(::ReciprocalBasis, ::AbstractMatrix{&lt;:Real})</code></a>).</p><p><strong>Coordinates</strong></p><p>The coordinates of a point in either direct or reciprocal space, each referred to a basis, also transform under <span>$\mathbf{P}$</span>. Concretely, direct- and reciprocal-space conventional points <span>$\mathbf{r} = (r_1, r_2, r_3)^{\text{T}}$</span> and <span>$\mathbf{k} = (k_1, k_2, k_3)^{\text{T}}$</span>, respectively, transform to a primitive setting under <span>$\mathbf{P}$</span> according to:</p><p class="math-container">\[\mathbf{r}&#39; = \mathbf{P}^{-1}\mathbf{r},\\
\mathbf{k}&#39; = \mathbf{P}^{\text{T}}\mathbf{k}.\]</p><p>See also <a href="../api/#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{var&quot;#s145&quot;} where var&quot;#s145&quot;&lt;:Real}"><code>transform(::DirectPoint, ::AbstractMatrix{&lt;:Real})</code></a> and <a href="../api/#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{var&quot;#s145&quot;} where var&quot;#s145&quot;&lt;:Real}"><code>transform(::ReciprocalPoint, ::AbstractMatrix{&lt;:Real})</code></a>).</p><p><strong>Setting conventions</strong></p><p>The setting choice for the primitive cell implied by the returned <span>$\mathbf{P}$</span> follows the widely adopted Cracknell-Davies-Miller-Love (CDML) convention.<sup class="footnote-reference"><a id="citeref-CDML" href="#footnote-CDML">[CDML]</a></sup> This convention is explicated e.g. in Table 2 of <sup class="footnote-reference"><a id="citeref-Aroyo" href="#footnote-Aroyo">[Aroyo]</a></sup> (or, alternatively, can be inferred from Tables 1.5.4.1 and 1.5.4.2 of <sup class="footnote-reference"><a id="citeref-ITB2" href="#footnote-ITB2">[ITB2]</a></sup>) and is followed e.g. on the Bilbao Crystallographic Server<sup class="footnote-reference"><a id="citeref-BCS" href="#footnote-BCS">[BCS]</a></sup>, in the CDML reference work on space group irreps<sup class="footnote-reference"><a id="citeref-CDML" href="#footnote-CDML">[CDML]</a></sup>, and in the C library <code>spglib</code>.<sup class="footnote-reference"><a id="citeref-spglib" href="#footnote-spglib">[spglib]</a></sup></p><p>Note that this setting choice is <em>not</em> what is frequently referred to as the &quot;ITA primitive setting&quot;, from which it differs for hP, hR, and oA Bravais types.</p><p>The setting choice is usually referred to as the CDML primitive setting, or, less frequently and more ambiguously, as the crystallographic primitive setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL68-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.transform-Tuple{DirectBasis, AbstractMatrix{var&quot;#s78&quot;} where var&quot;#s78&quot;&lt;:Real}" href="#Bravais.transform-Tuple{DirectBasis, AbstractMatrix{var&quot;#s78&quot;} where var&quot;#s78&quot;&lt;:Real}"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(Rs::DirectBasis, P::AbstractMatrix{&lt;:Real})</code></pre><p>Transform a direct basis <code>Rs</code> <span>$= (\mathbf{a}\ \mathbf{b}\ \mathbf{c})$</span> under the transformation matrix <code>P</code> <span>$= \mathbf{P}$</span>, returning  <code>Rs′</code> <span>$= (\mathbf{a}&#39;\ \mathbf{b}&#39;\ \mathbf{c}&#39;) = (\mathbf{a}\ \mathbf{b}\ \mathbf{c}) \mathbf{P}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL222-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.transform-Tuple{ReciprocalBasis, AbstractMatrix{var&quot;#s78&quot;} where var&quot;#s78&quot;&lt;:Real}" href="#Bravais.transform-Tuple{ReciprocalBasis, AbstractMatrix{var&quot;#s78&quot;} where var&quot;#s78&quot;&lt;:Real}"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(Gs::ReciprocalBasis, P::AbstractMatrix{&lt;:Real})</code></pre><p>Transform a reciprocal basis <code>Gs</code> <span>$= (\mathbf{a}^* \mathbf{b}^* \mathbf{c}^*)$</span> under the transformation matrix <code>P</code> <span>$= \mathbf{P}$</span>, returning  <code>Gs′</code> <span>$= (\mathbf{a}^{*\prime}\ \mathbf{b}^{*\prime}\ \mathbf{c}^{*\prime}) = (\mathbf{a}^*\ \mathbf{b}^*\ \mathbf{c}^*)(\mathbf{P}^{-1})^{\text{T}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL236-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.transform-Tuple{Bravais.DirectPoint, AbstractMatrix{var&quot;#s78&quot;} where var&quot;#s78&quot;&lt;:Real}" href="#Bravais.transform-Tuple{Bravais.DirectPoint, AbstractMatrix{var&quot;#s78&quot;} where var&quot;#s78&quot;&lt;:Real}"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(r::DirectPoint, P::AbstractMatrix{&lt;:Real})  --&gt;  r′::typeof(r)</code></pre><p>Transform a point in direct space <code>r</code> <span>$= (r_1, r_2, r_3)^{\text{T}}$</span> under the transformation matrix <code>P</code> <span>$= \mathbf{P}$</span>, returning <code>r′</code> <span>$= (r_1&#39;, r_2&#39;, r_3&#39;)^{\text{T}} = \mathbf{P}^{-1}(r_1&#39;, r_2&#39;, r_3&#39;)^{\text{T}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL250-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.transform-Tuple{Bravais.ReciprocalPoint, AbstractMatrix{var&quot;#s78&quot;} where var&quot;#s78&quot;&lt;:Real}" href="#Bravais.transform-Tuple{Bravais.ReciprocalPoint, AbstractMatrix{var&quot;#s78&quot;} where var&quot;#s78&quot;&lt;:Real}"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(k::ReciprocalPoint, P::AbstractMatrix{&lt;:Real})  --&gt;  k′::typeof(k)</code></pre><p>Transform a point in reciprocal space <code>k</code> <span>$= (k_1, k_2, k_3)^{\text{T}}$</span> under the transformation matrix <code>P</code> <span>$= \mathbf{P}$</span>, returning <code>k′</code> <span>$= (k_1&#39;, k_2&#39;, k_3&#39;)^{\text{T}} = \mathbf{P}^{\text{T}}(k_1&#39;, k_2&#39;, k_3&#39;)^{\text{T}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Tuple{Union{AbstractBasis, Bravais.AbstractPoint}, Union{Char, Integer}}" href="#Bravais.primitivize-Tuple{Union{AbstractBasis, Bravais.AbstractPoint}, Union{Char, Integer}}"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(V::Union{AbstractBasis, AbstractPoint}, 
            cntr_or_sgnum::Union{Char, &lt;:Integer})   --&gt;  V′::typeof(V)</code></pre><p>Return the primitive basis or point <code>V′</code> associated with the input conventional <code>AbstractBasis</code> or <code>AbstractPoint</code> <code>V</code>.</p><p>The assumed centering type is specified by <code>cntr_or_sgnum</code>, given either as a centering character (<code>::Char</code>) or inferred from a space group number (<code>::Integer</code>) and the dimensionality of <code>V</code> (see also <a href="../api/#Bravais.centering-Union{Tuple{Union{LittleGroup{D}, SpaceGroup{D}}}, Tuple{D}} where D"><code>centering(::Integer, ::Integer)</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL288-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Tuple{DirectBasis, Union{Char, Integer}}" href="#Bravais.primitivize-Tuple{DirectBasis, Union{Char, Integer}}"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(Rs::DirectBasis, cntr_or_sgnum::Union{Char, &lt;:Integer}) --&gt; Rs′::typeof(Rs)</code></pre><p>Return the primitive direct basis <code>Rs′</code> corresponding to the input conventional direct basis <code>Rs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL301-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Tuple{ReciprocalBasis, Union{Char, Integer}}" href="#Bravais.primitivize-Tuple{ReciprocalBasis, Union{Char, Integer}}"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(Gs::ReciprocalBasis, cntr_or_sgnum::Union{Char, &lt;:Integer}) --&gt; Gs′::typeof(Gs)</code></pre><p>Return the primitive reciprocal basis <code>Gs′</code> corresponding to the input conventional reciprocal basis <code>Gs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL309-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Tuple{Bravais.DirectPoint, Union{Char, Integer}}" href="#Bravais.primitivize-Tuple{Bravais.DirectPoint, Union{Char, Integer}}"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(r::DirectPoint, cntr_or_sgnum::Union{Char, &lt;:Integer}) --&gt; r′::typeof(r)</code></pre><p>Return the direct point <code>r′</code> with coordinates in a primitive basis, corresponding to the input point <code>r</code> with coordinates in a conventional basis. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Tuple{Bravais.ReciprocalPoint, Union{Char, Integer}}" href="#Bravais.primitivize-Tuple{Bravais.ReciprocalPoint, Union{Char, Integer}}"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(k::ReciprocalPoint, cntr_or_sgnum::Union{Char, &lt;:Integer}) --&gt; k′::typeof(k)</code></pre><p>Return the reciprocal point <code>k′</code> with coordinates in a primitive basis, corresponding to the input point <code>k</code> with coordinates in a conventional basis. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Tuple{Union{AbstractBasis, Bravais.AbstractPoint}, Union{Char, Integer}}" href="#Bravais.conventionalize-Tuple{Union{AbstractBasis, Bravais.AbstractPoint}, Union{Char, Integer}}"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(V′::Union{AbstractBasis, AbstractPoint}, 
                cntr_or_sgnum::Union{Char, &lt;:Integer})    --&gt;  V::typeof(V′)</code></pre><p>Return the conventional basis or point <code>V</code> associated with the input primitive <code>AbstractBasis</code> or <code>AbstractPoint</code> <code>V′</code>.</p><p>The assumed centering type is specified by <code>cntr_or_sgnum</code>, given either as a centering character (<code>::Char</code>) or inferred from a space group number (<code>::Integer</code>) and the dimensionality of <code>V′</code> (see also <a href="../api/#Bravais.centering-Union{Tuple{Union{LittleGroup{D}, SpaceGroup{D}}}, Tuple{D}} where D"><code>centering(::Integer, ::Integer)</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL349-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Tuple{DirectBasis, Union{Char, Integer}}" href="#Bravais.conventionalize-Tuple{DirectBasis, Union{Char, Integer}}"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(Rs′::DirectBasis, cntr_or_sgnum::Union{Char, &lt;:Integer}) --&gt; Rs::typeof(Rs′)</code></pre><p>Return the conventional direct basis <code>Rs</code> corresponding to the input primitive direct basis <code>Rs′</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL362-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Tuple{ReciprocalBasis, Union{Char, Integer}}" href="#Bravais.conventionalize-Tuple{ReciprocalBasis, Union{Char, Integer}}"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(Gs′::ReciprocalBasis, cntr_or_sgnum::Union{Char, &lt;:Integer}) --&gt; Gs::typeof(Gs′)</code></pre><p>Return the conventional reciprocal basis <code>Gs</code> corresponding to the input primitive reciprocal basis <code>Gs′</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL370-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Tuple{Bravais.DirectPoint, Union{Char, Integer}}" href="#Bravais.conventionalize-Tuple{Bravais.DirectPoint, Union{Char, Integer}}"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(r′::DirectPoint, cntr_or_sgnum::Union{Char, &lt;:Integer}) --&gt; r::typeof(r′)</code></pre><p>Return the direct point <code>r</code> with coordinates in a conventional basis, corresponding to the input point <code>r′</code> with coordinates in a primitive basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL378-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Tuple{Bravais.ReciprocalPoint, Union{Char, Integer}}" href="#Bravais.conventionalize-Tuple{Bravais.ReciprocalPoint, Union{Char, Integer}}"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(k′::ReciprocalPoint, cntr_or_sgnum::Union{Char, &lt;:Integer}) --&gt; k::typeof(k′)</code></pre><p>Return the reciprocal point <code>k</code> with coordinates in a conventional basis, corresponding to the input point <code>k′</code> with coordinates in a primitive basis. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/Bravais/src/transform.jl#LL386-L391">source</a></section></article><h2 id="Crystalline.jl-extensions-of-Bravais.jl-functions"><a class="docs-heading-anchor" href="#Crystalline.jl-extensions-of-Bravais.jl-functions">Crystalline.jl extensions of Bravais.jl functions</a><a id="Crystalline.jl-extensions-of-Bravais.jl-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Crystalline.jl-extensions-of-Bravais.jl-functions" title="Permalink"></a></h2><h3 id="SymOperation"><a class="docs-heading-anchor" href="#SymOperation"><code>SymOperation</code></a><a id="SymOperation-1"></a><a class="docs-heading-anchor-permalink" href="#SymOperation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Bravais.transform" href="#Bravais.transform"><code>Bravais.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(op::SymOperation, P::AbstractMatrix{&lt;:Real}, 
          p::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
          modw::Bool=true)                           --&gt; SymOperation</code></pre><p>Transforms a <code>op</code> <span>$= \{\mathbf{W}|\mathbf{w}\}$</span> by a rotation matrix <code>P</code> and a translation vector <code>p</code> (can be <code>nothing</code> for zero-translations), producing a new symmetry operation  <code>op′</code> <span>$= \{\mathbf{W}&#39;|\mathbf{w}&#39;\}$</span> (cf. Section 1.5.2.3 of <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>)</p><p class="math-container">\[\{\mathbf{W}&#39;|\mathbf{w}&#39;\} = \{\mathbf{P}|\mathbf{p}\}^{-1}\{\mathbf{W}|\mathbf{w}\}
\{\mathbf{P}|\mathbf{p}\}\]</p><p>with</p><p class="math-container">\[\mathbf{W}&#39; = \mathbf{P}^{-1}\mathbf{W}\mathbf{P}
\text{ and }
\mathbf{w}&#39; = \mathbf{P}^{-1}(\mathbf{w}+\mathbf{W}\mathbf{p}-\mathbf{p})\]</p><p>By default, the translation part of <code>op′</code>, i.e. <span>$\mathbf{w}&#39;$</span>, is reduced to the range <span>$[0,1)$</span>, i.e. computed modulo 1. This can be disabled by setting <code>modw = false</code> (default, <code>modw = true</code>).</p><p>See also <a href="../bravais/#Bravais.primitivize-Tuple{SymOperation, Char, Bool}"><code>Bravais.primitivize(::SymOperation, ::Char, ::Bool)</code></a> and <a href="../bravais/#Bravais.conventionalize-Tuple{SymOperation, Char, Bool}"><code>Bravais.conventionalize(::SymOperation, ::Char, ::Bool)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/symops.jl#LL704-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Tuple{SymOperation, Char, Bool}" href="#Bravais.primitivize-Tuple{SymOperation, Char, Bool}"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --&gt; typeof(op)</code></pre><p>Return a symmetry operation <code>op′</code> <span>$≡ \{W&#39;|w&#39;\}$</span> in a primitive setting, transformed from an input symmetry operation <code>op</code> <span>$= \{W|w\}$</span> in a conventional setting. The operations <span>$\{W&#39;|w&#39;\}$</span> and <span>$\{W|w\}$</span> are related by a transformation <span>$\{P|p\}$</span> via (cf. Section 1.5.2.3 of <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>):</p><p class="math-container">\[\{W&#39;|w&#39;\} = \{P|p\}⁻¹\{W|w\}\{P|p\}.\]</p><p>where <span>$P$</span> and <span>$p$</span> are the basis change matrix and origin shifts, respectively. The relevant transformation <span>$\{P|p\}$</span> is inferred from the centering type, as provided by <code>cntr</code> (see also <a href="../bravais/#Bravais.centering"><code>Bravais.centering</code></a>).</p><p>By default, translation parts of <code>op′</code>, i.e. <span>$w&#39;$</span> are reduced modulo 1 (<code>modw = true</code>); to disable this, set <code>modw = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/symops.jl#LL654-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Tuple{SymOperation, Char, Bool}" href="#Bravais.conventionalize-Tuple{SymOperation, Char, Bool}"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(op′::SymOperation, cntr::Char, modw::Bool=true) --&gt; typeof(op)</code></pre><p>Return a symmetry operation <code>op</code> <span>$= \{W|w\}$</span> in a conventional setting, transformed from an input symmetry operation <code>op′</code> <span>$≡ \{W&#39;|w&#39;\}$</span> in a primitive setting.</p><p>See <a href="../bravais/#Bravais.primitivize-Tuple{SymOperation, Char, Bool}"><code>primitivize(::SymOperation, ::Char, ::Bool)</code></a> for description of the centering argument <code>cntr</code> and optional argument <code>modw</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/symops.jl#LL685-L693">source</a></section></article><h3 id="AbstractFourierLattice"><a class="docs-heading-anchor" href="#AbstractFourierLattice"><code>AbstractFourierLattice</code></a><a id="AbstractFourierLattice-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractFourierLattice" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Tuple{Crystalline.AbstractFourierLattice, Char}" href="#Bravais.primitivize-Tuple{Crystalline.AbstractFourierLattice, Char}"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(flat::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flat)</code></pre><p>Given <code>flat</code> referred to a conventional basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flat′</code> referred to the associated primitive basis. </p><p>Specifically, if <code>flat</code> refers to a direct conventional basis <code>Rs</code> <span>$≡ (\mathbf{a} \mathbf{b} \mathbf{c})$</span> [with coordinate vectors <span>$\mathbf{r} ≡ (r_1, r_2, r_3)^{\mathrm{T}}$</span>] then <code>flat′</code> refers to a direct primitive basis <code>Rs′</code> <span>$≡ (\mathbf{a}&#39; \mathbf{b}&#39; \mathbf{c}&#39;) ≡ (\mathbf{a} \mathbf{b} \mathbf{c})\mathbf{P}$</span> [with coordinate vectors  <span>$\mathbf{r}&#39; ≡ (r_1&#39;, r_2&#39;, r_3&#39;)^{\mathrm{T}} = \mathbf{P}^{-1}\mathbf{r}$</span>], where <span>$\mathbf{P}$</span> denotes the basis-change matrix obtained from <code>primitivebasismatrix(...)</code>.</p><p>To compute the associated primitive basis vectors, see <a href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>primitivize(::DirectBasis, ::Char)</code></a> [specifically, <code>Rs′ = primitivize(Rs, cntr)</code>].</p><p><strong>Examples</strong></p><p>A centered (&#39;c&#39;) lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires <code>using PyPlot</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 5; D = 2; cntr = centering(sgnum, D)  # &#39;c&#39; (body-centered)

julia&gt; Rs   = directbasis(sgnum, Val(D))     # conventional basis (rectangular)
julia&gt; flat = levelsetlattice(sgnum, Val(D)) # Fourier lattice in basis of Rs
julia&gt; flat = modulate(flat)                 # modulate the lattice coefficients
julia&gt; plot(flat, Rs)

julia&gt; Rs′   = primitivize(Rs, cntr)    # primitive basis (oblique)
julia&gt; flat′ = primitivize(flat, cntr)  # Fourier lattice in basis of Rs′

julia&gt; using PyPlot
julia&gt; plot(flat′, Rs′)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/lattices.jl#LL253-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Tuple{Crystalline.AbstractFourierLattice, Char}" href="#Bravais.conventionalize-Tuple{Crystalline.AbstractFourierLattice, Char}"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(flat::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flat′)</code></pre><p>Given <code>flat</code> referred to a primitive basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flat′</code> referred to the associated conventional basis. </p><p>See also the complementary method <a href="../bravais/#Bravais.primitivize-Tuple{Crystalline.AbstractFourierLattice, Char}"><code>primitivize(::AbstractFourierLattice, ::Char)</code></a> for additional details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/lattices.jl#LL301-L309">source</a></section></article><h3 id="AbstractVec"><a class="docs-heading-anchor" href="#AbstractVec"><code>AbstractVec</code></a><a id="AbstractVec-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractVec" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{var&quot;#s80&quot;} where var&quot;#s80&quot;&lt;:Real}" href="#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{var&quot;#s80&quot;} where var&quot;#s80&quot;&lt;:Real}"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(v::AbstractVec, P::AbstractMatrix)  --&gt;  v′::typeof(v)</code></pre><p>Return a transformed coordinate vector <code>v′</code> from an original coordinate vector <code>v</code> using a basis change matrix <code>P</code>.</p><p>Note that a basis change matrix <span>$\mathbf{P}$</span> transforms direct coordinate vectors (<code>RVec</code>) as <span>$\mathbf{r}&#39; = \mathbf{P}^{-1}\mathbf{r}$</span> but transforms reciprocal coordinates (<code>KVec</code>) as <span>$\mathbf{k}&#39; = \mathbf{P}^{\mathrm{T}}\mathbf{k}$</span> <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/types.jl#LL333-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Tuple{Crystalline.AbstractVec, Char}" href="#Bravais.primitivize-Tuple{Crystalline.AbstractVec, Char}"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(v::AbstractVec, cntr::Char)  --&gt;  v′::typeof(v)</code></pre><p>Transforms a conventional coordinate vector <code>v</code> to a standard primitive basis (specified by the centering type <code>cntr</code>), returning the primitive coordinate vector <code>v′</code>.</p><p>Note that a basis change matrix <span>$\mathbf{P}$</span> (as returned e.g. by <a href="../bravais/#Bravais.primitivebasismatrix"><code>Bravais.primitivebasismatrix</code></a>) transforms direct coordinate vectors (<a href="#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>RVec</code></a>) as <span>$\mathbf{r}&#39; = \mathbf{P}^{-1}\mathbf{r}$</span> but transforms reciprocal coordinates (<a href="#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>KVec</code></a>) as <span>$\mathbf{k}&#39; = \mathbf{P}^{\text{T}}\mathbf{k}$</span> <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>. Recall also the distinction between transforming a basis and the coordinates of a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/types.jl#LL361-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Tuple{Crystalline.AbstractVec, Char}" href="#Bravais.conventionalize-Tuple{Crystalline.AbstractVec, Char}"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(v′::AbstractVec, cntr::Char)  --&gt;  v::typeof(v′)</code></pre><p>Transforms a primitive coordinate vector <code>v′</code> back to a standard conventional basis (specified by the centering type <code>cntr</code>), returning the conventional coordinate vector <code>v</code>.</p><p>See also <a href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>primitivize</code></a> and <a href="#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{var&quot;#s145&quot;} where var&quot;#s145&quot;&lt;:Real}"><code>transform</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/f18c46f40dc0b2a2e36f6f5cb6def2308084845f/src/types.jl#LL385-L392">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016): Tables      3.1.2.1 and 3.1.2.2 (or Tables 2.1.2.1, 9.1.7.1, and 9.1.7.2 of <sup class="footnote-reference"><a id="citeref-ITA5" href="#footnote-ITA5">[ITA5]</a></sup>).</li><li class="footnote" id="footnote-ITA5"><a class="tag is-link" href="#citeref-ITA5">ITA5</a>T. Hahn, International Tables of Crystallography, Vol. A, 5th ed. (2005).</li><li class="footnote" id="footnote-CDML"><a class="tag is-link" href="#citeref-CDML">CDML</a>Cracknell, Davies, Miller, &amp; Love, Kroenecker Product Tables, Vol. 1 (1979).</li><li class="footnote" id="footnote-BCS"><a class="tag is-link" href="#citeref-BCS">BCS</a>Bilbao Crystallographic Server, <a href="https://www.cryst.ehu.es/cryst/get_kvec.html">KVEC</a>.</li><li class="footnote" id="footnote-Aroyo"><a class="tag is-link" href="#citeref-Aroyo">Aroyo</a>Aroyo <em>et al.</em>, <a href="https://doi.org/10.1107/S205327331303091X">Acta Cryst. A70, 126 (2014)</a>: Table 2 gives       <span>$(\mathbf{P}^{-1})^{\text{T}}$</span>.</li><li class="footnote" id="footnote-ITB2"><a class="tag is-link" href="#citeref-ITB2">ITB2</a>Hahn, International Tables of Crystallography, Vol. B, 2nd edition (2001).</li><li class="footnote" id="footnote-spglib"><a class="tag is-link" href="#citeref-spglib">spglib</a>Spglib documentation: <a href="https://spglib.github.io/spglib/definition.html#transformation-to-the-primitive-cell">Transformation to the primitive setting</a>.        Thus, Bravais.jl and <a href="https://github.com/singularitti/Spglib.jl">Spglib.jl</a>        transform to identical primitive settings and are hence mutually compatible.</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../irreps/">« Irreps</a><a class="docs-footer-nextpage" href="../bandreps/">Band representations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 2 November 2021 01:58">Tuesday 2 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
