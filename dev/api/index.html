<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Crystalline.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://thchr.github.io/Crystalline.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Crystalline.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Crystalline.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Crystalline.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../operations/">Symmetry operations</a></li><li><a class="tocitem" href="../groups/">Groups</a></li><li><a class="tocitem" href="../irreps/">Irreps</a></li><li><a class="tocitem" href="../bravais/">Bravais types &amp; bases</a></li><li><a class="tocitem" href="../bandreps/">Band representations</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Exported-types"><span>Exported types</span></a></li><li><a class="tocitem" href="#Exported-methods"><span>Exported methods</span></a></li><li><a class="tocitem" href="#Exported-constants"><span>Exported constants</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/thchr/Crystalline.jl/blob/master/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><hr/><h2 id="Exported-types"><a class="docs-heading-anchor" href="#Exported-types">Exported types</a><a id="Exported-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Crystalline.BandRep" href="#Crystalline.BandRep"><code>Crystalline.BandRep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BandRep &lt;: AbstractVector{Int64}</code></pre><ul><li><p><code>wyckpos::String</code></p></li><li><p><code>sitesym::String</code></p></li><li><p><code>label::String</code></p></li><li><p><code>dim::Int64</code></p></li><li><p><code>decomposable::Bool</code></p></li><li><p><code>spinful::Bool</code></p></li><li><p><code>irvec::Vector{Int64}</code></p></li><li><p><code>irlabs::Vector{String}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL878-L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.BandRepSet" href="#Crystalline.BandRepSet"><code>Crystalline.BandRepSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BandRepSet &lt;: AbstractVector{BandRep}</code></pre><ul><li><p><code>sgnum::Int64</code></p></li><li><p><code>bandreps::Vector{BandRep}</code></p></li><li><p><code>kvs::Vector{&lt;:KVec}</code></p></li><li><p><code>klabs::Vector{String}</code></p></li><li><p><code>irlabs::Vector{String}</code></p></li><li><p><code>allpaths::Bool</code></p></li><li><p><code>spinful::Bool</code></p></li><li><p><code>timeinvar::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL923-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.CharacterTable" href="#Crystalline.CharacterTable"><code>Crystalline.CharacterTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CharacterTable{D} &lt;: Crystalline.AbstractCharacterTable</code></pre><ul><li><p><code>ops::Array{SymOperation{D}, 1} where D</code></p></li><li><p><code>irlabs::Vector{String}</code></p></li><li><p><code>table::Matrix{ComplexF64}</code></p></li><li><p><code>tag::String</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL787-L789">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D" href="#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>Crystalline.KVec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KVec{D}(str::AbstractString) --&gt; KVec{D}
KVec(str::AbstractString)    --&gt; KVec
KVec(::AbstractVector, ::AbstractMatrix) --&gt; KVec</code></pre><p>Return a <code>KVec</code> by parsing the string representations <code>str</code>, supplied in one of the following formats:</p><pre><code class="language-jl hljs">&quot;($1,$2,$3)&quot;
&quot;[$1,$2,$3]&quot;
&quot;$1,$2,$3&quot;</code></pre><p>where the coordinates <code>$1</code>,<code>$2</code>, and <code>$3</code> are strings that may contain fractions, decimal numbers, and &quot;free&quot; parameters {<code>&#39;α&#39;</code>,<code>&#39;β&#39;</code>,<code>&#39;γ&#39;</code>} (or, alternatively and equivalently, {<code>&#39;u&#39;</code>,<code>&#39;v&#39;</code>,<code>&#39;w&#39;</code>} or {<code>&#39;x&#39;</code>,<code>&#39;y&#39;</code>,<code>&#39;z&#39;</code>}).</p><p>Fractions such as <code>1/2</code> and decimal numbers can be parsed: but use of any other special operator besides <code>/</code> will produce undefined behavior (e.g. do not use <code>*</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; KVec(&quot;0.25,α,0&quot;)
[1/4, α, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL209-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.LGIrrep" href="#Crystalline.LGIrrep"><code>Crystalline.LGIrrep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LGIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>g::LittleGroup</code></p></li><li><p><code>matrices::Vector{Matrix{ComplexF64}}</code></p></li><li><p><code>translations::Vector{Vector{Float64}}</code></p></li><li><p><code>reality::Reality</code></p></li><li><p><code>iscorep::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL664-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.LittleGroup" href="#Crystalline.LittleGroup"><code>Crystalline.LittleGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LittleGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>kv::KVec</code></p></li><li><p><code>klab::String</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL514-L516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.ModulatedFourierLattice" href="#Crystalline.ModulatedFourierLattice"><code>Crystalline.ModulatedFourierLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModulatedFourierLattice{D} &lt;: AbstractFourierLattice{D}</code></pre><p>A <code>D</code>-dimensional concrete Fourier (plane wave) lattice, derived from  a <a href="../lattices/#Crystalline.UnityFourierLattice"><code>UnityFourierLattice{D}</code></a> by scaling and modulating its orbit coefficients  by complex numbers; in general, the coefficients do not have unit norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/lattices.jl#LL28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.MultTable" href="#Crystalline.MultTable"><code>Crystalline.MultTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MultTable{D} &lt;: AbstractArray{SymOperation{D}, 2}</code></pre><ul><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li><li><p><code>table::Matrix{Int64}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL101-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.MultTable-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D" href="#Crystalline.MultTable-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>Crystalline.MultTable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultTable(ops::AbstractVector{&lt;:SymOperation{D}}, modτ=true)</code></pre><p>Compute the multiplication (or Cayley) table of <code>ops</code>, an <code>AbstractVector</code> of <code>SymOperation{D}</code>s. The <code>modτ</code> keyword argument controls whether composition of operations is taken modulo lattice vectors (<code>true</code>, default) or not (<code>false</code>).</p><p>A <code>MultTable{D}</code> is returned, which contains symmetry operations resulting from composition  of <code>row</code> and <code>col</code> operators; the table of indices give the symmetry operators relative to the ordering of <code>ops</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL459-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.PGIrrep" href="#Crystalline.PGIrrep"><code>Crystalline.PGIrrep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PGIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>g::PointGroup</code></p></li><li><p><code>matrices::Vector{Matrix{ComplexF64}}</code></p></li><li><p><code>reality::Reality</code></p></li><li><p><code>iscorep::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL642-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.PointGroup" href="#Crystalline.PointGroup"><code>Crystalline.PointGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PointGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>label::String</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL501-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D" href="#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>Crystalline.RVec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RVec{D}(str::AbstractString) --&gt; RVec{D}
RVec(str::AbstractString)    --&gt; RVec
RVec(::AbstractVector, ::AbstractMatrix) --&gt; RVec</code></pre><p>Return a <code>RVec</code> by parsing the string representations <code>str</code>, supplied in one of the following formats:</p><pre><code class="language-jl hljs">&quot;($1,$2,$3)&quot;
&quot;[$1,$2,$3]&quot;
&quot;$1,$2,$3&quot;</code></pre><p>where the coordinates <code>$1</code>,<code>$2</code>, and <code>$3</code> are strings that may contain fractions, decimal numbers, and &quot;free&quot; parameters {<code>&#39;α&#39;</code>,<code>&#39;β&#39;</code>,<code>&#39;γ&#39;</code>} (or, alternatively and equivalently, {<code>&#39;u&#39;</code>,<code>&#39;v&#39;</code>,<code>&#39;w&#39;</code>} or {<code>&#39;x&#39;</code>,<code>&#39;y&#39;</code>,<code>&#39;z&#39;</code>}).</p><p>Fractions such as <code>1/2</code> and decimal numbers can be parsed: but use of any other special operator besides <code>/</code> will produce undefined behavior (e.g. do not use <code>*</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; RVec(&quot;0.25,α,0&quot;)
[1/4, α, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL209-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.Reality" href="#Crystalline.Reality"><code>Crystalline.Reality</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Reality &lt;: Enum{Int8}</code></pre><p>Enum type with instances</p><pre><code class="nohighlight hljs">REAL = 1
PSEUDOREAL = -1
COMPLEX = 0</code></pre><p>The return value of <a href="@ref"><code>reality(::AbstractIrrep)</code></a> and <a href="#Crystalline.calc_reality-Union{Tuple{D}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}, Union{Nothing, Vector{&lt;:Real}}}} where D"><code>calc_reality</code></a> is an instance of <code>Reality</code>. The reality type of an irrep is relevant for constructing &quot;physically real&quot; irreps (co-reps) via <a href="#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D}, 1}}, Tuple{D}} where D"><code>realify</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL578-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.SpaceGroup" href="#Crystalline.SpaceGroup"><code>Crystalline.SpaceGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SpaceGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL491-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.SubperiodicGroup" href="#Crystalline.SubperiodicGroup"><code>Crystalline.SubperiodicGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SubperiodicGroup{D, P} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li></ul><p>A subperiodic group of embedding dimension <code>D</code> and periodicity dimension <code>P</code>. </p><p>Fields: </p><ul><li><code>operations</code>: the <code>SymOperation</code>s of the finite factor group <span>$G/T$</span>, where <span>$G$</span> is the</li></ul><p>subperiodic group and <span>$T$</span> is the translation group of the associated lattice.</p><ul><li><code>num</code>: the canonical number of the group, following the International Tables for</li></ul><p>Crystallography, Volume E.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/subperiodic.jl#LL138-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.SymOperation" href="#Crystalline.SymOperation"><code>Crystalline.SymOperation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SymOperation{D} &lt;: AbstractMatrix{Float64}</code></pre><ul><li><p><code>rotation::Crystalline.SquareStaticMatrices.SqSMatrix{D, Float64} where D</code></p></li><li><p><code>translation::StaticArraysCore.SVector{D, Float64} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL5-L7">source</a></section></article><h2 id="Exported-methods"><a class="docs-heading-anchor" href="#Exported-methods">Exported methods</a><a id="Exported-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Bravais.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D}, DirectBasis{D}}} where D" href="#Bravais.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D}, DirectBasis{D}}} where D"><code>Bravais.cartesianize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cartesianize(op::SymOperation{D}, Rs::DirectBasis{D}) --&gt; SymOperation{D}</code></pre><p>Converts <code>opˡ</code> from a lattice basis to a Cartesian basis, by computing the transformed operators <code>opᶜ = 𝐑*opˡ*𝐑⁻¹</code> via the Cartesian basis matrix 𝐑 (whose columns are the <code>DirectBasis</code> vectors <code>Rs[i]</code>). </p><p><strong>Note 1</strong></p><p>The matrix 𝐑 maps vectors coefficients in a lattice basis 𝐯ˡ to coefficients in a Cartesian basis 𝐯ᶜ as 𝐯ˡ = 𝐑⁻¹𝐯ᶜ and vice versa as 𝐯ᶜ = 𝐑𝐯ˡ. Since a general transformation P  transforms an &quot;original&quot; vectors with coefficients 𝐯 to new coefficients 𝐯′ via 𝐯′ = P⁻¹𝐯 and since we here here consider the lattice basis as the &quot;original&quot; basis we have P = 𝐑⁻¹.  As such, the transformation of the operator <code>op</code> transforms as <code>opᶜ = P⁻¹*opˡ*P</code>, i.e. <code>opᶜ = transform(opˡ,P) = transform(opˡ,𝐑⁻¹)</code>.</p><p><strong>Note 2</strong></p><p>The display (e.g. Seitz and xyzt notation) of <code>SymOperation</code>s e.g. in the REPL implicitly assumes integer coefficients for its point-group matrix: as a consequence, displaying  <code>SymOperation</code>s in a Cartesian basis may produce undefined behavior. The matrix representation remains valid, however.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL884-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.centering-Union{Tuple{Union{LittleGroup{D}, SpaceGroup{D}}}, Tuple{D}} where D" href="#Bravais.centering-Union{Tuple{Union{LittleGroup{D}, SpaceGroup{D}}}, Tuple{D}} where D"><code>Bravais.centering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centering(g::AbstractGroup) --&gt; Char</code></pre><p>Return the conventional centering type of a group. </p><p>For groups without lattice structure (e.g., point groups), return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/notation.jl#LL38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D" href="#Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(flat::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flat′)</code></pre><p>Given <code>flat</code> referred to a primitive basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flat′</code> referred to the associated conventional basis. </p><p>See also the complementary method <a href="../bravais/#Bravais.primitivize-Tuple{Crystalline.AbstractFourierLattice, Char}"><code>primitivize(::AbstractFourierLattice, ::Char)</code></a> for additional details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/lattices.jl#LL297-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D" href="#Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(v′::AbstractVec, cntr::Char)  --&gt;  v::typeof(v′)</code></pre><p>Transforms a primitive coordinate vector <code>v′</code> back to a standard conventional basis (specified by the centering type <code>cntr</code>), returning the conventional coordinate vector <code>v</code>.</p><p>See also <a href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>primitivize</code></a> and <a href="#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{&lt;:Real}}"><code>transform</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL416-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.conventionalize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D" href="#Bravais.conventionalize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conventionalize(op′::SymOperation, cntr::Char, modw::Bool=true) --&gt; typeof(op)</code></pre><p>Return a symmetry operation <code>op</code> <span>$= \{W|w\}$</span> in a conventional setting, transformed from an input symmetry operation <code>op′</code> <span>$≡ \{W&#39;|w&#39;\}$</span> in a primitive setting.</p><p>See <a href="../bravais/#Bravais.primitivize-Tuple{SymOperation, Char, Bool}"><code>primitivize(::SymOperation, ::Char, ::Bool)</code></a> for description of the centering argument <code>cntr</code> and optional argument <code>modw</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL740-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D" href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(flat::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flat)</code></pre><p>Given <code>flat</code> referred to a conventional basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flat′</code> referred to the associated primitive basis. </p><p>Specifically, if <code>flat</code> refers to a direct conventional basis <code>Rs</code> <span>$≡ (\mathbf{a} \mathbf{b} \mathbf{c})$</span> [with coordinate vectors <span>$\mathbf{r} ≡ (r_1, r_2, r_3)^{\mathrm{T}}$</span>] then <code>flat′</code> refers to a direct primitive basis <code>Rs′</code> <span>$≡ (\mathbf{a}&#39; \mathbf{b}&#39; \mathbf{c}&#39;) ≡ (\mathbf{a} \mathbf{b} \mathbf{c})\mathbf{P}$</span> [with coordinate vectors  <span>$\mathbf{r}&#39; ≡ (r_1&#39;, r_2&#39;, r_3&#39;)^{\mathrm{T}} = \mathbf{P}^{-1}\mathbf{r}$</span>], where <span>$\mathbf{P}$</span> denotes the basis-change matrix obtained from <code>primitivebasismatrix(...)</code>.</p><p>To compute the associated primitive basis vectors, see <a href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>primitivize(::DirectBasis, ::Char)</code></a> [specifically, <code>Rs′ = primitivize(Rs, cntr)</code>].</p><p><strong>Examples</strong></p><p>A centered (&#39;c&#39;) lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires <code>using PyPlot</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 5; D = 2; cntr = centering(sgnum, D)  # &#39;c&#39; (body-centered)

julia&gt; Rs   = directbasis(sgnum, Val(D))     # conventional basis (rectangular)
julia&gt; flat = levelsetlattice(sgnum, Val(D)) # Fourier lattice in basis of Rs
julia&gt; flat = modulate(flat)                 # modulate the lattice coefficients
julia&gt; plot(flat, Rs)

julia&gt; Rs′   = primitivize(Rs, cntr)    # primitive basis (oblique)
julia&gt; flat′ = primitivize(flat, cntr)  # Fourier lattice in basis of Rs′

julia&gt; using PyPlot
julia&gt; plot(flat′, Rs′)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/lattices.jl#LL249-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D" href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(v::AbstractVec, cntr::Char)  --&gt;  v′::typeof(v)</code></pre><p>Transforms a conventional coordinate vector <code>v</code> to a standard primitive basis (specified by the centering type <code>cntr</code>), returning the primitive coordinate vector <code>v′</code>.</p><p>Note that a basis change matrix <span>$\mathbf{P}$</span> (as returned e.g. by <a href="../bravais/#Bravais.primitivebasismatrix"><code>Bravais.primitivebasismatrix</code></a>) transforms direct coordinate vectors (<a href="#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>RVec</code></a>) as <span>$\mathbf{r}&#39; = \mathbf{P}^{-1}\mathbf{r}$</span> but transforms reciprocal coordinates (<a href="#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>KVec</code></a>) as <span>$\mathbf{k}&#39; = \mathbf{P}^{\text{T}}\mathbf{k}$</span> <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>. Recall also the distinction between transforming a basis and the coordinates of a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL392-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.primitivize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D" href="#Bravais.primitivize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --&gt; typeof(op)</code></pre><p>Return a symmetry operation <code>op′</code> <span>$≡ \{W&#39;|w&#39;\}$</span> in a primitive setting, transformed from an input symmetry operation <code>op</code> <span>$= \{W|w\}$</span> in a conventional setting. The operations <span>$\{W&#39;|w&#39;\}$</span> and <span>$\{W|w\}$</span> are related by a transformation <span>$\{P|p\}$</span> via (cf. Section 1.5.2.3 of <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>):</p><p class="math-container">\[\{W&#39;|w&#39;\} = \{P|p\}⁻¹\{W|w\}\{P|p\}.\]</p><p>where <span>$P$</span> and <span>$p$</span> are the basis change matrix and origin shifts, respectively. The relevant transformation <span>$\{P|p\}$</span> is inferred from the centering type, as provided by <code>cntr</code> (see also <a href="../bravais/#Bravais.centering"><code>Bravais.centering</code></a>).</p><p>By default, translation parts of <code>op′</code>, i.e. <span>$w&#39;$</span> are reduced modulo 1 (<code>modw = true</code>); to disable this, set <code>modw = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL709-L729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{&lt;:Real}}" href="#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{&lt;:Real}}"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(v::AbstractVec, P::AbstractMatrix)  --&gt;  v′::typeof(v)</code></pre><p>Return a transformed coordinate vector <code>v′</code> from an original coordinate vector <code>v</code> using a basis change matrix <code>P</code>.</p><p>Note that a basis change matrix <span>$\mathbf{P}$</span> transforms direct coordinate vectors (<code>RVec</code>) as <span>$\mathbf{r}&#39; = \mathbf{P}^{-1}\mathbf{r}$</span> but transforms reciprocal coordinates (<code>KVec</code>) as <span>$\mathbf{k}&#39; = \mathbf{P}^{\mathrm{T}}\mathbf{k}$</span> <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL364-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bravais.transform-Union{Tuple{D}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}, Union{Nothing, AbstractVector{&lt;:Real}}}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}, Union{Nothing, AbstractVector{&lt;:Real}}, Bool}} where D" href="#Bravais.transform-Union{Tuple{D}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}, Union{Nothing, AbstractVector{&lt;:Real}}}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}, Union{Nothing, AbstractVector{&lt;:Real}}, Bool}} where D"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(op::SymOperation, P::AbstractMatrix{&lt;:Real}, 
          p::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
          modw::Bool=true)                           --&gt; SymOperation</code></pre><p>Transforms a <code>op</code> <span>$= \{\mathbf{W}|\mathbf{w}\}$</span> by a rotation matrix <code>P</code> and a translation vector <code>p</code> (can be <code>nothing</code> for zero-translations), producing a new symmetry operation  <code>op′</code> <span>$= \{\mathbf{W}&#39;|\mathbf{w}&#39;\}$</span> (cf. Section 1.5.2.3 of <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>)</p><p class="math-container">\[\{\mathbf{W}&#39;|\mathbf{w}&#39;\} = \{\mathbf{P}|\mathbf{p}\}^{-1}\{\mathbf{W}|\mathbf{w}\}
\{\mathbf{P}|\mathbf{p}\}\]</p><p>with</p><p class="math-container">\[\mathbf{W}&#39; = \mathbf{P}^{-1}\mathbf{W}\mathbf{P}
\text{ and }
\mathbf{w}&#39; = \mathbf{P}^{-1}(\mathbf{w}+\mathbf{W}\mathbf{p}-\mathbf{p})\]</p><p>By default, the translation part of <code>op′</code>, i.e. <span>$\mathbf{w}&#39;$</span>, is reduced to the range <span>$[0,1)$</span>, i.e. computed modulo 1. This can be disabled by setting <code>modw = false</code> (default, <code>modw = true</code>).</p><p>See also <a href="../bravais/#Bravais.primitivize-Tuple{SymOperation, Char, Bool}"><code>Bravais.primitivize(::SymOperation, ::Char, ::Bool)</code></a> and <a href="../bravais/#Bravais.conventionalize-Tuple{SymOperation, Char, Bool}"><code>Bravais.conventionalize(::SymOperation, ::Char, ::Bool)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL759-L790">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.bandreps" href="#Crystalline.bandreps"><code>Crystalline.bandreps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bandreps(sgnum::Integer, D::Integer=3; 
         allpaths::Bool=false, spinful::Bool=false, timereversal::Bool=true)</code></pre><p>Returns the elementary band representations (EBRs) as a <code>BandRepSet</code> for space group <code>sgnum</code> and dimension <code>D</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>allpaths</code>: include a minimal sufficient set (<code>false</code>, default) or all (<code>true</code>)              <strong>k</strong>-vectors. </li><li><code>spinful</code>: single- (<code>false</code>, default) or double-valued (<code>true</code>) irreps, as appropriate for            spinless and spinful particles, respectively. Only available for <code>D=3</code>.</li><li><code>timereversal</code>: assume presence (<code>true</code>, default) or absence (<code>false</code>) of time-reversal                 symmetry.</li></ul><p><strong>References</strong></p><p>3D EBRs are obtained from the Bilbao Crystallographic Server&#39;s  <a href="http://www.cryst.ehu.es/cgi-bin/cryst/programs/bandrep.pl">BANDREP program</a>; please reference the original research papers noted there if used in published work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/bandrep.jl#LL89-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.basisdim-Tuple{BandRepSet}" href="#Crystalline.basisdim-Tuple{BandRepSet}"><code>Crystalline.basisdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basisdim(BRS::BandRepSet) --&gt; Int</code></pre><p>Return the dimension of the (linearly independent parts) of a band representation set. This is <span>$d^{\text{bs}} = d^{\text{ai}}$</span> in the notation of <a href="https://doi.org/10.1038/s41467-017-00133-2">Po, Watanabe, &amp; Vishwanath, Nature Commun. <strong>8</strong>, 50 (2017)</a>, or  equivalently, the rank of <code>matrix(BRS)</code> over the ring of integers. This is the number of linearly independent basis vectors that span the expansions of a band structure viewed as symmetry data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/bandrep.jl#LL163-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.calc_reality-Union{Tuple{D}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}, Union{Nothing, Vector{&lt;:Real}}}} where D" href="#Crystalline.calc_reality-Union{Tuple{D}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}, Union{Nothing, Vector{&lt;:Real}}}} where D"><code>Crystalline.calc_reality</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_reality(lgir::LGIrrep, 
             sgops::AbstractVector{SymOperation{D}},
             αβγ::Union{Vector{&lt;:Real},Nothing}=nothing) --&gt; ::(Enum Reality)</code></pre><p>Compute and return the reality of a <code>lgir::LGIrrep</code> using the Herring criterion.</p><p>The computed value is one of three integers in <span>${1,-1,0}$</span>. In practice, this value is returned via a member of the Enum <code>Reality</code>, which has instances <code>REAL = 1</code>, <code>PSEUDOREAL = -1</code>, and <code>COMPLEX = 0</code>.</p><p><strong>Optional arguments</strong></p><p>As a sanity check, a value of <code>αβγ</code> can be provided to check for invariance along a symmetry symmetry line/plane/general point in k-space. The reality must be invariant to this choice.</p><p><strong>Note</strong></p><p>The provided space group operations <code>sgops</code> <strong>must</strong> be the set reduced by primitive translation vectors; i.e. using <code>spacegroup(...)</code> directly is <strong>not</strong> allowable in general (since the irreps we reference only include these &quot;reduced&quot; operations). This reduced set of operations can be obtained e.g. from the Γ point irreps of ISOTROPY&#39;s dataset, or alternatively, from <code>reduce_ops(spacegroup(...), true)</code>.</p><p><strong>Implementation</strong></p><p>The Herring criterion evaluates the following sum</p><p><span>$[∑ χ({β|b}²)]/[g_0/M(k)]$</span></p><p>over symmetry operations <span>${β|b}$</span> that take <span>$k → -k$</span>. Here <span>$g_0$</span> is the order of the point group of the space group and <span>$M(k)$</span> is the order of star(<span>$k$</span>) [both in a primitive basis].</p><p>See e.g. Cornwell, p. 150-152 &amp; 187-188 (which we mainly followed), Inui Eq. (13.48),  Dresselhaus, p. 618, or <a href="https://doi.org/10.1103/PhysRev.52.361">Herring&#39;s original paper</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/irreps_reality.jl#LL337-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.characters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D" href="#Crystalline.characters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D"><code>Crystalline.characters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">characters(irs::AbstractVector{&lt;:AbstractIrrep}, αβγ=nothing)</code></pre><p>Compute the character table associated with vector of <code>AbstractIrrep</code>s <code>irs</code>, returning a <code>CharacterTable</code>.</p><p><strong>Optional arguments</strong></p><p>Optionally, an <code>αβγ::AbstractVector{&lt;:Real}</code> variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for <code>LGIrrep</code>s, a concrete <strong>k</strong>-vector sampled from a &quot;line-irrep&quot;). Defaults to <code>nothing</code>, indicating it being either  irrelevant (e.g., for <code>PGIrrep</code>s) or all free parameters implicitly set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL806-L818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.classcharacters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D" href="#Crystalline.classcharacters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D"><code>Crystalline.classcharacters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">classcharacters(irs::AbstractVector{&lt;:AbstractIrrep}, αβγ=nothing)</code></pre><p>Compute the character table associated with the conjugacy classes of a vector of <code>AbstractIrrep</code>s <code>irs</code>, returning a <code>ClassCharacterTable</code>.</p><p>Since characters depend only on the conjugacy class (this is not true for ray, or projective, irreps), the class-specific characters often more succintly communicate the same information as the characters for each operation (as returned by <a href="#Crystalline.characters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D"><code>characters</code></a>).</p><p>See also: <a href="#Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D"><code>classes</code></a>.</p><p><strong>Optional arguments</strong></p><p>Optionally, an <code>αβγ::AbstractVector{&lt;:Real}</code> variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for <code>LGIrrep</code>s, a concrete <strong>k</strong>-vector sampled from a &quot;line-irrep&quot;). Defaults to <code>nothing</code>, indicating it being either  irrelevant (e.g., for <code>PGIrrep</code>s) or all free parameters implicitly set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL839-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D" href="#Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D"><code>Crystalline.classes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">classes(ops::AbstractVector{SymOperation{D}}, [cntr::Union{Char, Nothing}])
                                                --&gt;  Vector{Vector{SymOperation{D}}}</code></pre><p>Return the conjugacy classes of a group <span>$G$</span> defined by symmetry operations <code>ops</code>.</p><p><strong>Definitions</strong></p><p>Two elements <span>$a$</span> and <span>$b$</span> in <span>$G$</span> are considered conjugate if there exists a <span>$g ∈ G$</span> such that <span>$gag^{-1} = b$</span>. This defines an equivalence relation <span>$\sim$</span>, i.e., we say that <span>$a \sim b$</span> if <span>$a$</span> and <span>$b$</span> are conjugate. The conjugacy classes of <span>$G$</span> are the distinct equivalence classes that can be identified under this equivalence relation, i.e. the grouping of <span>$G$</span> into subsets that are equivalent under conjugacy.</p><p><strong>Extended help</strong></p><p>If <code>ops</code> describe operations in a crystal system that is not primitive (i.e., if its <a href="../bravais/#Bravais.centering"><code>centering</code></a> type is not <code>p</code> or <code>P</code>) but is presented in a conventional setting, the centering symbol <code>cntr</code> <em>must</em> be given. If <code>ops</code> is not in a centered crystal system, or if <code>ops</code> is already reduced to a primitive setting, <code>cntr</code> should be given as <code>nothing</code> (default behavior) or, alternatively, as <code>P</code> or <code>p</code> (depending on dimensionality).</p><p>A single-argument calls to <code>classes</code> with <code>SpaceGroup</code> or <code>LittleGroup</code> types will assume that <code>ops</code> is provided in a conventional setting, i.e., will forward the method call to <code>classes(ops, centering(ops, dim(ops)))</code>. To avoid this behavior (if <code>ops</code> was already reduced to a primitive setting prior to calling <code>classes</code>), <code>cntr</code> should be provided explicitly as <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/conjugacy.jl#LL1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.classification-Tuple{AbstractVector{&lt;:Integer}}" href="#Crystalline.classification-Tuple{AbstractVector{&lt;:Integer}}"><code>Crystalline.classification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">classification(BRS_or_F::Union{BandRepSet, Smith}) --&gt; String</code></pre><p>Return the symmetry indicator group <span>$X^{\text{BS}}$</span> of an EBR basis <code>F_or_BRS</code>, provided as a <code>BandRepSet</code> or <code>Smith</code> decomposition.</p><p>Technically, the calculation answers the question &quot;what direct product of  <span>$\mathbb{Z}_n$</span> groups is the the quotient group <span>$X^{\text{BS}} = \{\text{BS}\}/\{\text{AI}\}$</span> isomorphic to?&quot; (see <a href="https://doi.org/10.1038/s41467-017-00133-2">Po, Watanabe, &amp; Vishwanath, Nature Commun. <strong>8</strong>, 50 (2017)</a> for more information).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/bandrep.jl#LL140-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, KVec{D}}, Tuple{SymOperation{D}, KVec{D}, Bool}} where D" href="#Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, KVec{D}}, Tuple{SymOperation{D}, KVec{D}, Bool}} where D"><code>Crystalline.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compose(op::SymOperation, kv::KVec[, checkabc::Bool=true])  --&gt;  KVec</code></pre><p>Return the composition <code>op</code> <span>$= \{\mathbf{W}|\mathbf{w}\}$</span> and a reciprocal-space vector <code>kv</code> <span>$= \mathbf{k}$</span>.</p><p>The operation is taken to act directly, returning</p><p class="math-container">\[    \mathbf{k}&#39; = \{\mathbf{W}|\mathbf{w}\}\mathbf{k} = \mathbf{W}^{\text{T}}\mathbf{k}.\]</p><p>Note the transposition of <span>$\mathbf{W}$</span>, arising as a result of the implicit real-space basis of <span>$\{\mathbf{W}|\mathbf{w}\}$</span> versus the reciprocal-space basis specification of <span>$\mathbf{k}$</span>. Note also that the composition of <span>$\{\mathbf{W}|\mathbf{w}\}$</span> with <span>$\mathbf{k}$</span> is invariant under <span>$\mathbf{w}$</span>, i.e., translations do not act in reciprocal space.</p><p><strong>Extended help</strong></p><p>If <code>checkabc = false</code>, the free part of <code>KVec</code> is not transformed (can be improve  performance in situations when <code>kabc</code> is zero, and several transformations are requested).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL656-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, RVec{D}}} where D" href="#Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, RVec{D}}} where D"><code>Crystalline.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compose(op::SymOperation, rv::RVec)  --&gt;  RVec</code></pre><p>Return the composition of <code>op</code> <span>$= \{\mathbf{W}|\mathbf{w}\}$</span> and a real-space vector <code>rv</code> <span>$= \mathbf{r}$</span>.</p><p>The operation is taken to act directly, returning</p><p class="math-container">\[    \mathbf{r}&#39; = \{\mathbf{W}|\mathbf{w}\}\mathbf{r} = \mathbf{W}\mathbf{r} + \mathbf{w}.\]</p><p>The corresponding inverse action <span>$\{\mathbf{W}|\mathbf{w}\}^{-1}\mathbf{r} =  \mathbf{W}^{-1}\mathbf{r} - \mathbf{W}^{-1}\mathbf{w}$</span> can be obtained via  <code>compose(inv(op), rv)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL684-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.compose-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Bool}} where T&lt;:SymOperation" href="#Crystalline.compose-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Bool}} where T&lt;:SymOperation"><code>Crystalline.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compose(op1::T, op2::T, modτ::Bool=true) where T&lt;:SymOperation</code></pre><p>Compose two symmetry operations <code>op1</code> <span>$= \{W₁|w₁\}$</span> and <code>op2</code> <span>$= \{W₂|w₂\}$</span> using the composition rule (in Seitz notation)</p><p><span>$\{W₁|w₁\}\{W₂|w₂\} = \{W₁W₂|w₁+W₁w₂\}$</span></p><p>By default, the translation part of the <span>$\{W₁W₂|w₁+W₁w₂\}$</span> is reduced to the range <span>$[0,1[$</span>, i.e. computed modulo 1. This can be toggled off (or on) by the Boolean flag <code>modτ</code> (enabled, i.e. <code>true</code>, by default). Returns another <code>SymOperation</code>.</p><p>The multiplication operator <a href="@ref"><code>*</code></a> is overloaded for <code>SymOperation</code>s to call <code>compose</code>, in the manner <code>op1 * op2 = compose(op1, op2, modτ=true)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL367-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.cosets-Tuple{SiteGroup}" href="#Crystalline.cosets-Tuple{SiteGroup}"><code>Crystalline.cosets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cosets(g::SiteGroup) -&gt; Array{SymOperation{D}, 1} where D
</code></pre><p>Return the cosets of a <code>SiteGroup</code> <code>g</code>.</p><p>The cosets generate the orbit of the Wyckoff position <code>position(g)</code> (see <a href="#Crystalline.orbit-Tuple{SiteGroup}"><code>orbit(::SiteGroup)</code></a>) and furnish a left-coset decomposition of the underlying space group, jointly with the operations in <code>g</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.dim-Tuple{BandRep}" href="#Crystalline.dim-Tuple{BandRep}"><code>Crystalline.dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dim(BR::BandRep) --&gt; Int</code></pre><p>Return the number of bands included in the provided <code>BandRep</code>.</p><p>If the bands are &quot;nondetachable&quot; (i.e. if <code>BR.decomposable = false</code>), this is equal to a band connectivity μ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL897-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.find_isomorphic_parent_pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D" href="#Crystalline.find_isomorphic_parent_pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>Crystalline.find_isomorphic_parent_pointgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_isomorphic_parent_pointgroup(g::AbstractVector{SymOperation{D}}) 
                                                --&gt; PointGroup{D}, Vector{Int}, Bool</code></pre><p>Given a group <code>g</code> (or a collection of operators, defining a group), identifies a &quot;parent&quot; point group that is isomorphic to <code>g</code>.</p><p>Three variables are returned:</p><ul><li><code>pg</code>: the identified &quot;parent&quot; point group, with operators sorted to match the sorting of <code>g</code>&#39;s operators.</li><li><code>Iᵖ²ᵍ</code>: a permutation vector which transforms the standard sorting of point group operations (as returned by <a href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>pointgroup(::String)</code></a>) to the operator sorting of <code>g</code>.</li><li><code>equal</code>: a boolean, identifying whether the point group parts of <code>g</code> operations are identical (<code>true</code>) or merely isomorphic to the point group operations in <code>g</code>. In practice, this indicates whether <code>pg</code> and <code>g</code> are in the same setting or not.</li></ul><p><strong>Implementation</strong></p><p>The identification is made partly on the basis of comparison of operators (this is is sufficient for the <code>equal = true</code> case) and partly on the basis of comparison of  multiplication tables (<code>equal = false</code> case); the latter can be combinatorially slow if the sorting of operators is unlucky (i.e., if permutation between sortings in <code>g</code> and <code>pg</code> differ by many pairwise permutations).</p><p>Beyond mere isomorphisms of multiplication tables, the search also guarantees that all rotation orders are shared between <code>pg</code> and <code>g</code>. This disambiguates point groups that are intrinsically isomorphic to eachother, e.g. &quot;m&quot; and &quot;-1&quot;, but which still differ in their spatial interpretation.</p><p><strong>Properties</strong></p><p>The following properties hold for <code>g</code>, <code>pg</code>, and <code>Iᵖ²ᵍ</code>:</p><pre><code class="language-jl hljs">pg, Iᵖ²ᵍ, equal = find_isomorphic_parent_pointgroup(g)
@assert MultTable(pg) == MultTable(pointgroup(g))
pg′ = pointgroup(label(pg), dim(pg)) # &quot;standard&quot; sorting
@assert pg′[Iᵖ²ᵍ] == pg</code></pre><p>If <code>equal = true</code>, the following also holds:</p><pre><code class="language-jl hljs">pointgroup(g) == operations(pg) == operations(pg′)[Iᵖ²ᵍ]</code></pre><p><strong>Example</strong></p><pre><code class="language-jl hljs">sgnum = 141
wp    = wyckoffs(sgnum, Val(3))[end] # 4a Wyckoff position
sg    = spacegroup(sgnum, Val(3))
siteg = sitegroup(sg, wp)
pg, Iᵖ²ᵍ, equal = find_isomorphic_parent_pointgroup(siteg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/pointgroup.jl#LL253-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.find_representation" href="#Crystalline.find_representation"><code>Crystalline.find_representation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_representation(symvals::AbstractVector{Number}, 
                    lgirs::AbstractVector{&lt;:AbstractIrrep},
                    αβγ::Union{AbstractVector{&lt;:Real},Nothing}=nothing,
                    assert_return_T::Type{&lt;:Union{Integer, AbstractFloat}}=Int),
                    atol::Real=DEFAULT_ATOL,
                    maxresnorm::Real=1e-3,
                    verbose::Bool=false)

                    --&gt; Vector{assert_return_T}</code></pre><p>From a vector (or vector of vectors) of symmetry eigenvalues <code>symvals</code> sampled along all the operations of a group gᵢ, whose irreps are contained in <code>irs</code> (evaluated with optional free  parameters <code>αβγ</code>), return the multiplicities of each irrep.</p><p>Optionally, the multiciplities&#39; element type can be specified via the <code>assert_return_T</code> argument (performing checked conversion; returns <code>nothing</code> if representation in  <code>assert_return_T</code> is impossible). This can be useful if one suspects a particular band to  transform like a fraction of an irrep (i.e., the specified symmetry data is incomplete).</p><p>If no valid set of multiplicities exist (i.e., is solvable, and has real-valued and <code>assert_return_T</code> representible type), the sentinel value <code>nothing</code> is returned. Optional debugging information can in this case be shown by setting <code>verbose=true</code>.</p><p><strong>Extended help</strong></p><p>Effectively, this applies the projection operator P⁽ʲ⁾ of each irrep&#39;s character set χ⁽ʲ⁾(gᵢ) (j = 1, ... , Nⁱʳʳ) to the symmetry data sᵢ ≡ <code>symvals</code>:</p><pre><code class="nohighlight hljs">P⁽ʲ⁾  ≡ (dⱼ/|g|) ∑ᵢ χ⁽ʲ⁾(gᵢ)*gᵢ         [characters χ⁽ʲ⁾(gᵢ), irrep dimension dⱼ]
P⁽ʲ⁾s = (dⱼ/|g|) ∑ᵢ χ⁽ʲ⁾(gᵢ)*sᵢ = nⱼ,   [number of bands that transform like jth irrep]</code></pre><p>returning the irrep multiplicities mⱼ ≡ nⱼ/dⱼ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symeigs2irrep.jl#LL1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.findmaximal-Union{Tuple{AbstractArray{SiteGroup{D}, 1}}, Tuple{D}} where D" href="#Crystalline.findmaximal-Union{Tuple{AbstractArray{SiteGroup{D}, 1}}, Tuple{D}} where D"><code>Crystalline.findmaximal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findmaximal(sitegs::AbstractVector{&lt;:SiteGroup})</code></pre><p>Given a vector of <code>SiteGroup</code>s associated with the Wyckoff positions of a space group, return those <code>SiteGroup</code>s that are associated with a maximal Wyckoff positions.</p><p>Results are returned as a <code>view</code> into the input vector (i.e. as an  <code>AbstractVector{&lt;:SiteGroup}</code>). The associated Wyckoff positions can subsequently be retrieved via <a href="@ref"><code>wyck</code></a>.</p><p><strong>Definition</strong></p><p>A Wyckoff position is maximal if its site symmetry group has higher order than the site symmetry groups of any &quot;nearby&quot; Wyckoff positions (i.e. Wyckoff positions that can be  connected, i.e. made equivalent, through parameter variation to the considered Wyckoff position).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 5;

julia&gt; D = 2;

julia&gt; wps = wyckoffs(sgnum, Val(D));

julia&gt; sg  = spacegroup(sgnum, Val(D));


julia&gt; sitegs = sitegroup.(Ref(sg), wps)
2-element Vector{SiteGroup{2}}:
 [1] (4b: [α, β])
 [1, m₁₀] (2a: [0, β])

julia&gt; only(findmaximal(sitegs))
SiteGroup{2} ⋕5 (c1m1) at 2a = [0, β] with 2 operations:
 1
 m₁₀</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/wyckoff.jl#LL204-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D" href="#Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>Crystalline.generate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate a group from a finite set of generators <code>gens</code>. Returns a <code>GenericGroup</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>modτ</code> (default, <code>true</code>): the group composition operation can either be taken modulo lattice vectors (<code>true</code>) or not (<code>false</code>, useful e.g. for site symmetry groups). In this case, the provided generators will also be taken modulo integer lattice translations.</li><li><code>Nmax</code> (default, <code>256</code>): the maximum size of the generated group. This is essentially a cutoff set to ensure halting of execution in case the provided set of generators do not define a <em>finite</em> group (especially relevant if <code>modτ=false</code>). If more operations than <code>Nmax</code> are generated, the method throws an overflow error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL1064">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.generators-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D" href="#Crystalline.generators-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D"><code>Crystalline.generators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generators(num::Integer, T::Type{AbstractGroup{D}}[, optargs])
generators(pgiuc::String, T::PointGroup{D}})              --&gt;  Vector{SymOperation{D}}</code></pre><p>Return the generators of the group type <code>T</code> which may be a <code>SpaceGroup{D}</code> or a  <code>PointGroup{D}</code> parameterized by its dimensionality <code>D</code>. Depending on <code>T</code>, the group is determined by inputting as the first argument:</p><ul><li><code>SpaceGroup{D}</code>: the space group number <code>num::Integer</code>.</li><li><code>PointGroup{D}</code>: the point group IUC label <code>pgiuc::String</code> (see also [<code>pointgroup(::String)</code>) or the canonical point group number <code>num::Integer</code>, which can optionally be supplemented by an integer-valued setting choice <code>setting::Integer</code> (see also <a href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>pointgroup(::Integer, ::Integer, ::Integer)</code></a>]).</li><li><code>SubperiodicGroup{D}</code>: the subperiodic group number <code>num::Integer</code>.</li></ul><p>Setting choices match those in <a href="#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D"><code>spacegroup</code></a>, <a href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>pointgroup</code></a>, and <a href="#Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}"><code>subperiodicgroup</code></a>.</p><p>Iterated composition of the returned symmetry operations will generate all operations of the associated space or point group (see <a href="#Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>generate</code></a>). As an example, <code>generate(generators(num,</code>SpaceGroup{D}))<code>and</code>spacegroup(num, D)` return identical operations (with different sorting typically); and similarly so for point and subperiodic groups.</p><p><strong>Example</strong></p><p>Generators of space group 200:</p><pre><code class="language-julia-repl hljs">julia&gt; generators(200, SpaceGroup{3})
4-element Vector{SymOperation{3}}:
 2₀₀₁
 2₀₁₀
 3₁₁₁⁺
 -1</code></pre><p>Generators of point group m-3m:</p><pre><code class="language-julia-repl hljs">julia&gt; generators(&quot;2/m&quot;, PointGroup{3})
2-element Vector{SymOperation{3}}:
 2₀₁₀
 -1</code></pre><p>Generators of the Frieze group 𝓅2mg:</p><pre><code class="language-julia-repl hljs">julia&gt; generators(7, SubperiodicGroup{2, 1})
2-element Vector{SymOperation{2}}:
 2
 {m₁₀|½,0}</code></pre><p><strong>Citing</strong></p><p>Please cite the original data sources if used in published work:</p><ul><li>Space groups: <a href="https://doi.org/10.1524/zkri.2006.221.1.15">Aroyo et al., Z. Kristallogr. Cryst. Mater. <strong>221</strong>, 15 (2006)</a>;</li><li>Point group: Bilbao Crystallographic Server&#39;s <a href="https://www.cryst.ehu.es/cryst/get_point_genpos.html">2D and 3D GENPOS</a>;</li><li>Subperiodic groups: Bilbao Crystallographic Server&#39;s <a href="https://www.cryst.ehu.es/subperiodic/get_sub_gen.html">SUBPERIODIC GENPOS</a>.</li></ul><p><strong>Extended help</strong></p><p>Note that the returned generators are not guaranteed to be the smallest possible set of generators; i.e., there may exist other generators with fewer elements (an example is space group 168 (P6), for which the returned generators are <code>[2₀₀₁, 3₀₀₁⁺]</code> even though the group could be generated by just <code>[6₀₀₁⁺]</code>). The returned generators, additionally, are not guaranteed to be <a href="https://en.wikipedia.org/wiki/Generating_set_of_a_module">minimal</a>, i.e., they may include proper subsets that generate the group themselves (e.g., in space group 75 (P4), the returned generators are <code>[2₀₀₁, 4₀₀₁⁺]</code> although the subset <code>[4₀₀₁⁺]</code> is sufficient to generate the group). The motivation for this is to expose as similar generators as possible for similar crystal systems (see e.g. Section 8.3.5 of the International Tables of Crystallography, Vol. A, Ed. 5 (ITA) for further background).</p><p>Note also that, contrary to conventions in ITA, the identity operation is excluded among the returned generators (except in space group 1) since it composes trivially and adds no additional context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL94-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.generators-Union{Tuple{P}, Tuple{D}, Tuple{Integer, Type{SubperiodicGroup{D, P}}}} where {D, P}" href="#Crystalline.generators-Union{Tuple{P}, Tuple{D}, Tuple{Integer, Type{SubperiodicGroup{D, P}}}} where {D, P}"><code>Crystalline.generators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generators(num::Integer, ::Type{SubperiodicGroup{D,P}})  --&gt;  ::Vector{SymOperation{D}}</code></pre><p>Return a canonical set of generators for the subperiodic group <code>num</code> of embedding dimension <code>D</code> and periodicity dimension <code>P</code>. See also <a href="#Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}"><code>subperiodicgroup</code></a>.</p><p>See also <a href="@ref"><code>generators(::Integer, ::Type{SpaceGroup{D}})</code></a> and information therein.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generators(7, SubperiodicGroup{2, 1})
2-element Vector{SymOperation{2}}:
 2
 {m₁₀|½,0}</code></pre><p><strong>Data sources</strong></p><p>The generators returned by this function were originally retrieved from the <a href="https://www.cryst.ehu.es/subperiodic/get_sub_gen.html">Bilbao Crystallographic Database, SUBPERIODIC GENPOS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/subperiodic.jl#LL273-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.is_abelian-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D" href="#Crystalline.is_abelian-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D"><code>Crystalline.is_abelian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_abelian(ops::AbstractVector{SymOperation}, [cntr::Union{Char, Nothing}])  --&gt;  Bool</code></pre><p>Return the whether the group composed of the elements <code>ops</code> is Abelian.</p><p>A group <span>$G$</span> is Abelian if all its elements commute mutually, i.e., if <span>$g = hgh^{-1}$</span> for all <span>$g,h ∈ G$</span>.</p><p>See discussion of the setting argument <code>cntr</code> in <a href="#Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D"><code>classes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/conjugacy.jl#LL104-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.isnormal-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D" href="#Crystalline.isnormal-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D"><code>Crystalline.isnormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnormal(opsᴳ::AbstractVector{&lt;:SymOperation},
         opsᴴ::AbstractVector{&lt;:SymOperation};
         verbose::Bool=false)                    --&gt; Bool</code></pre><p>Determine whether the operations in group <span>$H$</span> are normal in the group <span>$G$</span> (each with  operations <code>opsᴳ</code> and <code>opsᴴ</code>), in the sense that </p><p class="math-container">\[ghg⁻¹ ∈ H, ∀ g∈G, ∀ h∈H\]</p><p>Returns a Boolean answer (<code>true</code> if normal, <code>false</code> if not).</p><p><strong>Note</strong></p><p>This compares space groups rather than space group types, i.e. the comparison assumes a matching setting choice between <span>$H$</span> and <span>$G$</span>. To compare space group types with different conventional settings, they must first be transformed to a shared setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL1022-L1040">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.israyrep" href="#Crystalline.israyrep"><code>Crystalline.israyrep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">israyrep(lgir::LGIrrep, αβγ=nothing) -&gt; (::Bool, ::Matrix)</code></pre><p>Computes whether a given little group irrep <code>ir</code> is a ray representation  by computing the coefficients αᵢⱼ in DᵢDⱼ=αᵢⱼDₖ; if any αᵢⱼ differ  from unity, we consider the little group irrep a ray representation (as opposed to the simpler &quot;vector&quot; representations where DᵢDⱼ=Dₖ). The function returns a boolean (true =&gt; ray representation) and the coefficient matrix αᵢⱼ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL744-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issubgroup-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D" href="#Crystalline.issubgroup-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D"><code>Crystalline.issubgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issubgroup(opsᴳ::T, opsᴴ::T′) where T⁽′⁾&lt;:AbstractVector{SymOperation} --&gt; Bool</code></pre><p>Determine whether the operations in group <span>$H$</span> are a subgroup of the group <span>$G$</span> (each with  operations <code>opsᴳ</code> and <code>opsᴴ</code>, respectively), i.e. whether <span>$H&lt;G$</span>. Specifically, this requires that <span>$G$</span> and <span>$H$</span> are both groups and that for every <span>$h∈H$</span> there exists an element <span>$g∈G$</span> such that <span>$h=g$</span>.</p><p>Returns a Boolean answer (<code>true</code> if normal, <code>false</code> if not).</p><p><strong>Note</strong></p><p>This compares space groups rather than space group types, i.e. the comparison assumes a matching setting choice between <span>$H$</span> and <span>$G$</span>. To compare space group types with different conventional settings, they must first be transformed to a shared setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL976-L990">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph" href="#Crystalline.issymmorph"><code>Crystalline.issymmorph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issymmorph(sgnum::Integer, D::Integer=3) --&gt; Bool</code></pre><p>Return whether the space group with number <code>sgnum</code> and dimensionality <code>D</code> is symmorphic  (<code>true</code>) or nonsymmorphic (<code>false</code>).</p><p>Equivalent to <code>issymmorph(spacegroup(sgnum, D))</code> but uses memoization for performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL316-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph-Tuple{Crystalline.AbstractGroup}" href="#Crystalline.issymmorph-Tuple{Crystalline.AbstractGroup}"><code>Crystalline.issymmorph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issymmorph(sg::Union{SpaceGroup, LittleGroup}) --&gt; Bool</code></pre><p>Return whether a given space group <code>sg</code> is symmorphic (<code>true</code>) or nonsymmorphic (<code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL306-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph-Union{Tuple{D}, Tuple{SymOperation{D}, Char}} where D" href="#Crystalline.issymmorph-Union{Tuple{D}, Tuple{SymOperation{D}, Char}} where D"><code>Crystalline.issymmorph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issymmorph(op::SymOperation, cntr::Char) --&gt; Bool</code></pre><p>Return whether a given symmetry operation <code>op</code> is symmorphic (<code>true</code>) or nonsymmorphic (<code>false</code>). </p><p>The operation is assumed provided in conventional basis with centering type <code>cntr</code>:  checking symmorphism is then equivalent to checking whether the operation&#39;s translation part is zero or a lattice vector in the associated primitive basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL290-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.iuc" href="#Crystalline.iuc"><code>Crystalline.iuc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iuc(sgnum::Integer, D::Integer=3) --&gt; String</code></pre><p>Return the IUC (International Union of Crystallography) notation for space group number <code>sgnum</code> in dimension <code>D</code> (1, 2, or 3), as used in the International Tables of Crystallography.</p><p>The notation is sometimes also known as the <a href="https://en.wikipedia.org/wiki/Hermann–Mauguin_notation">Hermann-Mauguin notation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/notation.jl#LL12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.levelsetlattice-Union{Tuple{Integer}, Tuple{D′}, Tuple{Integer, Integer}, Tuple{Integer, Integer, Tuple{Vararg{Int64, D′}}}} where D′" href="#Crystalline.levelsetlattice-Union{Tuple{Integer}, Tuple{D′}, Tuple{Integer, Integer}, Tuple{Integer, Integer, Tuple{Vararg{Int64, D′}}}} where D′"><code>Crystalline.levelsetlattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">levelsetlattice(sgnum::Integer, D::Integer=2, idxmax::NTuple=ntuple(i-&gt;2,D))
    --&gt; UnityFourierLattice{D}</code></pre><p>Compute a &quot;neutral&quot;/uninitialized Fourier lattice basis, a <a href="../lattices/#Crystalline.UnityFourierLattice"><code>UnityFourierLattice</code></a>, consistent with the symmetries of the space group <code>sgnum</code> in dimension <code>D</code>.  The resulting lattice <code>flat</code> is expanded in a Fourier basis split into symmetry-derived orbits, with intra-orbit coefficients constrained by the symmetries of the space-group. The inter-orbit coefficients are, however, free and unconstrained.</p><p>The Fourier resolution along each reciprocal lattice vector is controlled by <code>idxmax</code>: e.g., if <code>D = 2</code> and <code>idxmax = (2, 3)</code>, the resulting Fourier lattice may contain  reciprocal lattice vectors (k₁, k₂) with k₁∈[0,±1,±2] and k₂∈[0,±1,±2,±3], referred  to a 𝐆-basis.</p><p>This &quot;neutral&quot; lattice can, and usually should, be subsequently modulated by <a href="../lattices/#Crystalline.modulate"><code>modulate</code></a> (which modulates the inter-orbit coefficients, which may eliminate &quot;synthetic symmetries&quot; that can exist in the &quot;neutral&quot; configuration, due to all  inter-orbit coefficients being set to unity).</p><p><strong>Examples</strong></p><p>Compute a <code>UnityFourierLattice</code>, modulate it with random inter-orbit coefficients  via <code>modulate</code>, and finally plot it (via PyPlot.jl):</p><pre><code class="language-julia-repl hljs">julia&gt; uflat = levelsetlattice(16, Val(2))
julia&gt; flat  = modulate(uflat)
julia&gt; Rs    = directbasis(16, Val(2)) 
julia&gt; using PyPlot
julia&gt; plot(flat, Rs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/lattices.jl#LL48-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D" href="#Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D"><code>Crystalline.lgirreps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lgirreps(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3))
                                                -&gt; Dict{String, Vector{LGIrrep{D}}}</code></pre><p>For given space group number <code>sgnum</code> and dimension <code>D</code>, return the associated little group (or &quot;small&quot;) irreps (<code>LGIrrep{D}</code>s) at high-symmetry k-points, lines, and planes. </p><p>Returns a <code>Dict</code> with little group <strong>k</strong>-point labels as keys and vectors of <code>LGIrrep{D}</code>s as values.</p><p><strong>Notes</strong></p><ul><li>The returned irreps are complex in general. Real irreps (as needed in time-reversal invariant settings) can subsequently be obtained with the <a href="#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D}, 1}}, Tuple{D}} where D"><code>realify</code></a> method.</li><li>Returned irreps are spinless.</li><li>The irrep labelling follows CDML conventions.</li><li>Irreps along lines or planes may depend on free parameters <code>αβγ</code> that parametrize the <strong>k</strong> point. To evaluate the irreps at a particular value of <code>αβγ</code> and return the associated matrices, use <code>(lgir::LGIrrep)(αβγ)</code>. If <code>αβγ</code> is an empty tuple in this call, the matrices associated with <code>lgir</code> will be evaluated assuming <code>αβγ = [0,0,...]</code>.</li></ul><p><strong>References</strong></p><p>The underlying data is sourced from the ISOTROPY ISO-IR dataset. Please cite original reference material associated with ISO-IR:</p><ol><li>Stokes, Hatch, &amp; Campbell,  <a href="https://stokes.byu.edu/iso/irtables.php">ISO-IR, ISOTROPY Software Suite</a>.</li><li>Stokes, Campbell, &amp; Cordes, <a href="https://doi.org/10.1107/S0108767313007538">Acta Cryst. A. <strong>69</strong>, 388-395 (2013)</a>.</li></ol><p>The ISO-IR dataset is occasionally missing some <strong>k</strong>-points that lie outside the basic domain but still resides in the representation domain (i.e. <strong>k</strong>-points with postscripted &#39;A&#39;, &#39;B&#39;, etc. labels, such as &#39;ZA&#39;). In such cases, the missing irreps may instead have been manually sourced from the Bilbao Crystallographic Database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/littlegroup_irreps.jl#LL46-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}} where D" href="#Crystalline.littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}} where D"><code>Crystalline.littlegroups</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">littlegroups(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3)) 
                                                    -&gt; Dict{String, LittleGroup{D}}</code></pre><p>For given space group number <code>sgnum</code> and dimension <code>D</code>, return the associated little groups (<code>LittleGroups{D}</code>s) at high-symmetry k-points, lines, and planes (see also <a href="#Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D"><code>lgirreps</code></a>).</p><p>Returns a <code>Dict</code> with little group <strong>k</strong>-point labels as keys and vectors of <code>LittleGroup{D}</code>s as values.</p><p><strong>Notes</strong></p><p>A conventional crystallographic setting is assumed (as in <a href="#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D"><code>spacegroup</code></a>).</p><p>Unlike <code>spacegroup</code>, &quot;centering&quot;-copies of symmetry operations are not included in the returned <code>LittleGroup</code>s; as an example, space group 110 (body-centered, with centering symbol &#39;I&#39;) has a centering translation <code>[1/2,1/2,1/2]</code> in the conventional setting: the symmetry operations returned by <code>spacegroup</code> thus includes e.g. both <code>{1|0}</code> and  <code>{1|½,½,½}</code> while the symmetry operations returned by <code>littlegroups</code> only include <code>{1|0}</code> (and so on).</p><p>Currently, only <code>D = 3</code> is supported.</p><p><strong>References</strong></p><p>The underlying data is sourced from the ISOTROPY dataset: see also <a href="#Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D"><code>lgirreps</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/littlegroup_irreps.jl#LL2-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.matrix-Tuple{BandRepSet}" href="#Crystalline.matrix-Tuple{BandRepSet}"><code>Crystalline.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(BRS::BandRepSet; includedim::Bool=true)</code></pre><p>Return a matrix representation of <code>BRS::BandRepSet</code>, with band representations as columns  and irreps over rows.</p><p>By default, the last row will give the &quot;filling&quot; of each <code>BandRep</code> (or, more precisely, number of included bands per <code>BandRep</code>, i.e. <code>dim.(BRS)</code>. To toggle this off, set the keyword argument <code>includedim</code> to <code>false</code> (default is <code>includedim = true</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/types.jl#LL949-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}, Union{Nothing, Real}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}, Union{Nothing, Real}, Union{Nothing, ReciprocalBasis{D}}}} where D" href="#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}, Union{Nothing, Real}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}, Union{Nothing, Real}, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>Crystalline.modulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modulate(flat::UnityFourierLattice{D},
modulation::AbstractVector{ComplexF64}=rand(ComplexF64, length(getcoefs(flat))),
expon::Union{Nothing, Real}=nothing, Gs::Union{ReciprocalBasis{D}, Nothing}=nothing)
                        --&gt; ModulatedFourierLattice{D}</code></pre><p>Derive a concrete, modulated Fourier lattice from a <code>UnityFourierLattice</code> <code>flat</code> (containing the <em>interrelations</em> between orbit coefficients), by  multiplying the &quot;normalized&quot; orbit coefficients by a <code>modulation</code>, a <em>complex</em> modulating vector (in general, should be complex; otherwise restores unintended symmetry to the lattice). Distinct <code>modulation</code> vectors produce distinct  realizations of the same lattice described by the original <code>flat</code>. By default, a random complex vector is used.</p><p>An exponent <code>expon</code> can be provided, which introduces a penalty term to short- wavelength features (i.e. high-|G| orbits) by dividing the orbit coefficients by |G|^<code>expon</code>; producing a &quot;simpler&quot; and &quot;smoother&quot; lattice boundary when <code>expon &gt; 0</code> (reverse for <code>expon &lt; 0</code>). This basically amounts to a  continuous &quot;simplifying&quot; operation on the lattice (it is not necessarily a  smoothing operation; it simply suppresses &quot;high-frequency&quot; components). If <code>expon = nothing</code>, no rescaling is performed. If <code>Gs</code> is provided as <code>nothing</code>, the orbit norm is computed in the reciprocal lattice basis (and, so, may not strictly speaking be a norm if the lattice basis is not cartesian); to account for the basis explicitly, <code>Gs</code> must be provided as a <a href="../bravais/#Bravais.ReciprocalBasis"><code>ReciprocalBasis</code></a>, see also <a href="#Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>normscale</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/lattices.jl#LL316-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.mulliken-Union{Tuple{PGIrrep{D}}, Tuple{D}} where D" href="#Crystalline.mulliken-Union{Tuple{PGIrrep{D}}, Tuple{D}} where D"><code>Crystalline.mulliken</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the Mulliken label of a point group irrep <code>pgir</code>.</p><p><strong>Notes</strong></p><p>This functionality is a simple mapping between the tabulated CDML point group irrep labels and associated Mulliken labels, using the listings at the Bilbao Crystallographic Database <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><p>Ignoring subscript, the rough rules associated with assignment of Mulliken labels are:</p><ol><li><strong>Irrep dimensionality</strong>: <ul><li><strong>1D irreps</strong>: if a real irrep, assign A or B (B if antisymmetric under a principal  rotation); if a complex irrep, assigned label ¹E or ²E.</li><li><strong>2D irreps</strong>: assign label E</li><li><strong>3D irreps</strong>: assign label T</li></ul></li><li><strong><em>u</em> and <em>g</em> subscripts</strong>: if the group contains inversion, indicate whether irrep is symmetric (g ~ gerade) or antisymmetric (ᵤ ~ ungerade) under inversion.</li><li><strong>Prime superscripts</strong>: if the group contains a mirror <em>m</em> aligned with a principal  rotation axis, but does <em>not</em> contain inversion, indicate whether irrep is symmetric (′)  or antisymmetric (′′) under this mirror.</li><li><strong>Numeral subscripts</strong>: the rules for assignment of numeral subscripts are too too complicated in general - and indeed, we are unaware of a general coherent rule – to describe here.</li></ol><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/notation.jl#LL474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.nontrivial_factors-Tuple{Smith}" href="#Crystalline.nontrivial_factors-Tuple{Smith}"><code>Crystalline.nontrivial_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nontrivial_factors(F::Smith) -&gt; Any
</code></pre><p>Return the nontrivial (i.e., ≠ {0,1}) elementary factors of an EBR basis, provided as a <code>BandRepSet</code> or <code>Smith</code> decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/bandrep.jl#LL123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.normscale!-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D" href="#Crystalline.normscale!-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>Crystalline.normscale!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normscale!(flat::ModulatedFourierLattice, expon::Real,
           Gs::Union{ReciprocalBasis, Nothing} = nothing) --&gt; ModulatedFourierLattice</code></pre><p>In-place equivalent of <a href="#Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>normscale</code></a>: mutates <code>flat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/lattices.jl#LL382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D" href="#Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>Crystalline.normscale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normscale(flat::ModulatedFourierLattice, expon::Real, 
          Gs::Union{ReciprocalBasis, Nothing} = nothing)  --&gt; ModulatedFourierLattice</code></pre><p>Applies inverse-orbit norm rescaling of expansion coefficients with a norm exponent <code>expon</code>. If <code>Gs</code> is nothing, the orbit norm is computed in the lattice basis (and, so, is not strictly a norm); by providing <code>Gs</code> as <a href="../bravais/#Bravais.ReciprocalBasis"><code>ReciprocalBasis</code></a>, the norm is evaluated correctly in cartesian setting. See further discussion in <a href="../lattices/#Crystalline.modulate"><code>modulate</code></a>.</p><p>An in-place equivalent is provided in <a href="#Crystalline.normscale!-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>normscale!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/lattices.jl#LL367-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.orbit-Tuple{SiteGroup}" href="#Crystalline.orbit-Tuple{SiteGroup}"><code>Crystalline.orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orbit(g::SiteGroup)  --&gt;  Vector{WyckoffPosition}</code></pre><p>Compute the orbit of the Wyckoff position associated with the site symmetry group <code>g</code>.</p><p><strong>Extended help</strong></p><p>The orbit of a Wyckoff position <span>$\mathbf{r}$</span> in a space group <span>$G$</span> is defined as the set of inequivalent points in the unit cell that can be obtained by applying the elements of <span>$G$</span> to <span>$\mathbf{r}$</span>. Equivalently, every element of the orbit of <span>$\mathbf{r}$</span> can be written as the composition of a coset representative of the Wyckoff position&#39;s site group in <span>$G$</span> with <span>$\mathbf{r}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/wyckoff.jl#LL186-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.orbit-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}, Union{Nothing, AbstractMatrix{&lt;:Real}}}} where D" href="#Crystalline.orbit-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}, Union{Nothing, AbstractMatrix{&lt;:Real}}}} where D"><code>Crystalline.orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orbit(g::AbstractVector{&lt;:SymOperation}, kv::KVec, cntr::Char)  --&gt;  Vector{KVec{D}}
orbit(lg::LittleGroup)
orbit(lgir::LGIrrep)</code></pre><p>Return the orbit of of the reciprocal-space vector <code>kv</code> under the action of the group <code>g</code>, also known as the star of <strong>k</strong>.</p><p>The orbit of <code>kv</code> in <code>g</code> is the set of inequivalent <strong>k</strong>-points obtained by composition of all the symmetry operations of <code>g</code> with <code>kv</code>. Two reciprocal vectors <span>$\mathbf{k}$</span> and <span>$\mathbf{k}&#39;$</span> are equivalent if they differ by a primitive reciprocal lattice vector.</p><p>If <code>kv</code> and <code>g</code> are specified in a conventional basis but refer to a non-primitive lattice, the centering type <code>cntr</code> must be provided to ensure that only equivalence by primitive (not conventional) reciprocal lattice vectors are considered. If the centering type of the group <code>g</code> can be inferred from <code>g</code> (e.g., if <code>g</code> is a <code>SpaceGroup</code>), <code>orbit</code> will assume a conventional setting and use the inferred centering type; otherwise, if <code>cntr</code> is neither explicitly set nor inferrable, a primitive setting is assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL617-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.pgirreps" href="#Crystalline.pgirreps"><code>Crystalline.pgirreps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pgirreps(iuclab::String, ::Val{D}=Val(3); mullikken::Bool=false) where D ∈ (1,2,3)
pgirreps(iuclab::String, D; mullikken::Bool=false)</code></pre><p>Return the (crystallographic) point group irreps of the IUC label <code>iuclab</code> of dimension <code>D</code> as a <code>Vector{PGIrrep{D}}</code>.</p><p><strong>Notation</strong></p><p>The irrep labelling follows the conventions of CDML <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> [which occasionally differ from those in e.g. Bradley and Cracknell, <em>The Mathematical Theory of Symmetry in Solids</em>  (1972)].</p><p>To use Mulliken (&quot;spectroscopist&quot;) irrep labels instead, set the keyword argument <code>mulliken = true</code> (default, <code>false). See also [</code>mulliken`](@ref).</p><p><strong>Data sources</strong></p><p>The data is sourced from the Bilbao Crystallographic Server <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. If you are using this  functionality in an explicit fashion, please cite the original reference <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</p><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/pointgroup.jl#LL168-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D" href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>Crystalline.pointgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointgroup(ops:AbstractVector{SymOperation{D}})
pointgroup(sg::AbstractGroup)</code></pre><p>Computes the point group associated with a space group <code>sg</code> (characterized by a set of operators <code>ops</code>, which, jointly with lattice translations generate  the space group), obtained by &quot;taking away&quot; any translational parts and  then reducing to the resulting unique rotational operations. (technically, in the language of Bradley &amp; Cracknell, this is the so-called isogonal point group of <code>sg</code>; see Sec. 1.5).</p><p>Returns a <code>Vector</code> of <code>SymOperation</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL344-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.pointgroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Integer}} where D" href="#Crystalline.pointgroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Integer}} where D"><code>Crystalline.pointgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointgroup(pgnum::Integer, ::Union{Val{D}, Integer}=Val(3), setting::Integer=1)
                                                                  --&gt;  PointGroup{D}</code></pre><p>Return the symmetry operations associated with the point group identfied with canonical number <code>pgnum</code> in dimension <code>D</code> as a <code>PointGroup{D}</code>. The connection between a point group&#39;s numbering and its IUC label is enumerated in <code>Crystalline.PG_NUM2IUC[D]</code> and <code>Crystalline.IUC2NUM[D]</code>.</p><p>Certain point groups feature in multiple setting variants: e.g., IUC labels 321 and 312 both correspond to <code>pgnum = 18</code> and correspond to the same group structure expressed in two different settings. The <code>setting</code> argument allows choosing between these setting variations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/pointgroup.jl#LL105-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.pointgroup-Union{Tuple{String}, Tuple{D}, Tuple{String, Val{D}}} where D" href="#Crystalline.pointgroup-Union{Tuple{String}, Tuple{D}, Tuple{String, Val{D}}} where D"><code>Crystalline.pointgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointgroup(iuclab::String, ::Union{Val{D}, Integer}=Val(3))  --&gt;  PointGroup{D}</code></pre><p>Return the symmetry operations associated with the point group identified with label <code>iuclab</code> in dimension <code>D</code> as a <code>PointGroup{D}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/pointgroup.jl#LL83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D}, 1}}, Tuple{D}} where D" href="#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D}, 1}}, Tuple{D}} where D"><code>Crystalline.realify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">realify(lgirs::AbstractVector{&lt;:LGIrrep}; verbose::Bool=false)
                                                    --&gt; AbstractVector{&lt;:LGIrrep}</code></pre><p>From <code>lgirs</code>, a vector of <code>LGIrrep</code>s, determine the associated (gray) co-representations, i.e. the &quot;real&quot;, or &quot;physical&quot; irreps that are relevant in scenarios with time-reversal symmetry.</p><p>For <code>LGIrrep</code> that are <code>REAL</code>, or that characterize a k-point 𝐤 which is not equivalent to -𝐤 (i.e. its star does not include both 𝐤 and -𝐤; equivalently, the little group includes time-reversal symmetry), the associated co-representations are just the  original irreps themselves.  For <code>PSEUDOREAL</code> and <code>COMPLEX</code> <code>LGIrrep</code>s where ±𝐤 are equivalent, the associated co-representations are built from pairs of irreps that &quot;stick&quot; together. This method computes this pairing and sets the <code>LGIrrep</code> field <code>iscorep</code> to true, to indicate that the resulting &quot;paired irrep&quot; (i.e. the co-representation) should be doubled with  itself (<code>PSEUDOREAL</code> reality) or its complex conjugate (<code>COMPLEX</code> reality).</p><p><strong>Background</strong></p><p>For background, see p. 650-652 (and p. 622-626 for point groups) in Bradley &amp; Cracknell&#39;s book. Their discussion is for magnetic groups (the &quot;realified&quot; irreps are, in fact, simply co-representations of the &quot;gray&quot; magnetic groups).  Cornwell&#39;s book also explicates this at some length as does Inui et al. (p. 296-299).</p><p><strong>Keyword arguments</strong></p><ul><li><code>verbose::Bool</code>: if set to <code>true</code>, prints details about mapping from small irrep to small</li></ul><p>corep for each <code>LGIrrep</code> (default: <code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/irreps_reality.jl#LL1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.realify-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Crystalline.AbstractIrrep" href="#Crystalline.realify-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Crystalline.AbstractIrrep"><code>Crystalline.realify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">realify(pgirs::AbstractVector{T}) where T&lt;:AbstractIrrep --&gt; Vector{T}</code></pre><p>Return physically real irreps (coreps) from a set of conventional irreps (as produced by e.g. <a href="#Crystalline.pgirreps"><code>pgirreps</code></a>). Fallback method for point-group-like <code>AbstractIrrep</code>s.</p><p><strong>Example</strong></p><pre><code class="language-jl-doctest hljs">julia&gt; pgirs = pgirreps(&quot;4&quot;, Val(3));
julia&gt; characters(pgirs)
CharacterTable{3}: ⋕9 (4)
───────┬────────────────────
       │ Γ₁  Γ₂    Γ₃    Γ₄ 
───────┼────────────────────
     1 │  1   1     1     1
  2₀₀₁ │  1   1    -1    -1
 4₀₀₁⁺ │  1  -1   1im  -1im
 4₀₀₁⁻ │  1  -1  -1im   1im
───────┴────────────────────

julia&gt; characters(realify(pgirs))
CharacterTable{3}: ⋕9 (4)
───────┬──────────────
       │ Γ₁  Γ₂  Γ₃Γ₄ 
───────┼──────────────
     1 │  1   1     2
  2₀₀₁ │  1   1    -2
 4₀₀₁⁺ │  1  -1     0
 4₀₀₁⁻ │  1  -1     0
───────┴──────────────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/irreps_reality.jl#LL215-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.schoenflies-Tuple{Integer}" href="#Crystalline.schoenflies-Tuple{Integer}"><code>Crystalline.schoenflies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">schoenflies(sgnum::Integer) --&gt; String</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Schoenflies_notation">Schoenflies notation</a> for space group number <code>sgnum</code> in dimension 3.</p><p>Note that Schoenflies notation is well-defined only for 3D point and space groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/notation.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D" href="#Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D"><code>Crystalline.seitz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seitz(op::SymOperation) --&gt; String</code></pre><p>Computes the correponding Seitz notation for a symmetry operation in triplet/xyzt form.</p><p>Implementation based on ITA5 Table 11.2.1.1, with 3D point group parts inferred from the trace and determinant of the matrix <span>$\mathb{W}$</span> in the triplet <span>$\{\mathbf{W}|\mathbf{w}\}$</span>.</p><table><tr><th style="text-align: left">detW/trW</th><th style="text-align: right">-3</th><th style="text-align: right">-2</th><th style="text-align: right">-1</th><th style="text-align: right">0</th><th style="text-align: right">1</th><th style="text-align: right">2</th><th style="text-align: right">3</th></tr><tr><td style="text-align: left"><strong>1</strong></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">2</td><td style="text-align: right">3</td><td style="text-align: right">4</td><td style="text-align: right">6</td><td style="text-align: right">1</td></tr><tr><td style="text-align: left"><strong>-1</strong></td><td style="text-align: right">-1</td><td style="text-align: right">-6</td><td style="text-align: right">-4</td><td style="text-align: right">-3</td><td style="text-align: right">m</td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>with the elements of the table giving the type of symmetry operation in in Hermann-Mauguin notation. The rotation axis and the rotation sense are computed following the rules in ITA6 Sec. 1.2.2.4(1)(b-c). See also .</p><p>Note that the orientation of the axis (i.e. its sign) does not necessarily match the orientation picked in Tables 1.4.2.1-5 of ITA6; it is a matter of (arbitrary) convention, and the conventions have not been explicated in ITA.</p><p>2D operations are treated by the same procedure, by elevation in a third dimension; 1D operations by a simple inspection of sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/notation.jl#LL180-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.sitegroup-Union{Tuple{D}, Tuple{SpaceGroup{D}, WyckoffPosition{D}}} where D" href="#Crystalline.sitegroup-Union{Tuple{D}, Tuple{SpaceGroup{D}, WyckoffPosition{D}}} where D"><code>Crystalline.sitegroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sitegroup(
    sg::SpaceGroup{D},
    wp::WyckoffPosition{D}
) -&gt; SiteGroup
</code></pre><p>Return the site symmetry group <code>g::SiteGroup</code> for a Wyckoff position <code>wp</code> in space group <code>sg</code> (or with space group number <code>sgnum</code>; in this case, the dimensionality is inferred from <code>wp</code>).</p><p><code>g</code> is a group of operations that are isomorphic to the those listed in <code>sg</code> (in the sense that they might differ by lattice vectors) and that leave the Wyckoff position <code>wp</code> invariant, such that <code>all(op -&gt; wp == op*wp, g) == true</code>.</p><p>The returned <code>SiteGroup</code> also contains the coset representatives of the Wyckoff position (that are again isomorphic to those featured in <code>sg</code>), accessible via <a href="#Crystalline.cosets-Tuple{SiteGroup}"><code>cosets</code></a>, which e.g. generate the orbit of the Wyckoff position (see <a href="#Crystalline.orbit-Tuple{SiteGroup}"><code>orbit(::SiteGroup)</code></a>) and define a left-coset decomposition of <code>sg</code> jointly with the elements in <code>g</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 16;

julia&gt; D = 2;

julia&gt; wp = wyckoffs(sgnum, D)[3] # pick a Wyckoff position
2b: [1/3, 2/3]

julia&gt; sg = spacegroup(sgnum, D);

julia&gt; g  = sitegroup(sg, wp)
SiteGroup{2} ⋕16 (p6) at 2b = [1/3, 2/3] with 3 operations:
 1
 {3⁺|1,1}
 {3⁻|0,1}</code></pre><p>The group structure of a <code>SiteGroup</code> can be inspected with <code>MultTable</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; MultTable(g)
3×3 MultTable{2}:
──────────┬──────────────────────────────
          │        1  {3⁺|1,1}  {3⁻|0,1} 
──────────┼──────────────────────────────
        1 │        1  {3⁺|1,1}  {3⁻|0,1} 
 {3⁺|1,1} │ {3⁺|1,1}  {3⁻|0,1}         1
 {3⁻|0,1} │ {3⁻|0,1}         1  {3⁺|1,1}
──────────┴──────────────────────────────</code></pre><p>The original space group can be reconstructed from a left-coset decomposition, using the operations and cosets contained in a <code>SiteGroup</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; ops = [opʰ*opᵍ for opʰ in cosets(g) for opᵍ in g];

julia&gt; Set(sg) == Set(ops)
true</code></pre><p><strong>Terminology</strong></p><p>Mathematically, the site symmetry group is a <em>stabilizer group</em> for a Wyckoff position, in the same sense that the little group of <strong>k</strong> is a stabilizer group for a <strong>k</strong>-point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/wyckoff.jl#LL48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D" href="#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D"><code>Crystalline.spacegroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spacegroup(sgnum::Integer, ::Val{D}=Val(3))
spacegroup(sgnum::Integer, D::Integer)          --&gt; SpaceGroup{D}</code></pre><p>Return the space group symmetry operations for a given space group number <code>sgnum</code> and  dimensionality <code>D</code> as a <code>SpaceGroup{D}</code>. The returned symmetry operations are specified relative to the conventional basis vectors, i.e. are not necessarily primitive (see <a href="../bravais/#Bravais.centering"><code>centering</code></a>). If desired, operations for the primitive unit cell can subsequently be generated using  <a href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>primitivize</code></a> or <a href="@ref"><code>Crystalline.reduce_ops</code></a>.</p><p>The default choices for the conventional basis vectors follow the conventions of the Bilbao Crystallographic Server (or, equivalently, the International Tables of Crystallography),  which are:</p><ul><li>Unique axis <em>b</em> (cell choice 1) for monoclinic space groups.</li><li>Obverse triple hexagonal unit cell for rhombohedral space groups.</li><li>Origin choice 2: inversion centers are placed at (0,0,0). (relevant for certain centrosymmetric space groups with two possible choices; e.g., in the orthorhombic, tetragonal or cubic crystal systems).</li></ul><p>See also <a href="../bravais/#Bravais.directbasis"><code>directbasis</code></a>.</p><p><strong>Data sources</strong></p><p>The symmetry operations returned by this function were originally retrieved from the <a href="https://www.cryst.ehu.es/cryst/get_gen.html">Bilbao Crystallographic Server, SPACEGROUP GENPOS</a>. The associated citation is: (<a href="https://doi.org/10.1524/zkri.2006.221.1.15">Aroyo et al., Z. Kristallogr. Cryst. Mater. <strong>221</strong>, 15 (2006).</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/symops.jl#LL56-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.subduction_count-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Union{Nothing, Vector{&lt;:Real}}}} where T&lt;:Crystalline.AbstractIrrep" href="#Crystalline.subduction_count-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Union{Nothing, Vector{&lt;:Real}}}} where T&lt;:Crystalline.AbstractIrrep"><code>Crystalline.subduction_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subduction_count(Dᴳᵢ, Dᴴⱼ[, αβγᴴⱼ]) --&gt; Int</code></pre><p>For two groups <span>$G$</span> and <span>$H$</span>, where <span>$H$</span> is a subgroup of <span>$G$</span>, i.e. <span>$H&lt;G$</span>, with associated irreducible representations <code>Dᴳᵢ</code> = <span>$D^G_i(g)$</span> and <code>Dᴴⱼ</code> = <span>$D^H_j(g)$</span> over operations <span>$g∈G$</span> and <span>$h∈H&lt;G$</span>, compute the compatibility relation between the two irreps from the subduction reduction formula (or &quot;magic&quot; formula/Schur orthogonality relation), returning how many times <span>$n^{GH}_{ij}$</span> the subduced representation <span>$D^G_i↓H$</span> contains  the irrep <span>$D^H_j$</span>; in other words, this gives the compatibility between the two irreps.</p><p>Optionally, a vector <code>αβγᴴⱼ</code> may be provided, to evaluate the characters/irreps  of <code>Dᴳᵢ</code> at a concrete value of <span>$(α,β,γ)$</span>. This is e.g. meaningful for <code>LGIrrep</code>s at non-special <strong>k</strong>-vectors. Defaults to <code>nothing</code>.</p><p>The result is computed using the reduction formula [see e.g. Eq. (15) of <a href="https://arxiv.org/abs/1706.09272">arXiv:1706.09272v2</a>]:</p><p><span>$n^{GH}_{ij} = |H|^{-1} \sum_h \chi^G_i(h)\chi^H_j(h)^*$</span></p><p><strong>Example</strong></p><p>Consider the two compatible <strong>k</strong>-vectors Γ (a point) and Σ (a line) in space group 207:</p><pre><code class="language-jl hljs">lgirsd  = lgirreps(207, Val(3));
Γ_lgirs = lgirsd[&quot;Γ&quot;]; # at Γ ≡ [0.0, 0.0, 0.0]
Σ_lgirs = lgirsd[&quot;Σ&quot;]; # at Σ ≡ [α, α, 0.0]</code></pre><p>We can test their compatibility via:</p><pre><code class="language-jl hljs">[[subduction_count(Γi, Σj) for Γi in Γ_lgirs] for Σj in Σ_lgirs]
&gt; # Γ₁ Γ₂ Γ₃ Γ₄ Γ₅
&gt;  [ 1, 0, 1, 1, 2] # Σ₁
&gt;  [ 0, 1, 1, 2, 1] # Σ₂</code></pre><p>With following enterpretatation for compatibility relations between irreps at Γ and Σ:</p><table><tr><th style="text-align: right">Compatibility relation</th><th style="text-align: right">Degeneracies</th></tr><tr><td style="text-align: right">Γ₁ → Σ₁</td><td style="text-align: right">1 → 1</td></tr><tr><td style="text-align: right">Γ₂ → Σ₂</td><td style="text-align: right">1 → 1</td></tr><tr><td style="text-align: right">Γ₃ → Σ₁ + Σ₂</td><td style="text-align: right">2 → 1 + 1</td></tr><tr><td style="text-align: right">Γ₄ → Σ₁ + 2Σ₂</td><td style="text-align: right">3 → 1 + 2</td></tr><tr><td style="text-align: right">Γ₅ → 2Σ₁ + Σ₂</td><td style="text-align: right">3 → 2 + 1</td></tr></table><p>where, in this case, all the small irreps are one-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/compatibility.jl#LL3-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}" href="#Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}"><code>Crystalline.subperiodicgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subperiodicgroup(num::Integer, ::Val{D}=Val(3), ::Val{P}=Val(2))
subperiodicgroup(num::Integer, D::Integer, P::Integer)
                                                        --&gt; ::SubperiodicGroup{D,P}</code></pre><p>Return the operations of the subperiodic group <code>num</code> of embedding dimension <code>D</code> and periodicity dimension <code>P</code> as a <code>SubperiodicGroup{D,P}</code>.</p><p>The setting choices are those of the International Tables for Crystallography, Volume E.</p><p>Allowed combinations of <code>D</code> and <code>P</code> and their associated group names are:</p><ul><li><code>D = 3</code>, <code>P = 2</code>: Layer groups (<code>num</code> = 1, …, 80).</li><li><code>D = 3</code>, <code>P = 1</code>: Rod groups (<code>num</code> = 1, …, 75).</li><li><code>D = 2</code>, <code>P = 1</code>: Frieze groups (<code>num</code> = 1, …, 7).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; subperiodicgroup(7, Val(2), Val(1))
SubperiodicGroup{2, 1} ⋕7 (𝓅2mg) with 4 operations:
 1
 2
 {m₁₀|½,0}
 {m₀₁|½,0}</code></pre><p><strong>Data sources</strong></p><p>The symmetry operations returned by this function were originally retrieved from the <a href="https://www.cryst.ehu.es/subperiodic/get_sub_gen.html">Bilbao Crystallographic Database, SUBPERIODIC GENPOS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/subperiodic.jl#LL232-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.wyckoffs-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D" href="#Crystalline.wyckoffs-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D"><code>Crystalline.wyckoffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wyckoffs(sgnum::Integer) -&gt; Vector{WyckoffPosition{3}}
wyckoffs(sgnum::Integer, ::Val{D}) -&gt; Any
</code></pre><p>Return the Wyckoff positions of space group <code>sgnum</code> in dimension <code>D</code> as a  <code>Vector{WyckoffPosition{D}</code>.</p><p>The positions are given in the conventional basis setting, following the conventions of the Bilbao Crystallographic Server (from which the underlying data is sourced <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wps = wyckoffs(16, 2)
4-element Vector{WyckoffPosition{2}}:
 6d: [α, β]
 3c: [1/2, 0]
 2b: [1/3, 2/3]
 1a: [0, 0]</code></pre><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/wyckoff.jl#LL4">source</a></section></article><h2 id="Exported-constants"><a class="docs-heading-anchor" href="#Exported-constants">Exported constants</a><a id="Exported-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-constants" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Crystalline.ENANTIOMORPHIC_PAIRS" href="#Crystalline.ENANTIOMORPHIC_PAIRS"><code>Crystalline.ENANTIOMORPHIC_PAIRS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ENANTIOMORPHIC_PAIRS :: NTuple{11, Pair{Int,Int}}</code></pre><p>Return the space group numbers of the 11 enantiomorphic space group pairs in 3D.</p><p>The space group types associated with each such pair <code>(sgnum, sgnum&#39;)</code> are related by a mirror transformation: i.e. there exists a transformation  <span>$\mathbb{P} = \{\mathbf{P}|\mathbf{p}\}$</span> between the two groups <span>$G = \{g\}$</span> and <span>$G&#39; = \{g&#39;\}$</span> such that <span>$G&#39; = \mathbb{P}^{-1}G\mathbb{P}$</span> where <span>$\mathbf{P}$</span> is improper (i.e. <span>$\mathrm{det}\mathbf{P} &lt; 0$</span>).</p><p>We define distinct space group <em>types</em> as those that cannot be related by a proper transformation (i.e. with <span>$\mathrm{det}\mathbf{P} &gt; 0$</span>). With that view, there are 230 space group types. If the condition is relaxed to allow improper rotations, there are  <span>$230-11 = 219$</span> distinct <em>affine</em> space group types. See e.g. ITA5 Section 8.2.2.</p><p>The enantiomorphic space group types are also chiral space group types in 3D. There are no enantiomorphic pairs in lower dimensions; in 3D all enantiomorphic pairs involve screw symmetries, whose direction is inverted between pairs (i.e. have opposite handedness).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/constants.jl#LL49-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.MAX_SGNUM" href="#Crystalline.MAX_SGNUM"><code>Crystalline.MAX_SGNUM</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">MAX_SGNUM :: Tuple{Int,Int,Int}</code></pre><p>Return the number of distinct space group types across dimensions 1, 2, and 3 (indexable by dimensionality).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/constants.jl#LL5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.MAX_SUBGNUM" href="#Crystalline.MAX_SUBGNUM"><code>Crystalline.MAX_SUBGNUM</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">MAX_SUBGNUM :: ImmutableDict</code></pre><p>An immutable dictionary with values <code>v::Int</code> and keys <code>k::Tuple{Int,Int}</code>, where <code>v</code> is the number of distinct subperiodic group types for a given key <code>k = (D,P)</code> describing a subperiodic group of dimensionality <code>D</code> and periodicity <code>P</code>:</p><ul><li>layer groups: <code>(D,P) = (3,2)</code></li><li>rod groups: <code>(D,P) = (3,1)</code></li><li>frieze groups: <code>(D,P) = (2,1)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/18a2d35f3a9519d3f1bcdf94e117b139b7181a6f/src/constants.jl#LL13-L23">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Bilbao Crystallographic Database&#39;s   <a href="https://www.cryst.ehu.es/cgi-bin/cryst/programs/representations_point.pl?tipogrupo=spg">Representations PG program</a>.</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Cracknell, Davies, Miller, &amp; Love, Kronecher Product Tables 1 (1979).</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Bilbao Crystallographic Database&#39;s   <a href="https://www.cryst.ehu.es/cgi-bin/cryst/programs/representations_point.pl?tipogrupo=spg">Representations PG program</a>.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Elcoro et al.,    <a href="https://doi.org/10.1107/S1600576717011712">J. of Appl. Cryst. <strong>50</strong>, 1457 (2017)</a></li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Aroyo, <em>et al.</em>,   <a href="https://doi.org/0.1524/zkri.2006.221.1.15">Z. Kristallogr. <strong>221</strong>, 15-27 (2006)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lattices/">« Lattices</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 12 September 2022 14:51">Monday 12 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
