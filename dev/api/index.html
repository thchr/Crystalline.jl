<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Â· Crystalline</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Crystalline</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Exported-types"><span>Exported types</span></a></li><li><a class="tocitem" href="#Exported-methods"><span>Exported methods</span></a></li><li><a class="tocitem" href="#Unexported-API"><span>Unexported API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/thchr/Crystalline.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><hr/><h2 id="Exported-types"><a class="docs-heading-anchor" href="#Exported-types">Exported types</a><a id="Exported-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-types" title="Permalink"></a></h2><h2 id="Exported-methods"><a class="docs-heading-anchor" href="#Exported-methods">Exported methods</a><a id="Exported-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Crystalline.bandreps" href="#Crystalline.bandreps"><code>Crystalline.bandreps</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bandreps(sgnum::Integer, D::Integer=3; 
         allpaths::Bool=false, spinful::Bool=false, timereversal::Bool=true)</code></pre><p>Returns the <code>BandRepSet</code> for space group <code>sgnum</code> (provided by the <a href="http://www.cryst.ehu.es/cgi-bin/cryst/programs/bandrep.pl">Bilbao Crystallographic Server</a>) and dimension <code>D</code>.</p><p>Keyword arguments:</p><ul><li><code>allpaths</code>: include a minimal sufficient set (<code>false</code>, default) or all (<code>true</code>) k-vectors. </li><li><code>spinful</code>: single- (<code>false</code>, default) or double-valued (<code>true</code>) irreps, as appropriate for            spinless and spinful particles, respectively.</li><li><code>timereversal</code>: assume presence (<code>true</code>, default) or absence (<code>false</code>) of time-reversal                 symmetry.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bandrep.jl#L89-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.basisdim-Tuple{BandRepSet}" href="#Crystalline.basisdim-Tuple{BandRepSet}"><code>Crystalline.basisdim</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">basisdim(BRS::BandRepSet) --&gt; Int64</code></pre><p>Computes the dimension of the (linearly independent parts) of a band representation set. This is <span>$d^{\text{bs}} = d^{\text{ai}}$</span> in the notation of Po, Watanabe, &amp; Vishwanath, Nature Commun. <strong>8</strong>, 50 (2017). In other words, this is the number of linearly independent basis vectors that span the expansions of a band structure or atomic insulator viewed as symmetry-data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bandrep.jl#L140-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.calcfourier-Tuple{Any,Crystalline.AbstractFourierLattice}" href="#Crystalline.calcfourier-Tuple{Any,Crystalline.AbstractFourierLattice}"><code>Crystalline.calcfourier</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calcfourier(xyz, flat::AbstractFourierLattice) --&gt; Float64</code></pre><p>Compute the real part of the function evaluation of <code>flat</code> at a point <code>xyz</code> (a tuple, SVector, or a vector), i.e. return     Re[âˆ‘áµ¢ cáµ¢exp(2Ï€iğ†áµ¢â‹…ğ«)] with ğ†áµ¢ denoting a ğ†-vector in an allowed orbit in <code>flat</code>, and  cáµ¢ an associated coefficient (and with ğ« â‰¡ <code>xyz</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L396-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D},DirectBasis{D}}} where D" href="#Crystalline.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D},DirectBasis{D}}} where D"><code>Crystalline.cartesianize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesianize(op::SymOperation{D}, Rs::DirectBasis{D}) --&gt; SymOperation{D}</code></pre><p>Converts <code>opË¡</code> from a lattice basis to a Cartesian basis, by computing the transformed operators <code>opá¶œ = ğ‘*opË¡*ğ‘â»Â¹</code> via the Cartesian basis matrix ğ‘ (whose columns are the <code>DirectBasis</code> vectors <code>Rs[i]</code>). </p><p><strong>Note 1</strong></p><p>The matrix ğ‘ maps vectors coefficients in a lattice basis ğ¯Ë¡ to coefficients in a Cartesian basis ğ¯á¶œ as ğ¯Ë¡ = ğ‘â»Â¹ğ¯á¶œ and vice versa as ğ¯á¶œ = ğ‘ğ¯Ë¡. Since a general transformation P  transforms an &quot;original&quot; vectors with coefficients ğ¯ to new coefficients ğ¯â€² via ğ¯â€² = Pâ»Â¹ğ¯ and since we here here consider the lattice basis as the &quot;original&quot; basis we have P = ğ‘â»Â¹.  As such, the transformation of the operator <code>op</code> transforms as <code>opá¶œ = Pâ»Â¹*opË¡*P</code>, i.e. <code>opá¶œ = transform(opË¡,P) = transform(opË¡,ğ‘â»Â¹)</code>.</p><p><strong>Note 2</strong></p><p>The display (e.g. Seitz and xyzt notation) of <code>SymOperation</code>s e.g. in the REPL implicitly assumes integer coefficients for its point-group matrix: as a consequence, displaying  <code>SymOperation</code>s in a Cartesian basis may produce undefined behavior. The matrix representation remains valid, however.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L634-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.centering" href="#Crystalline.centering"><code>Crystalline.centering</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">centering(sg::SpaceGroup) --&gt; Char
centering(sgnum::Integer, D::Integer=3) --&gt; Char</code></pre><p>Determines the conventional centering type of a given space/plane group <code>sg</code> (alternatively specified by its conventional number <code>sgnum</code> and dimensionality <code>D</code> by comparison with the Hermann-Mauguin notation&#39;s first letter. </p><p>Possible output values, depending on dimensionality <code>D</code>, are (see ITA Sec. 9.1.4):</p><pre><code class="language-none">D=2 â”Œ &#39;p&#39;: no centring (primitive)
    â”” &#39;c&#39;: face centered

D=3 â”Œ &#39;P&#39;: no centring (primitive)
    â”œ &#39;I&#39;: body centred (innenzentriert)
    â”œ &#39;F&#39;: all-face centred
    â”œ &#39;A&#39;, &#39;B&#39;, &#39;C&#39;: one-face centred, (b,c) or (c,a) or (a,b)
    â”” &#39;R&#39;: hexagonal cell rhombohedrally centred</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/notation.jl#L27-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.classification-Tuple{BandRepSet}" href="#Crystalline.classification-Tuple{BandRepSet}"><code>Crystalline.classification</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">classification(BRS::BandRepSet) --&gt; String</code></pre><p>Calculate the symmetry indicator classification of a band representation set, meaning the  index-classification inferrable on the basis of symmetry alone.</p><p>Technically, the calculation answers a question like &quot;what direct product of  <span>$\mathbb{Z}_n$</span> groups is the the quotient group <span>$X^{\text{bs}} = \{\text{BS}\}/\{\text{AI}\}$</span> isomorphic to?&quot;.</p><p>See e.g. Po, Watanabe, &amp; Vishwanath, Nature Commun. <strong>8</strong>, 50 (2017) for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bandrep.jl#L116-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D" href="#Crystalline.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D"><code>Crystalline.conventionalize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conventionalize(flatâ€²::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flatâ€²)</code></pre><p>Given <code>flatâ€²</code> referred to a primitive basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flat</code> referred to the associated conventional basis. </p><p>See also the complementary methods <a href="@ref"><code>transform(::AbstractFourierLattice, ::AbstractMatrix{&lt;:Real}</code></a> and <a href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>primitivize(::AbstractFourierLattice, ::Char)</code></a> for additional details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L296-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.conventionalize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D" href="#Crystalline.conventionalize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D"><code>Crystalline.conventionalize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conventionalize(Rsâ€²::DirectBasis, cntr::Char) --&gt; Rs::DirectBasis</code></pre><p>Transforms a primitive DirectBasis <code>Rsâ€²</code> into its conventional equivalent <code>Rs</code>, with the  transformation dependent on the centering type <code>cntr</code> (P, I, F, R, A, C, and p, c); for centering P and p, the conventional and primive bases coincide.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L464-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.crystal-NTuple{6,Real}" href="#Crystalline.crystal-NTuple{6,Real}"><code>Crystalline.crystal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crystal(a,b,c,Î±,Î²,Î³) --&gt; Rs::DirectBasis{3}</code></pre><p>Calculate basis vectors <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span>, <span>$\mathbf{R}_3$</span> in a 3D Cartesian basis for a right-handed coordinate system with specified basis vector lengths <code>a</code>, <code>b</code>, <code>c</code> (associated with <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span>, &amp; <span>$\mathbf{R}_3$</span>, respectively) and specified interaxial angles  <code>Î±</code> <span>$= âˆ (\mathbf{R}_2,\mathbf{R}_3)$</span>, <code>Î²</code> <span>$= âˆ (\mathbf{R}_3,\mathbf{R}_1)$</span>,  <code>Î³</code> <span>$= âˆ (\mathbf{R}_1,\mathbf{R}_2)$</span>, with <span>$âˆ $</span> denoting the angle between two vectors.</p><p>For definiteness, the <span>$\mathbf{R}_1$</span> basis vector is oriented along the <span>$x$</span>-axis of the Cartesian coordinate system, and the <span>$\mathbf{R}_2$</span> axis is placed in the <span>$xy$</span>-plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.crystal-Tuple{Real,Real,Real}" href="#Crystalline.crystal-Tuple{Real,Real,Real}"><code>Crystalline.crystal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crystal(a,b,Î³) --&gt; DirectBasis{2}</code></pre><p>Calculate basis vectors <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span> in a 2D Cartesian basis for a  right-handed coordinate system with specified basis vector lengths <code>a</code>, <code>b</code> (associated with <span>$\mathbf{R}_1$</span> &amp; <span>$\mathbf{R}_2$</span>, respectively) and specified interaxial angle <code>Î³</code> <span>$= âˆ (\mathbf{R}_1,\mathbf{R}_2)$</span>.</p><p>For definiteness, the <span>$\mathbf{R}_1$</span> basis vector is oriented along the <span>$x$</span>-axis of the Cartesian coordinate system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L36-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.crystal-Tuple{Real}" href="#Crystalline.crystal-Tuple{Real}"><code>Crystalline.crystal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crystal(a)  --&gt; DirectBasis{1}</code></pre><p>Return a one-dimensional crystal with lattice period <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.crystalsystem-Union{Tuple{DirectBasis{D}}, Tuple{D}} where D" href="#Crystalline.crystalsystem-Union{Tuple{DirectBasis{D}}, Tuple{D}} where D"><code>Crystalline.crystalsystem</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crystalsystem(R::DirectBasis{D})</code></pre><p>Determine the crystal system of a point lattice specified in a  <em>conventional</em> <code>DirectBasis{D}</code> of dimension <code>D</code> using Tables 2.1.2.1, 9.1.7.1, &amp; 9.1.7.2 of the International Tables of  Crystallography, Volume 1 (ITA).  There are 4 crystal systems in 2D and 7 in 3D (see ITA 2.1.2(iii)):</p><table><tr><th style="text-align: right"><code>D</code></th><th style="text-align: right">System</th><th style="text-align: right">Conditions</th><th style="text-align: right">Free parameters</th></tr><tr><td style="text-align: right"><em>1D</em></td><td style="text-align: right">linear</td><td style="text-align: right">none</td><td style="text-align: right">a</td></tr><tr><td style="text-align: right"><em>2D</em></td><td style="text-align: right">square</td><td style="text-align: right">a=b &amp; Î³=90Â°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">rectangular</td><td style="text-align: right">Î³=90Â°</td><td style="text-align: right">a,b</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">hexagonal</td><td style="text-align: right">a=b &amp; Î³=120Â°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">oblique</td><td style="text-align: right">none</td><td style="text-align: right">a,b,Î³</td></tr><tr><td style="text-align: right"><em>3D</em></td><td style="text-align: right">cubic</td><td style="text-align: right">a=b=c &amp; Î±=Î²=Î³=90Â°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">hexagonal</td><td style="text-align: right">a=b &amp; Î±=Î²=90Â° &amp; Î³=120Â°</td><td style="text-align: right">a,c</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">trigonal</td><td style="text-align: right">a=b &amp; Î±=Î²=90Â° &amp; Î³=120Â°</td><td style="text-align: right">a,c (a,Î± for hR)</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">tetragonal</td><td style="text-align: right">a=b &amp; Î±=Î²=Î³=90Â°</td><td style="text-align: right">a,c</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">orthorhombic</td><td style="text-align: right">Î±=Î²=Î³=90Â°</td><td style="text-align: right">a,b,c</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">monoclinic</td><td style="text-align: right">Î±=Î³=90Â°</td><td style="text-align: right">a,b,c,Î²â‰¥90Â°</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">triclinic</td><td style="text-align: right">none</td><td style="text-align: right">a,b,c,Î±,Î²,Î³</td></tr></table><p>The DirectBasis input is assumed to use <em>conventional</em> basis vectors;  i.e. not necessarily primitive. For primitive basis vectors, the  crystal system can be further reduced into 5 Bravais types in 2D and 14 in 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L79-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.dim-Tuple{BandRep}" href="#Crystalline.dim-Tuple{BandRep}"><code>Crystalline.dim</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(BR::BandRep) --&gt; Int64</code></pre><p>Get the number of bands included in a single BandRep <code>BR</code>; i.e. the &quot;band filling&quot; Î½ discussed in Po&#39;s papers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L589-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.directbasis-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D" href="#Crystalline.directbasis-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>Crystalline.directbasis</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">directbasis(sgnum, D=3;    abclims, Î±Î²Î³lims)
directbasis(sgnum, Val(D); abclims, Î±Î²Î³lims) --&gt; DirectBasis{D}</code></pre><p>Generates a (conventional) DirectBasis for a crystal compatible with  the space group number <code>sgnum</code> and dimensionality <code>D</code>. Free parameters in the lattice vectors are chosen randomly, with limits optionally supplied in <code>abclims</code> (lengths) and <code>Î±Î²Î³lims</code> (angles). By convention, the length of the first lattice vector (= <code>a</code>) is set to unity, such that the second and third (= <code>b</code> and <code>c</code>) lattice  vectors&#39; lengths are relative to the first.</p><p>Limits on the relative uniform distribution of lengths <code>b</code> and <code>c</code> can be specified as 2-tuple kwarg <code>abclims</code>; similarly, limits on  the angles <code>Î±</code>, <code>Î²</code>, <code>Î³</code> can be set via Î±Î²Î³lims (only affects  oblique, monoclinic, &amp; triclinic lattices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L209-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.find_representation" href="#Crystalline.find_representation"><code>Crystalline.find_representation</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_representation(symvals::AbstractVector{Number}, 
                    lgirs::AbstractVector{&lt;:AbstractIrrep},
                    Î±Î²Î³::Union{AbstractVector{&lt;:Real},Nothing}=nothing,
                    assert_return_T::Type{&lt;:Union{Integer, AbstractFloat}}=Int))

                    --&gt; Vector{assert_return_T}</code></pre><p>From a vector (or vector of vectors) of symmetry eigenvalues <code>symvals</code> sampled along all the operations of a group gáµ¢, whose irreps are contained in <code>irs</code> (evaluated with optional free  parameters <code>Î±Î²Î³</code>), return the multiplicities of each irrep.</p><p>Optionally, the multiciplities&#39; element type can be specified via the <code>assert_return_T</code> argument (performing checked conversion; returns <code>nothing</code> if representation in  <code>assert_return_T</code> is impossible). This can be useful if one suspects a particular band to  transform like a fraction of an irrep (i.e., the specified symmetry data is incomplete).</p><p><strong>Extended help</strong></p><p>Effectively, this applies the projection operator Pâ½Ê²â¾ of each irrep&#39;s character set Ï‡â½Ê²â¾(gáµ¢) (j = 1, ... , Nâ±Ê³Ê³) to the symmetry data sáµ¢ â‰¡ <code>symvals</code>:</p><pre><code class="language-none">Pâ½Ê²â¾  â‰¡ (dâ±¼/|g|) âˆ‘áµ¢ Ï‡â½Ê²â¾(gáµ¢)*gáµ¢         [characters Ï‡â½Ê²â¾(gáµ¢), irrep dimension dâ±¼]
Pâ½Ê²â¾s = (dâ±¼/|g|) âˆ‘áµ¢ Ï‡â½Ê²â¾(gáµ¢)*sáµ¢ = nâ±¼,   [number of bands that transform like jth irrep]</code></pre><p>returning the irrep multiplicities mâ±¼ â‰¡ nâ±¼/dâ±¼.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symeigs2irrep.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D" href="#Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D"><code>Crystalline.generate</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Generate a group from a finite set of generators <code>gens</code>. Returns a <code>GenericGroup</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>modÏ„</code> (default, <code>true</code>): the group composition operation can either be taken modulo lattice vectors (<code>true</code>) or not (<code>false</code>, useful e.g. for site symmetry groups). In this case, the provided generators will also be taken modulo integer lattice translations.</li><li><code>Nmax</code> (default, <code>256</code>): the maximum size of the generated group. This is essentially a cutoff set to ensure halting of execution in case the provided set of generators do not define a <em>finite</em> group (especially relevant if <code>modÏ„=false</code>). If more operations than <code>Nmax</code> are generated, the method throws an overflow error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L807-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile},Union{Nothing, JLD2.JLDFile}}} where D" href="#Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile},Union{Nothing, JLD2.JLDFile}}} where D"><code>Crystalline.get_lgirreps</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_lgirreps(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3))
                                                -&gt; Dict{String, Vector{LGIrrep{D}}}</code></pre><p>For given space group number <code>sgnum</code> and dimension <code>D</code>, return the associated little group (or &quot;small&quot;) irreps (<code>LGIrrep{D}</code>s) at high-symmetry k-points, lines, and planes. </p><p>Returns a <code>Dict</code> with little group <strong>k</strong>-point labels as keys and vectors of <code>LGIrrep{D}</code>s as values.</p><p><strong>Notes</strong></p><ul><li>Currently, only <code>D = 3</code> is supported.</li><li>The returned irreps are complex in general. Real irreps (as needed in time-reversal invariant settings) can subsequently be obtained with the <a href="#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D},1}}, Tuple{D}, Tuple{AbstractArray{LGIrrep{D},1},Bool}} where D"><code>realify</code></a> method.</li><li>Returned irreps are spinless.</li></ul><p><strong>References</strong></p><p>The underlying data is sourced from the ISOTROPY ISO-IR dataset. If used in research, please cite the original reference material associated with ISO-IR:</p><ul><li>Stokes, Hatch, &amp; Campbell, <a href="https://stokes.byu.edu/iso/irtables.php">ISO-IR, ISOTROPY Software Suite</a></li><li>Stokes, Campbell, &amp; Cordes, <a href="https://doi.org/10.1107/S0108767313007538">Acta Cryst. A. <strong>69</strong>, 388-395 (2013)</a>.</li></ul><p>The ISO-IR dataset is occasionally missing some <strong>k</strong>-points that lie outside the basic domain but still resides in the representation domain (i.e. <strong>k</strong>-points with postscripted &#39;A&#39;, &#39;B&#39;, etc. labels, such as &#39;ZA&#39;). In such cases, the missing irreps may instead have been manually sourced from the Bilbao Crystallographic Database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/littlegroup_irreps.jl#L62-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.get_littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}} where D" href="#Crystalline.get_littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}} where D"><code>Crystalline.get_littlegroups</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_littegroups(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3)) 
                                                    -&gt; Dict{String, LittleGroup{D}}</code></pre><p>For given space group number <code>sgnum</code> and dimension <code>D</code>, return the associated little groups (<code>LittleGroups{D}</code>s) at high-symmetry k-points, lines, and planes (see also <a href="#Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile},Union{Nothing, JLD2.JLDFile}}} where D"><code>get_lgirreps</code></a>).</p><p>Returns a <code>Dict</code> with little group <strong>k</strong>-point labels as keys and vectors of <code>LittleGroup{D}</code>s as values.</p><p><strong>Notes</strong></p><p>A conventional crystallographic setting is assumed (as in <a href="#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>spacegroup</code></a>).</p><p>Unlike <code>spacegroup</code>, &quot;centering&quot;-copies of symmetry operations are not included in the returned <code>LittleGroup</code>s; as an example, space group 110 (body-centered, with centering symbol &#39;I&#39;) has a centering translation <code>[1/2,1/2,1/2]</code> in the conventional setting: the symmetry operations returned by <code>spacegroup</code> thus includes e.g. both <code>{1|0}</code> and  <code>{1|Â½,Â½,Â½}</code> while the symmetry operations returned by <code>get_littlegroups</code> only include <code>{1|0}</code> (and so on).</p><p>Currently, only <code>D = 3</code> is supported.</p><p><strong>References</strong></p><p>The underlying data is sourced from the ISOTROPY dataset: see also <a href="#Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile},Union{Nothing, JLD2.JLDFile}}} where D"><code>get_lgirreps</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/littlegroup_irreps.jl#L4-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.get_pgirreps-Tuple{String,Val{3}}" href="#Crystalline.get_pgirreps-Tuple{String,Val{3}}"><code>Crystalline.get_pgirreps</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_pgirreps(iuclab::String, Val{D}) where D âˆˆ (1,2,3)
get_pgirreps(iuclab::String, D)</code></pre><p>Return the (crystallographic) point group irreps of the IUC label <code>iuclab</code> of dimension <code>D</code> as a vector of <code>PGIrrep{D}</code>s.</p><p><strong>Notes</strong></p><p>The irrep labelling follows the conventions of CDML [1] [which occasionally differ from those in e.g. Bradley and Cracknell, <em>The Mathematical Theory of Symmetry in Solids</em> (1972)].</p><p>The data is sourced from the Bilbao Crystallographic Server [2]. If you are using this  functionality in an explicit fashion, please cite the original reference [3].</p><p><strong>References</strong></p><p>[1] Cracknell, Davies, Miller, &amp; Love, Kronecher Product Tables 1 (1979).</p><p>[2] Bilbao Crystallographic Server:      https://www.cryst.ehu.es/cgi-bin/cryst/programs/representations_point.pl</p><p>[3] Elcoro et al.,      <a href="https://doi.org/10.1107/S1600576717011712">J. of Appl. Cryst. <strong>50</strong>, 1457 (2017)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/pointgroup.jl#L129-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.herring-Union{Tuple{D}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1}}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1},Union{Nothing, Array{var&quot;#s128&quot;,1} where var&quot;#s128&quot;&lt;:Real}}} where D" href="#Crystalline.herring-Union{Tuple{D}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1}}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1},Union{Nothing, Array{var&quot;#s128&quot;,1} where var&quot;#s128&quot;&lt;:Real}}} where D"><code>Crystalline.herring</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">herring(lgir::LGIrrep, sgops::AbstractVector{SymOperation{D}},
        Î±Î²Î³::Union{Vector{&lt;:Real},Nothing}=nothing)        --&gt; Tuple{Int, Int}</code></pre><p>Computes the Herring criterion for a small irrep <code>lgir::LGIrrep</code>, from </p><p><span>$[âˆ‘ Ï‡(\{Î²|b\}Â²)]/[g_0/M(k)]$</span></p><p>over symmetry operations <span>$\{Î²|b\}$</span> that take <span>$k â†’ -k$</span>.  Here <span>$g_0$</span> is the order of the point group of the space group and <span>$M(k)$</span> is the order of the star(<span>$k$</span>) [both in a primitive basis].</p><p>The returned value, <span>$[âˆ‘ Ï‡(\{Î²|b\}Â²)]/[g_0/M(k)]$</span>, is one of three integers in  <span>$\{1,-1,0\}$</span> corresponding to {real, pseudoreal, complex} reality.  We remind that ISOTROPY&#39;s convention (and hence, the <code>type</code> field of <code>LGIrrep</code>s and  <code>PGIrrep</code>s) of the same reality types is <span>$\{1,2,3\}$</span>.</p><p>The provided space group operations <code>sgops</code> <strong>must</strong> be the set reduced by primitive translation vectors; i.e. using <code>spacegroup(...)</code> directly is <strong>not</strong> allowable in general (since the irreps we reference only include these &quot;reduced&quot; operations). This reduced set of operations can be obtained e.g. from the Î“ point irreps of ISOTROPY&#39;s dataset, or alternatively, from <code>reduce_ops(spacegroup(...), true)</code>.</p><p>As a sanity check, a value of <code>Î±Î²Î³</code> can be provided to check for invariance along a symmetry line/plane/general point in k-space. Obviously, the reality  type should invariant to this choice.</p><p><strong>Implementation:</strong>  See e.g. Inui&#39;s Eq. (13.48), Dresselhaus, p. 618, and  and Herring&#39;s original paper at https://doi.org/10.1103/PhysRev.52.361. We mainly followed Cornwell, p. 150-152 &amp; 187-188.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/irreps_reality.jl#L247-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.interpolate_kvpath-Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:(AbstractArray{var&quot;#s25&quot;,1} where var&quot;#s25&quot;&lt;:Real),Integer}" href="#Crystalline.interpolate_kvpath-Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:(AbstractArray{var&quot;#s25&quot;,1} where var&quot;#s25&quot;&lt;:Real),Integer}"><code>Crystalline.interpolate_kvpath</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolate_kvpath(kvs::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, Ninterp::Integer) 
    --&gt; Vector{Vector{Float64}}, Int64</code></pre><p>Computes an interpolated <span>$k$</span>-path between the discrete <span>$k$</span>-points in <code>kvs</code>, so that the interpolated path has <em>approximately</em> <code>Ninterp</code> points in total (typically fewer).</p><p>Since the actual number of points in the path may deviate from the requested <code>Ninterp</code>, the actual number of points in the path is returned along with the interpolated itself.</p><p>Note that, in general, it is not possible to do this so that all interpolated <span>$k$</span>-points are equidistant; but points are equidistant in-between the initial discrete points provided in <code>kvs</code>.</p><p>See also <a href="#Crystalline.splice_kvpath-Tuple{AbstractArray{var&quot;#s21&quot;,1} where var&quot;#s21&quot;&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real),Integer}"><code>splice_kvpath</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/utils.jl#L254-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.isnormal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:(SymOperation{var&quot;#s15&quot;} where var&quot;#s15&quot;))" href="#Crystalline.isnormal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:(SymOperation{var&quot;#s15&quot;} where var&quot;#s15&quot;))"><code>Crystalline.isnormal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isnormal(opsá´³::T, opsá´´::T; verbose::Bool=false) where T&lt;:AbstractVector{SymOperation{D}}
                                                --&gt; Bool</code></pre><p>Determine whether the operations in group <span>$H$</span> are normal in the group <span>$G$</span> (each with  operations <code>opsá´³</code> and <code>opsá´´</code>), in the sense that </p><p><span>$ghgâ»Â¹ âˆˆ H, âˆ€ gâˆˆG, âˆ€ hâˆˆH$</span></p><p>Returns a Boolean answer (<code>true</code> if normal, <code>false</code> if not).</p><p><strong>Note</strong></p><p>This compares space groups rather than space group types, i.e. the  comparison assumes a matching setting choice between <span>$H$</span> and <span>$G$</span>. To compare space  group types with different conventional settings, they must first be transformed to a shared setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L768-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.israyrep" href="#Crystalline.israyrep"><code>Crystalline.israyrep</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">israyrep(lgir::LGIrrep, Î±Î²Î³=nothing) -&gt; (::Bool, ::Matrix)</code></pre><p>Computes whether a given little group irrep <code>ir</code> is a ray representation  by computing the coefficients Î±áµ¢â±¼ in Dáµ¢Dâ±¼=Î±áµ¢â±¼Dâ‚–; if any Î±áµ¢â±¼ differ  from unity, we consider the little group irrep a ray representation (as opposed to the simpler &quot;vector&quot; representations where Dáµ¢Dâ±¼=Dâ‚–). The function returns a boolean (true =&gt; ray representation) and the coefficient matrix Î±áµ¢â±¼.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L497-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issubgroup-Union{Tuple{T}, Tuple{D}, Tuple{T,T}} where T&lt;:AbstractArray{SymOperation{D},1} where D" href="#Crystalline.issubgroup-Union{Tuple{T}, Tuple{D}, Tuple{T,T}} where T&lt;:AbstractArray{SymOperation{D},1} where D"><code>Crystalline.issubgroup</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issubgroup(opsá´³::T, opsá´´::T) where T&lt;:AbstractVector{SymOperation{D}} --&gt; Bool</code></pre><p>Determine whether the operations in group <span>$H$</span> are a subgroup of the group <span>$G$</span> (each with  operations <code>opsá´³</code> and <code>opsá´´</code>, respectively), i.e. whether <span>$H&lt;G$</span>. Specifically, this requires that <span>$G$</span> and <span>$H$</span> are both groups and that for every <span>$hâˆˆH$</span> there exists an element <span>$gâˆˆG$</span> such that <span>$h=g$</span>.</p><p>Returns a Boolean answer (<code>true</code> if normal, <code>false</code> if not).</p><p><strong>Note</strong></p><p>This compares space groups rather than space group types, i.e. the  comparison assumes a matching setting choice between <span>$H$</span> and <span>$G$</span>. To compare space  group types with different conventional settings, they must first be transformed to a shared setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L722-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph" href="#Crystalline.issymmorph"><code>Crystalline.issymmorph</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issymmorph(sgnum::Integer, D::Integer=3) --&gt; Bool</code></pre><p>Checks whether a given space group <code>sgnum</code> (of dimensionality <code>D</code>) is symmorphic (true) or nonsymmorphic (false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph-Tuple{SymOperation,Char}" href="#Crystalline.issymmorph-Tuple{SymOperation,Char}"><code>Crystalline.issymmorph</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issymmorph(op::SymOperation, cntr::Char) --&gt; Bool</code></pre><p>Checks whether a given symmetry operation <code>op</code> is symmorphic (true) or nonsymmorphic (false). The operation is assumed to be given in a  conventional basis; but the check requires that the translation is zero  in a primitive basis. Accordingly, the centering <code>cntr</code> must provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph-Tuple{Union{LittleGroup, SpaceGroup}}" href="#Crystalline.issymmorph-Tuple{Union{LittleGroup, SpaceGroup}}"><code>Crystalline.issymmorph</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issymmorph(sg::AbstractGroup) --&gt; Bool</code></pre><p>Checks whether a given space group <code>sg</code> is symmorphic (true) or nonsymmorphic (false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.iuc" href="#Crystalline.iuc"><code>Crystalline.iuc</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iuc(sgnum::Integer, D::Integer=3) --&gt; String</code></pre><p>Returns the IUC (International Union of Crystallography) notation for space group number <code>sgnum</code> and dimensionality <code>D</code>, as used in the International Tables of Crystallography.  The notation is sometimes also known as the Hermann-Mauguin notation; the functionality is consequently aliased by <code>hermannmauguin(sgnum, D)</code>.  IUC/Hermann-Mauguin notation applies in one, two, and three-dimensions.</p><p>For more information, see https://en.wikipedia.org/wiki/Hermann%E2%80%93Mauguin_notation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/notation.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.levelsetlattice" href="#Crystalline.levelsetlattice"><code>Crystalline.levelsetlattice</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">levelsetlattice(sgnum::Integer, D::Integer=2, idxmax::NTuple=ntuple(i-&gt;2,D))
    --&gt; UnityFourierLattice{D}</code></pre><p>Compute a &quot;neutral&quot;/uninitialized Fourier lattice basis, a UnityFourierLattice, consistent with the symmetries of the space group <code>sgnum</code> in dimension <code>D</code>. The resulting lattice <code>flat</code> is expanded in a Fourier basis split into symmetry-derived orbits, with intra-orbit  coefficients constrained by the symmetries of the space-group. The inter-orbit coefficients are, however, free and unconstrained.</p><p>The Fourier resolution along each reciprocal lattice vector is controlled by <code>idxmax</code>: e.g., if <code>D = 2</code> and <code>idxmax = (2, 3)</code>, the resulting Fourier lattice may contain  reciprocal lattice vectors (kâ‚, kâ‚‚) with kâ‚âˆˆ[0,Â±1,Â±2] and kâ‚‚âˆˆ[0,Â±1,Â±2,Â±3], referred  to a ğ†-basis.</p><p>This &quot;neutral&quot; lattice can, and usually should, be subsequently modulated by <code>modulate</code> (modulates the inter-orbit coefficients, which will often eliminate symmetries that may remain in the &quot;neutral&quot; configuration, where all inter-orbit coefficients are unity).</p><p><strong>Examples</strong></p><p>Compute a UnityFourierLattice, modulate it with random inter-orbit coefficients via <code>modulate</code>, and finally plot it (requires <code>using PyPlot</code>):</p><pre><code class="language-julia-repl">julia&gt; uflat = levelsetlattice(16, 2)
julia&gt; flat  = modulate(uflat)
julia&gt; Rs    = directbasis(16, 2) 
julia&gt; plot(flat, Rs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L53-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.matrix" href="#Crystalline.matrix"><code>Crystalline.matrix</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">matrix(BRS::BandRepSet[, includedim::Bool=false])</code></pre><p>Return a matrix representation of <code>BRS::BandRepSet</code>, with band representations as columns  and irreps over rows.</p><p>For <code>includedim=true</code> the band filling (i.e. <code>dim.(BRS)</code>) is included as the last row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L635-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}}}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}},Union{Nothing, Real}}} where D" href="#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}}}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}},Union{Nothing, Real}}} where D"><code>Crystalline.modulate</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">modulate(flat::UnityFourierLattice{D},
modulation::AbstractVector{ComplexF64}=rand(ComplexF64, length(getcoefs(flat))),
expon::Union{Nothing, Real}=nothing)
                        --&gt; ModulatedFourierLattice{D}</code></pre><p>Derive a concrete, modulated Fourier lattice from <code>flat</code>, a UnityFourierLattice  struct (that contains the <em>interrelations</em> between orbit coefficients), by  multiplying the &quot;normalized&quot; orbit coefficients by a <code>modulation</code>, a <em>complex</em> modulating vector (in general, should be complex; otherwise restores unintended symmetry to the lattice). Distinct <code>modulation</code> vectors produce distinct  realizations of the same lattice described by the original <code>flat</code>. By default, a random complex vector is used.</p><p>An exponent <code>expon</code> can be provided, which introduces a penalty term to short- wavelength features (i.e. high-|G| orbits) by dividing the orbit coefficients by |G|^<code>expon</code>; producing a more &quot;localized&quot; and &quot;smooth&quot; lattice boundary when <code>expon &gt; 0</code> (reverse for <code>expon &lt; 0</code>). This basically amounts to a  continuous &quot;simplifying&quot; operation on the lattice (it is not necessarily a  smoothing operation; it simply suppresses &quot;high-frequency&quot; components). If <code>expon = nothing</code>, no rescaling is performed. </p><p>The <code>normscale(!)</code> methods exists to perform subsequent <code>expon</code> norm-rescaling  of a <code>ModulatedFourierLattice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L316-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.normscale!-Tuple{ModulatedFourierLattice,Real}" href="#Crystalline.normscale!-Tuple{ModulatedFourierLattice,Real}"><code>Crystalline.normscale!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normscale!(flat::ModulatedFourierLattice, expon::Real) --&gt; ModulatedFourierLattice</code></pre><p>In-place equivalent of <code>normscale</code>: changes <code>flat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.normscale-Tuple{ModulatedFourierLattice,Real}" href="#Crystalline.normscale-Tuple{ModulatedFourierLattice,Real}"><code>Crystalline.normscale</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normscale(flat::ModulatedFourierLattice, expon::Real) --&gt; ModulatedFourierLattice</code></pre><p>Applies subsequent norm-rescaling via <code>expon</code>; see detailed description  in <code>modulate</code>. An in-place variant is provided as <code>normscale!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L368-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.orbit-Tuple{AbstractArray{var&quot;#s127&quot;,1} where var&quot;#s127&quot;&lt;:(AbstractArray{var&quot;#s126&quot;,2} where var&quot;#s126&quot;&lt;:Real),AbstractArray{var&quot;#s125&quot;,1} where var&quot;#s125&quot;&lt;:Real}" href="#Crystalline.orbit-Tuple{AbstractArray{var&quot;#s127&quot;,1} where var&quot;#s127&quot;&lt;:(AbstractArray{var&quot;#s126&quot;,2} where var&quot;#s126&quot;&lt;:Real),AbstractArray{var&quot;#s125&quot;,1} where var&quot;#s125&quot;&lt;:Real}"><code>Crystalline.orbit</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orbit(Ws, x)</code></pre><p>Computes the orbit of <code>x</code> under a set of point-group operations <code>Ws</code>, i.e. computes the set <code>{gx | gâˆˆG}</code> where <code>g</code> denotes elements of the group <code>G</code> composed of all operations in <code>Ws</code> (possibly iterated, to ensure full coverage).</p><p>At the moment, we only consider <em>point group</em> operations; i.e. there are  no nonsymmorphic <code>Ws</code> parts. </p><p>It is important that <code>Ws</code> and <code>x</code> are given in the same basis. </p><p>[W&#39; = PWPâ»Â¹ if the basis change is from coordinates r to r&#39; = Pr, corresponding  to a new set of basis vectors (xÌ‚&#39;)áµ€=xÌ‚áµ€P; e.g., when going from a direct basis representation to a Cartesian one, the basis change matrix is P = [Râ‚ Râ‚‚ Râ‚ƒ], with Ráµ¢ inserted as column vectors]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L182-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D" href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D"><code>Crystalline.pointgroup</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointgroup(ops:AbstractVector{SymOperation{D}})
pointgroup(sg::AbstractGroup)</code></pre><p>Computes the point group associated with a space group <code>sg</code> (characterized by a set of operators <code>ops</code>, which, jointly with lattice translations generate  the space group), obtained by &quot;taking away&quot; any translational parts and  then reducing to the resulting unique rotational operations. (technically, in the language of Bradley &amp; Cracknell, this is the so-called isogonal point group of <code>sg</code>; see Sec. 1.5).</p><p>Returns a <code>Vector</code> of <code>SymOperation</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L168-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.prepare_mpbcalc!-Union{Tuple{D}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real,String}} where D" href="#Crystalline.prepare_mpbcalc!-Union{Tuple{D}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real,String}} where D"><code>Crystalline.prepare_mpbcalc!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prepare_mpbcalc!(...)</code></pre><p>Formats a set of parameters that uniquely specify an MPB calculation, given a  space group number <code>sgnum</code>, a Fourier lattice <code>flat</code>, a DirectBasis <code>Rs</code>, a filling fraction <code>filling</code> for <code>flat</code>, interior and exterior (above, below the contour) permittivities <code>Îµin</code> and <code>Îµout</code>, as well as a list of k-vectors <code>kvecs</code>, an  identifying tag <code>id</code> (to label the calculation for book-keeping purposes), a  resolution for the MPB calculation <code>res</code>, and a selection of calculation type <code>runtype</code> (&quot;all&quot;, &quot;te&quot;, or &quot;tm&quot;). The results are written to requested IO <code>io</code>.</p><p>Our preferred choice is to write these parameters to a bash file, with a name generated by the <code>mpb_calcname(...)</code> method.</p><p>The options are expected to be fed to the <code>fourier-lattice.ctl</code> file, e.g. through a bash script of the following kind:</p><pre><code class="language-sh">    IFS=$&#39;\n&#39;; # stop command-substitutions from word-splitting at space

    PATH_TO_MPB_EXECUTABLE \
        (cat ${calcname}.sh)
        ctl/fourier-lattice.ctl 2&gt;&amp;1 | tee logs/${calcname}.log
        
    unset IFS; # restore usual command-substitution word-splitting practice</code></pre><p>on gbar, <code>PATH_TO_MPB_EXECUTABLE</code> is <code>~/postdoc/mpb-transform-dev/1.8-dev/bin/mpb</code>. Locally, in <code>mpb-ctl</code> we have a file <code>run-fourier-lattice.sh</code> which performs the  above, with <code>calcname</code> specified as an input parameter (assumed to be a subfolder <code>/input/</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/export2mpb.jl#L88-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Tuple{KVec,Char}" href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(kv::KVec, cntr::Char) --&gt; kvâ€²::KVec</code></pre><p>Transforms a conventional reciprocal coordinate vector <code>kv</code> to a standard primitive basis (specified by the centering type <code>cntr</code>), returning the associated reciprocal coordinate vector <code>kvâ€²</code>.</p><p>Note that a basis change matrix <span>$P$</span> (as returned by  <a href="@ref">Crystalline.primitivebasismatrix</a>) transforms direct coordinate vectors as <span>$râ€²=Pâ»Â¹r$</span> but transforms reciprocal coordinates as <span>$kâ€² = Páµ€k$</span> (see e.g. ITA7 Sec. 1.5.1.2 and 1.5.2.1). Recall also the distinction between transforming a basis and the coordinates of a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L550-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(flat::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flat)</code></pre><p>Given <code>flat</code> referred to a conventional basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flatâ€²</code> referred to the associated primitive basis. </p><p>Specifically, if <code>flat</code> refers to a direct conventional basis <code>Rs</code> <span>$â‰¡ (ğš ğ› ğœ)$</span> [with  coordinate vectors <span>$ğ« â‰¡ (râ‚, râ‚‚, râ‚ƒ)^T$</span>] then <code>flatâ€²</code> refers to a direct primitive basis <code>Rsâ€²</code> <span>$â‰¡ (ğšâ€² ğ›â€² ğœâ€²) â‰¡ (ğš ğ› ğœ)P$</span> [with coordinate vectors <span>$ğ«â€² â‰¡ (râ‚â€², râ‚‚â€², râ‚ƒâ€²)^T = Pâ»Â¹ğ«$</span>], where <span>$P$</span> denotes the basis-change matrix obtained from <code>primitivebasismatrix(...)</code>.</p><p>To compute the associated primitive basis vectors, see <a href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>primitivize(::DirectBasis, ::Char)</code></a> [specifically, <code>Rsâ€² = primitivize(Rs, cntr)</code>].</p><p><strong>Examples</strong></p><p>A centered (&#39;c&#39;) lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires <code>using PyPlot</code>):</p><pre><code class="language-julia-repl">julia&gt; using PyPlot
julia&gt; sgnum = 5; D = 2; cntr = centering(sgnum, D)  # &#39;c&#39; (body-centered)

julia&gt; Rs   = directbasis(sgnum, D)     # conventional basis (rectangular)
julia&gt; flat = levelsetlattice(sgnum, D) # Fourier lattice in basis of Rs
julia&gt; flat = modulate(flat)            # modulate the lattice coefficients
julia&gt; plot(flat, Rs)

julia&gt; Rsâ€²   = primitivize(Rs, cntr)    # primitive basis (oblique)
julia&gt; flatâ€² = primitivize(flat, cntr)  # Fourier lattice in basis of Rsâ€²
julia&gt; plot(flatâ€², Rsâ€²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L252-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.Basis{D},Integer}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.Basis{D},Integer}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(Vs::Basis, sgnum::Integer) --&gt; Rsâ€²::Basis</code></pre><p>Transforms a conventional <code>Basis</code> (either <code>DirectBasis</code> or <code>ReciprocalBasis</code>) <code>Vs</code> into its primitive equivalent <code>Vsâ€²</code>, provided that its centering differs from the conventional (P or p), by inferring the Bravais type from the space group number <code>sgnum</code> and applying an applying an appropriate (<code>Basis</code>-type specific) transformation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L427-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(Rs::DirectBasis, cntr::Char) --&gt; Rsâ€²::DirectBasis</code></pre><p>Transforms a conventional DirectBasis <code>Rs</code> into its primitive  equivalent <code>Rsâ€²</code>, with the transformation dependent on the centering type <code>cntr</code> (P, I, F, R, A, C, and p, c); for centering P and p, the  conventional and primive bases coincide.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L446-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{ReciprocalBasis{D},Char}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{ReciprocalBasis{D},Char}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(Gs::ReciprocalBasis, cntr::Char) --&gt; Gsâ€²::ReciprocalBasis</code></pre><p>Calculates the <strong>primitive</strong> reciprocal basis associated with an assumed <strong>conventional</strong> reciprocal basis <code>Gs::ReciprocalBasis</code> with centering type <code>cntr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L494-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{SymOperation{D},Char}, Tuple{SymOperation{D},Char,Bool}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{SymOperation{D},Char}, Tuple{SymOperation{D},Char,Bool}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --&gt; SymOperation</code></pre><p>Transforms a symmetry operation <code>op</code> <span>$= \{W|w\}$</span> from a conventional cell to a primitive cell (specified by its centering character <code>cntr</code>), then denoted <span>$\{W&#39;|w&#39;\}$</span>; i.e. performs a basis change <code>opâ€²</code> <span>$â‰¡ \{W&#39;|w&#39;\} = \{P|p\}â»Â¹\{W|w\}\{P|p\}$</span> where <span>$P$</span> and <span>$p$</span> are the basis change matrix and origin shifts, respectively, of the transformation.</p><p>By default, translation parts of <code>opâ€²</code>, i.e. <span>$w&#39;$</span> are reduced modulo 1 (<code>modw = true</code>); to disable this, set <code>modw = false</code>.</p><p>For additional details, see ITA6 Sec. 1.5.2.3, p. 84.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L494-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D},1}}, Tuple{D}, Tuple{AbstractArray{LGIrrep{D},1},Bool}} where D" href="#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D},1}}, Tuple{D}, Tuple{AbstractArray{LGIrrep{D},1},Bool}} where D"><code>Crystalline.realify</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">realify(lgirs::AbstractVector{&lt;:LGIrrep}, verbose::Bool=false)
                                                    --&gt; AbstractVector{&lt;:LGIrrep}</code></pre><p>From <code>lgirs</code>, a vector of <code>LGIrrep</code>s, determine the associated (gray) co-representations, i.e. the &quot;real&quot;, or &quot;physical&quot; irreps that are relevant in scenarios with time-reversal symmetry.</p><p>For <code>LGIrrep</code> that are real (<code>type=1</code>), or that characterize a k-point ğ¤ which is not equivalent to -ğ¤ (i.e. its star does not include both ğ¤ and -ğ¤; equivalently, the little group includes time-reversal symmetry), the associated co-representations are just the  original irreps themselves.  For pseudo-real (<code>type=2</code>) and complex (<code>type=3</code>) <code>LGIrrep</code>s where Â±ğ¤ are equivalent, the associated co-representations are built from pairs of irreps that &quot;stick&quot; together. This method computes this pairing and sets the <code>LGIrrep</code> field <code>iscorep</code> to true, to indicate that the resulting &quot;paired irrep&quot; (i.e. the co-representation) should be doubled with  itself (pseudo-real type) or its complex conjugate (complex type).</p><p><strong>Background</strong></p><p>For background, see p. 650-652 (and 622-626 for point groups) in Bradley &amp; Cracknell&#39;s book. Their discussion is for magnetic groups (the &quot;realified&quot; irreps are really correspond to co-representations of &quot;gray&quot; magnetic groups).  Cornwell&#39;s book also does a good job of explicating this, as does Inui (p. 296-299).</p><p><strong>Keyword arguments</strong></p><ul><li><code>verbose::Bool</code>: if set to <code>true</code>, prints details about mapping from small irrep to small</li></ul><p>corep for each <code>LGIrrep</code> (default: <code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/irreps_reality.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.reciprocalbasis-Union{Tuple{Union{Tuple{Vararg{Array{var&quot;#s130&quot;,1} where var&quot;#s130&quot;&lt;:Real,D}}, DirectBasis{D}}}, Tuple{D}} where D" href="#Crystalline.reciprocalbasis-Union{Tuple{Union{Tuple{Vararg{Array{var&quot;#s130&quot;,1} where var&quot;#s130&quot;&lt;:Real,D}}, DirectBasis{D}}}, Tuple{D}} where D"><code>Crystalline.reciprocalbasis</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reciprocalbasis(Rs::DirectBasis{D}) --&gt; Gs::ReciprocalBasis{D}</code></pre><p>Calculates the reciprocal basis associated with a <code>DirectBasis</code> <code>Rs</code> (alternatively supplied as an <code>NTuple</code> of <code>Vector</code>s). Returns a <code>ReciprocalBasis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L396-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.schoenflies-Tuple{Integer}" href="#Crystalline.schoenflies-Tuple{Integer}"><code>Crystalline.schoenflies</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">schoenflies(sgnum::Integer) --&gt; String</code></pre><p>Returns the Schoenflies notation for a given space group number <code>sgnum</code>. Schoenflies notation only applies to point groups and  space groups, not plane groups, so this notation is only relevant in three dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/notation.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D" href="#Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D"><code>Crystalline.seitz</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">seitz(op::SymOperation) --&gt; String</code></pre><p>Computes the correponding Seitz notation for a symmetry operation in triplet/xyzt form.</p><p>Implementation based on ITA5 Table 11.2.1.1, with 3D point group parts inferred from the trace and determinant of the matrix <span>$W$</span> in the triplet <span>${W|w}$</span>.</p><table><tr><th style="text-align: right">detW\trW</th><th style="text-align: right">-3</th><th style="text-align: right">-2</th><th style="text-align: right">-1</th><th style="text-align: right">0</th><th style="text-align: right">1</th><th style="text-align: right">2</th><th style="text-align: right">3</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">2</td><td style="text-align: right">3</td><td style="text-align: right">4</td><td style="text-align: right">6</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">-1</td><td style="text-align: right">-1</td><td style="text-align: right">-6</td><td style="text-align: right">-4</td><td style="text-align: right">-3</td><td style="text-align: right">m</td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>with the elements of the table giving the type of symmetry operation in in Hermann-Mauguin notation. The rotation axis and the rotation sense are  computed following the rules in ITA6 Sec. 1.2.2.4(1)(b-c). The implementation has been checked against the Tables 1.4.2.1-5 of ITA6.</p><p>Note that the orientation of axis (i.e. its sign) is not necessarily equal to the orientation picked in those tables; it is a matter of convention, and the conventions have not been explicated in ITA6.</p><p>2D operations are treated by the same procedure, by elevation in a third dimension; 1D operations by a simple inspection of sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/notation.jl#L182-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D" href="#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>Crystalline.spacegroup</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spacegroup(sgnum::Integer, D::Integer=3) --&gt; SpaceGroup{D}</code></pre><p>Return the space group symmetry operations in for a given space group number <code>sgnum</code> and  dimensionality <code>D</code> as a <code>SpaceGroup{D}</code>. The returned symmetry operations are specified relative to the conventional basis choice, i.e. are not necessarily primitive (see <a href="#Crystalline.centering"><code>centering</code></a>). If desired, operations for the primitive unit cell can be subsequently generated using  <a href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>primitivize</code></a> or <a href="@ref"><code>reduce_ops</code></a>.</p><p>The default choices for the <em>conventional</em> basis vectors are specified in Bilbao as: </p><ul><li>Unique axis b (cell choice 1) for space groups within the monoclinic system.</li><li>Obverse triple hexagonal unit cell for R space groups.</li><li>Origin choice 2: inversion center at (0,0,0). (Relevant for the centrosymmetric space groups where there are two origin choices, in the orthorhombic, tetragonal and cubic  systems)</li></ul><p>See also <a href="#Crystalline.directbasis-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>directbasis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L22-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.splice_kvpath-Tuple{AbstractArray{var&quot;#s21&quot;,1} where var&quot;#s21&quot;&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real),Integer}" href="#Crystalline.splice_kvpath-Tuple{AbstractArray{var&quot;#s21&quot;,1} where var&quot;#s21&quot;&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real),Integer}"><code>Crystalline.splice_kvpath</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">splice_kvpath(kvs::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, Nsplice::Integer) 
                                                            --&gt; Vector{Vector{Float64}}</code></pre><p>Computes an interpolated <span>$k$</span>-path between the discrete <span>$k$</span>-points in <code>kvs</code>, inserting <code>Nsplice</code> points between each pair of adjacent <span>$k$</span>-points.</p><p>See also <a href="#Crystalline.interpolate_kvpath-Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:(AbstractArray{var&quot;#s25&quot;,1} where var&quot;#s25&quot;&lt;:Real),Integer}"><code>interpolate_kvpath</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/utils.jl#L289-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.subduction_count-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Union{Nothing, Array{var&quot;#s127&quot;,1} where var&quot;#s127&quot;&lt;:Real}}} where T&lt;:Crystalline.AbstractIrrep" href="#Crystalline.subduction_count-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Union{Nothing, Array{var&quot;#s127&quot;,1} where var&quot;#s127&quot;&lt;:Real}}} where T&lt;:Crystalline.AbstractIrrep"><code>Crystalline.subduction_count</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subduction_count(Dá´³áµ¢, Dá´´â±¼[, Î±Î²Î³á´´â±¼]) --&gt; Int64</code></pre><p>For two groups G and H, where H is a subgroup of G, i.e. G&gt;H, with associated  irreducible representations <code>Dá´³áµ¢</code><span>$(g)$</span> and <code>Dá´´â±¼</code><span>$(g)$</span> for elements <span>$gâˆˆG$</span> and <span>$hâˆˆH&lt;G$</span>, compute the compatibility relation between the two irreps from the subduction reduction formula (or &quot;magic&quot; formula/Schur orthogonality relation): this is essentially how many times <code>ná´³á´´áµ¢â±¼</code> the subduced representation <code>Dá´³áµ¢</code><span>$â†“H$</span> contains the irrep <code>Dá´´â±¼</code>;  in other words, this gives the compatibility between the two irreps.</p><p>Optionally, a vector <code>Î±Î²Î³á´´â±¼</code> may be provided, to evaluate the characters/irreps  of <code>Dá´³áµ¢</code> at a concrete value of Î±Î²Î³. This is e.g. meaningful for LGIrreps at non- special k-vectors. Defaults to <code>nothing</code>.</p><p>The reduction formula [e.g. Eq. (15) of https://arxiv.org/pdf/1706.09272.pdf] is:</p><p><span>$ná´³á´´áµ¢â±¼ = |H|^{-1}âˆ‘_h Ï‡^G_i(h)Ï‡^H_j(h)*$</span></p><p>As an example, consider space group 207 and the two compatible k-vectors  Î“ (a point) and Î£ (a line):</p><pre><code class="language-none">lgirsd  = get_lgirreps(207, Val(3));
Î“_lgirs = lgirsd[&quot;Î“&quot;]; # at Î“ â‰¡ [0.0, 0.0, 0.0]
Î£_lgirs = lgirsd[&quot;Î£&quot;]; # at Î£ â‰¡ [Î±, Î±, 0.0]</code></pre><p>We can test their compatibility like so:</p><pre><code class="language-none">[[subduction_count(Î“i, Î£j) for Î“i in Î“_lgirs] for Î£j in Î£_lgirs]
&gt; # Î“â‚ Î“â‚‚ Î“â‚ƒ Î“â‚„ Î“â‚…
&gt;  [ 1, 0, 1, 1, 2] # Î£â‚
&gt;  [ 0, 1, 1, 2, 1] # Î£â‚‚</code></pre><p>This entails the following compatibility relations between irreps at Î“ and Î£:</p><table><tr><th style="text-align: right">Compatibility relation</th><th style="text-align: right">Degeneracies</th></tr><tr><td style="text-align: right">Î“â‚ â†’ Î£â‚</td><td style="text-align: right">1 â†’ 1</td></tr><tr><td style="text-align: right">Î“â‚‚ â†’ Î£â‚‚</td><td style="text-align: right">1 â†’ 1</td></tr><tr><td style="text-align: right">Î“â‚ƒ â†’ Î£â‚ + Î£â‚‚</td><td style="text-align: right">2 â†’ 1 + 1</td></tr><tr><td style="text-align: right">Î“â‚„ â†’ Î£â‚ + 2Î£â‚‚</td><td style="text-align: right">3 â†’ 1 + 2</td></tr><tr><td style="text-align: right">Î“â‚… â†’ 2Î£â‚ + Î£â‚‚</td><td style="text-align: right">3 â†’ 2 + 1</td></tr></table><p>where, in this case, all the small irreps are one-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/compatibility.jl#L3-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.transform-Union{Tuple{D}, Tuple{KVec{D},AbstractArray{var&quot;#s129&quot;,2} where var&quot;#s129&quot;&lt;:Real}} where D" href="#Crystalline.transform-Union{Tuple{D}, Tuple{KVec{D},AbstractArray{var&quot;#s129&quot;,2} where var&quot;#s129&quot;&lt;:Real}} where D"><code>Crystalline.transform</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform(kv::KVec, P::AbstractMatrix{&lt;:Real}) --&gt; kvâ€²::KVec</code></pre><p>Returns a transformed reciprocal coordinate vector <code>kvâ€²</code> from an original reciprocal coordinate vector <code>kv</code> and a basis change matrix <code>P</code>.</p><p>Note that a basis change matrix <code>P</code> transforms reciprocal coordinates vectors as <span>$kâ€² = Páµ€k$</span> but transforms direct coordinate vectors as <span>$râ€²=Pâ»Â¹r$</span> (see e.g. ITA7 Sec. 1.5.1.2 and 1.5.2.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L535-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.transform-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{var&quot;#s27&quot;,2} where var&quot;#s27&quot;&lt;:Real}, Tuple{SymOperation{D},AbstractArray{var&quot;#s25&quot;,2} where var&quot;#s25&quot;&lt;:Real,Union{Nothing, AbstractArray{var&quot;#s22&quot;,1} where var&quot;#s22&quot;&lt;:Real}}, Tuple{SymOperation{D},AbstractArray{var&quot;#s21&quot;,2} where var&quot;#s21&quot;&lt;:Real,Union{Nothing, AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real},Bool}} where D" href="#Crystalline.transform-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{var&quot;#s27&quot;,2} where var&quot;#s27&quot;&lt;:Real}, Tuple{SymOperation{D},AbstractArray{var&quot;#s25&quot;,2} where var&quot;#s25&quot;&lt;:Real,Union{Nothing, AbstractArray{var&quot;#s22&quot;,1} where var&quot;#s22&quot;&lt;:Real}}, Tuple{SymOperation{D},AbstractArray{var&quot;#s21&quot;,2} where var&quot;#s21&quot;&lt;:Real,Union{Nothing, AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real},Bool}} where D"><code>Crystalline.transform</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform(op::SymOperation, P::Matrix{&lt;:Real}, 
          p::Union{Vector{&lt;:Real}, Nothing}=nothing,
          modw::Bool=true)                          --&gt; SymOperation</code></pre><p>Transforms a <code>op</code> <span>$= \{W|w\}$</span> by a rotation matrix <code>P</code> and a translation vector <code>p</code> (can be <code>nothing</code> for zero-translations), producing a new symmetry operation  <code>opâ€²</code> <span>$= \{W&#39;|w&#39;\}$</span>: (see ITA6, Sec. 1.5.2.3)</p><p><span>$\{W&#39;|w&#39;\} = \{P|p\}^{-1}\{W|w\}\{P|p\}$</span></p><p>with</p><p><span>$W&#39; = P^{-1}WP$</span> and <span>$w&#39; = P^{-1}(w+Wp-p)$</span></p><p>By default, the translation part of <code>opâ€²</code>, i.e. <span>$w&#39;$</span>, is reduced to the range <span>$[0,1)$</span>,  i.e. computed modulo 1. This can be disabled by setting <code>modw = false</code> (default, <code>modw = true</code>).</p><p>See also <a href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>primitivize</code></a> and <a href="#Crystalline.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D"><code>conventionalize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L527-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.wyckpos-Union{Tuple{D}, Tuple{Integer,Val{D}}} where D" href="#Crystalline.wyckpos-Union{Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>Crystalline.wyckpos</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wyckpos(sgnum, _)
</code></pre><p>Return the Wyckoff positions of space group <code>sgnum</code> in dimension <code>D</code> as a  <code>Vector{WyckPos{D}</code>.</p><p>The positions are given in the conventional basis setting, following the conventions of the Bilbao Crystallographic Server (from where the underlying data is obtained [1]).</p><p>[1] Aroyo, et. al. Zeitschrift fuer Kristallographie (2006), 221, 1, 15-27.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/wyckoff.jl#L38">source</a></section></article><h2 id="Unexported-API"><a class="docs-heading-anchor" href="#Unexported-API">Unexported API</a><a id="Unexported-API-1"></a><a class="docs-heading-anchor-permalink" href="#Unexported-API" title="Permalink"></a></h2><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Crystalline.BandRep" href="#Crystalline.BandRep"><code>Crystalline.BandRep</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BandRep &lt;: AbstractArray{Int64,1}</code></pre><ul><li><p><code>wyckpos::String</code></p></li><li><p><code>sitesym::String</code></p></li><li><p><code>label::String</code></p></li><li><p><code>dim::Integer</code></p></li><li><p><code>decomposable::Bool</code></p></li><li><p><code>spinful::Bool</code></p></li><li><p><code>irvec::Array{Int64,1}</code></p></li><li><p><code>irlabs::Array{String,1}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L569-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.BandRepSet" href="#Crystalline.BandRepSet"><code>Crystalline.BandRepSet</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BandRepSet &lt;: AbstractArray{BandRep,1}</code></pre><ul><li><p><code>sgnum::Int64</code></p></li><li><p><code>bandreps::Array{BandRep,1}</code></p></li><li><p><code>kvs::Array{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:KVec</code></p></li><li><p><code>klabs::Array{String,1}</code></p></li><li><p><code>irlabs::Array{String,1}</code></p></li><li><p><code>allpaths::Bool</code></p></li><li><p><code>spinful::Bool</code></p></li><li><p><code>timeinvar::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L605-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.CharacterTable" href="#Crystalline.CharacterTable"><code>Crystalline.CharacterTable</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CharacterTable{D}</code></pre><ul><li><p><code>ops::Array{SymOperation{D},1} where D</code></p></li><li><p><code>irlabs::Array{String,1}</code></p></li><li><p><code>chartable::Array{Complex{Float64},2}</code></p></li><li><p><code>tag::String</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L527-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.CharacterTable-Union{Tuple{AbstractArray{var&quot;#s15&quot;,1} where var&quot;#s15&quot;&lt;:Crystalline.AbstractIrrep{D}}, Tuple{D}, Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:Crystalline.AbstractIrrep{D},Union{Nothing, AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:Real}}} where D" href="#Crystalline.CharacterTable-Union{Tuple{AbstractArray{var&quot;#s15&quot;,1} where var&quot;#s15&quot;&lt;:Crystalline.AbstractIrrep{D}}, Tuple{D}, Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:Crystalline.AbstractIrrep{D},Union{Nothing, AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:Real}}} where D"><code>Crystalline.CharacterTable</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CharacterTable(irs::AbstractVector{&lt;:AbstractIrrep}, Î±Î²Î³=nothing)</code></pre><p>Returns a <code>CharacterTable</code> associated with vector of <code>AbstractIrrep</code>s <code>irs</code>. </p><p>Optionally, an <code>Î±Î²Î³::AbstractVector{&lt;:Real}</code> variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for <code>LGIrrep</code>s, a concrete k-vector sampled from a &quot;line-irrep&quot;). Defaults to <code>nothing</code>, indicating it being either  irrelevant (e.g., for <code>PGIrrep</code>s) or all free parameters implicitly set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L547-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.DirectBasis" href="#Crystalline.DirectBasis"><code>Crystalline.DirectBasis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DirectBasis{D} &lt;: Basis{D}</code></pre><ul><li>vecs:NTuple{D, SVector{D, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.GenericGroup" href="#Crystalline.GenericGroup"><code>Crystalline.GenericGroup</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GenericGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><code>operations::Array{SymOperation{D},1} where D</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L338-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D" href="#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>Crystalline.KVec</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">KVec{D}(str::AbstractString) --&gt; KVec{D}
KVec(str::AbstractString)    --&gt; KVec
KVec(::AbstractVector, ::AbstractMatrix) --&gt; KVec</code></pre><p>Return a <code>KVec</code> by parsing the string representations <code>str</code>, supplied in one of the following formats:</p><pre><code class="language-jl">&quot;($1,$2,$3)&quot;
&quot;[$1,$2,$3]&quot;
&quot;$1,$2,$3&quot;</code></pre><p>where the coordinates <code>$1</code>,<code>$2</code>, and <code>$3</code> are strings that may contain fractions, decimal numbers, and &quot;free&quot; parameters {<code>&#39;Î±&#39;</code>,<code>&#39;Î²&#39;</code>,<code>&#39;Î³&#39;</code>} (or, alternatively and equivalently, {<code>&#39;u&#39;</code>,<code>&#39;v&#39;</code>,<code>&#39;w&#39;</code>} or {<code>&#39;x&#39;</code>,<code>&#39;y&#39;</code>,<code>&#39;z&#39;</code>}).</p><p>Fractions such as <code>1/2</code> and decimal numbers can be parsed: but use of any other special operator besides <code>/</code> will produce undefined behavior (e.g. do not use <code>*</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; T(&quot;0.25,Î±,0&quot;)
[0.25, Î±, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L229-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.LGIrrep" href="#Crystalline.LGIrrep"><code>Crystalline.LGIrrep</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LGIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>lg::LittleGroup{D} where D</code></p></li><li><p><code>matrices::Array{Array{Complex{Float64},2},1}</code></p></li><li><p><code>translations::Array{Array{Float64,1},1}</code></p></li><li><p><code>type::Int64</code></p></li><li><p><code>iscorep::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L431-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.LittleGroup" href="#Crystalline.LittleGroup"><code>Crystalline.LittleGroup</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LittleGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>kv::KVec{D} where D</code></p></li><li><p><code>klab::String</code></p></li><li><p><code>operations::Array{SymOperation{D},1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L370-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.ModulatedFourierLattice" href="#Crystalline.ModulatedFourierLattice"><code>Crystalline.ModulatedFourierLattice</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModulatedFourierLattice{D} &lt;: AbstractFourierLattice{D}</code></pre><p>A <code>D</code>-dimensional concrete Fourier/plane wave lattice, derived from  a UnityFourierLattice by scaling/modulating its orbit coefficients  by complex numbers; in general, the coefficients do not have unit norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.MultTable" href="#Crystalline.MultTable"><code>Crystalline.MultTable</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MultTable{D} &lt;: AbstractArray{Int64,2}</code></pre><ul><li><p><code>operations::Array{SymOperation{D},1} where D</code></p></li><li><p><code>table::Array{Int64,2}</code></p></li><li><p><code>isgroup::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L121-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.MultTable-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D" href="#Crystalline.MultTable-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D"><code>Crystalline.MultTable</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MultTable(ops::AbstractVector{&lt;:SymOperation{D}}, modÏ„=true, verbose=false)</code></pre><p>Compute the multiplication (or Cayley) table of <code>ops</code>, an <code>AbstractVector</code> of <code>SymOperation{D}</code>s. The <code>modÏ„</code> keyword argument controls whether composition of operations is taken modulo lattice vectors (<code>true</code>, default) or not (<code>false</code>).</p><p>A <code>MultTable{D}</code> is returned, which contains symmetry operations resulting from composition  of <code>row âˆ˜ col</code> operators; the table of indices give the symmetry operators relative to the ordering of <code>ops</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L278-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.PGIrrep" href="#Crystalline.PGIrrep"><code>Crystalline.PGIrrep</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PGIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>pg::PointGroup{D} where D</code></p></li><li><p><code>matrices::Array{Array{Complex{Float64},2},1}</code></p></li><li><p><code>type::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L412-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.PointGroup" href="#Crystalline.PointGroup"><code>Crystalline.PointGroup</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PointGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>label::String</code></p></li><li><p><code>operations::Array{SymOperation{D},1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L358-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D" href="#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>Crystalline.RVec</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RVec{D}(str::AbstractString) --&gt; RVec{D}
RVec(str::AbstractString)    --&gt; RVec
RVec(::AbstractVector, ::AbstractMatrix) --&gt; RVec</code></pre><p>Return a <code>RVec</code> by parsing the string representations <code>str</code>, supplied in one of the following formats:</p><pre><code class="language-jl">&quot;($1,$2,$3)&quot;
&quot;[$1,$2,$3]&quot;
&quot;$1,$2,$3&quot;</code></pre><p>where the coordinates <code>$1</code>,<code>$2</code>, and <code>$3</code> are strings that may contain fractions, decimal numbers, and &quot;free&quot; parameters {<code>&#39;Î±&#39;</code>,<code>&#39;Î²&#39;</code>,<code>&#39;Î³&#39;</code>} (or, alternatively and equivalently, {<code>&#39;u&#39;</code>,<code>&#39;v&#39;</code>,<code>&#39;w&#39;</code>} or {<code>&#39;x&#39;</code>,<code>&#39;y&#39;</code>,<code>&#39;z&#39;</code>}).</p><p>Fractions such as <code>1/2</code> and decimal numbers can be parsed: but use of any other special operator besides <code>/</code> will produce undefined behavior (e.g. do not use <code>*</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; T(&quot;0.25,Î±,0&quot;)
[0.25, Î±, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L229-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.ReciprocalBasis" href="#Crystalline.ReciprocalBasis"><code>Crystalline.ReciprocalBasis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReciprocalBasis{D} &lt;: Basis{D}</code></pre><ul><li>vecs:NTuple{D, SVector{D, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.SpaceGroup" href="#Crystalline.SpaceGroup"><code>Crystalline.SpaceGroup</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SpaceGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>operations::Array{SymOperation{D},1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L348-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.SymOperation" href="#Crystalline.SymOperation"><code>Crystalline.SymOperation</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SymOperation{D} &lt;: AbstractArray{Float64,2}</code></pre><ul><li><p><code>rotation::Crystalline.SquareStaticMatrices.SqSMatrix{D,Float64} where D</code></p></li><li><p><code>translation::StaticArrays.SArray{Tuple{D},Float64,1,D} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L59-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.UnityFourierLattice" href="#Crystalline.UnityFourierLattice"><code>Crystalline.UnityFourierLattice</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>UnityFourierLatticeFourierLattice{D} &lt;: AbstractFourierLattice{D}</p><p>A general <code>D</code>-dimensional Fourier/plane wave lattice (specified  by G-orbits and coefficient interrelations); specifies the allowable  interrelations between coefficients within each orbit. The norm of  all orbit coefficients is unity. The G-orbits <code>orbits</code> (&amp; associated coefficients) are sorted in order of increasing |G| (low to high).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/lattices.jl#L14-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:âˆ˜-Union{Tuple{D}, Tuple{SymOperation{D},KVec{D}}, Tuple{SymOperation{D},KVec{D},Bool}} where D" href="#Base.:âˆ˜-Union{Tuple{D}, Tuple{SymOperation{D},KVec{D}}, Tuple{SymOperation{D},KVec{D},Bool}} where D"><code>Base.:âˆ˜</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(âˆ˜)(op::SymOperation, kv::KVec, checkabc::Bool=true) --&gt; KVec</code></pre><p>Computes the action of <code>op::SymOperation</code> <span>$â‰¡ g$</span> on <code>kv::KVec</code> <span>$â‰¡ k$</span> using that <span>$g$</span> acts on k-vectors as <span>$k(G)&#39; = [g(R)áµ€]â»Â¹k(G)$</span>, with <span>$g$</span>  in an <span>$R$</span>-basis and k in a <span>$G$</span>-basis. Returns a new <code>KVec</code>, that is  possibly distinct from its original only by a reciprocal lattice vector (i.e. multiple of integers).</p><p>If <code>checkabc = false</code>, the free part of <code>KVec</code> is not transformed (can be useful in situation when <code>kabc</code> is zero, and several  transformations are requested).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L468-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:âˆ˜-Union{Tuple{D}, Tuple{SymOperation{D},RVec{D}}} where D" href="#Base.:âˆ˜-Union{Tuple{D}, Tuple{SymOperation{D},RVec{D}}} where D"><code>Base.:âˆ˜</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">âˆ˜(op::SymOperation, qv::RVec) --&gt; RVec</code></pre><p>Return the composition of <code>op</code> <span>$= \{W|w\}$</span> with a real-space vector <code>qv</code>.</p><p>The operation is taken to act directly, i.e. returns <span>$\{W|w\}$</span><code>qv</code> <span>$= W$</span><code>qv</code><span>$+w$</span> rather than <span>$\{W|w\}^{-1}$</span><code>qv</code> <span>$= W^{-1}$</span><code>qv</code> <span>$- W^{-1}w$</span>, which can instead be obtained from <code>inv(op)âˆ˜qv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/wyckoff.jl#L64-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:âˆ˜-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Bool}} where T&lt;:SymOperation" href="#Base.:âˆ˜-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Bool}} where T&lt;:SymOperation"><code>Base.:âˆ˜</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(âˆ˜)(op1::T, op2::T, modÏ„::Bool=true) where T&lt;:SymOperation</code></pre><p>Compose two symmetry operations <code>op1</code> <span>$= \{Wâ‚|wâ‚\}$</span> and <code>op2</code> <span>$= \{Wâ‚‚|wâ‚‚\}$</span> using the composition rule (in Seitz notation)</p><p><span>$\{Wâ‚|wâ‚\}âˆ˜\{Wâ‚‚|wâ‚‚\} = \{Wâ‚Wâ‚‚|wâ‚+Wâ‚wâ‚‚\}$</span></p><p>By default, the translation part of the <span>$\{Wâ‚Wâ‚‚|wâ‚+Wâ‚wâ‚‚\}$</span> is reduced to the range <span>$[0,1[$</span>, i.e. computed modulo 1. This can be toggled off (or on) by the Boolean flag <code>modÏ„</code> (enabled, i.e. <code>true</code>, by default). Returns another <code>SymOperation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L193-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{T} where T&lt;:SymOperation" href="#Base.inv-Tuple{T} where T&lt;:SymOperation"><code>Base.inv</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inv(op::SymOperation{D}) --&gt; SymOperation{D}</code></pre><p>Compute the inverse {W|w}â»Â¹ â‰¡ {Wâ»Â¹|-Wâ»Â¹w} of an operator <code>op</code> â‰¡ {W|w}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Union{Tuple{D}, Tuple{KVec{D},KVec{D},Char}} where D" href="#Base.isapprox-Union{Tuple{D}, Tuple{KVec{D},KVec{D},Char}} where D"><code>Base.isapprox</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isapprox(kv1::KVec, kv2::KVec[, cntr::Char]; kwargs...) --&gt; Bool</code></pre><p>Compute approximate equality of two KVec&#39;s <code>k1</code> and <code>k2</code> modulo any  primitive G-vectors. To ensure that primitive G-vectors are used,  the centering type <code>cntr</code> (see <code>centering(cntr, dim)</code>) must be given (the dimensionality is inferred from <code>kv1</code> and <code>kv2</code>). Optionally, keyword arguments (e.g., <code>atol</code> and <code>rtol</code>) can be  provided, to include in calls to <code>Base.isapprox</code>.</p><p>If <code>cntr</code> is not provided, the comparison will not account for equivalence by primitive G-vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L295-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.:âŠš-Union{Tuple{T}, Tuple{T,T}} where T&lt;:SymOperation" href="#Crystalline.:âŠš-Union{Tuple{T}, Tuple{T,T}} where T&lt;:SymOperation"><code>Crystalline.:âŠš</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(âŠš)(op1::T, op2::T) where T&lt;:SymOperation --&gt;  Vector{Float64}</code></pre><p>Compose two symmetry operations <code>op1</code> <span>$= \{Wâ‚|wâ‚\}$</span> and <code>op2</code> <span>$= \{Wâ‚‚|wâ‚‚\}$</span> and return the quotient of <span>$wâ‚+Wâ‚wâ‚‚$</span> and 1. This functionality complements <code>op1âˆ˜op2</code>, which yields the translation modulo 1; accordingly,  <code>translation(op1âˆ˜op2) + op1âŠšop2</code> yields the translation component of the composition <code>op1</code> and <code>op2</code> <em>without</em> taking it modulo 1, i.e. including any &quot;trivial&quot; lattice translation.</p><p>Note that âŠš can be auto-completed in Julia via \circledcirc+[tab]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L240-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline._findsubgroup-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:(SymOperation{var&quot;#s27&quot;} where var&quot;#s27&quot;))" href="#Crystalline._findsubgroup-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{var&quot;#s52&quot;,1} where var&quot;#s52&quot;&lt;:(SymOperation{var&quot;#s27&quot;} where var&quot;#s27&quot;))"><code>Crystalline._findsubgroup</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_findsubgroup(opsá´³, opsá´´) --&gt; (Bool, Vector{Int64})</code></pre><p>Determine whether the group <span>$H$</span> (with operators <code>opsá´´</code>) is a subgroup of the group <span>$G$</span> (with operators <code>opsá´³</code>), i.e. whether <span>$H&lt;G$</span>, and returns an indexing vector <code>idxs</code> of <code>opsá´³</code> into <code>opsá´´</code> (empty if <code>false</code>), such that <code>opsá´³[idxs]</code> <span>$â‰¡ H$</span>.  The first return argument is a Boolean (whether <span>$H&lt;G$</span>); the second is <code>idxs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L698-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.basis2matrix-Union{Tuple{Crystalline.Basis{D}}, Tuple{D}} where D" href="#Crystalline.basis2matrix-Union{Tuple{Crystalline.Basis{D}}, Tuple{D}} where D"><code>Crystalline.basis2matrix</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">basis2matrix(Vs::Basis{D}) where D</code></pre><p>Compute a matrix <code>[Vs[1] Vs[2] .. Vs[D]]</code> from <code>Vs::Basis{D}</code>, i.e. a matrix whose columns are the basis vectors in <code>Vs</code>. </p><p>Note: Trying to use the iteration interface via <code>hcat(Vs...)</code> does not lead to a correctly       inferred type Matrix::Float64 (and a type-assertion does not improve speed much).       Instead, we just use the .vec field of <code>Vs</code> directly, which achieves good performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.compact_print_matrix" href="#Crystalline.compact_print_matrix"><code>Crystalline.compact_print_matrix</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compact_print_matrix(io, X, prerow)
compact_print_matrix(io, X, prerow, elformat)
compact_print_matrix(io, X, prerow, elformat, sep)
</code></pre><p>Canibalized and adapted from Base.print_matrix, specifically to allow a <code>prerow</code> input.</p><p>Should never be used for printing very large matrices, as it will not wrap or abbreviate rows/columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/utils.jl#L195-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.compatibility-Union{Tuple{Dict{String,var&quot;#s119&quot;} where var&quot;#s119&quot;&lt;:AbstractArray{LGIrrep{D},1}}, Tuple{D}} where D" href="#Crystalline.compatibility-Union{Tuple{Dict{String,var&quot;#s119&quot;} where var&quot;#s119&quot;&lt;:AbstractArray{LGIrrep{D},1}}, Tuple{D}} where D"><code>Crystalline.compatibility</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compatibility(lgirsd)
</code></pre><p>TODO: Seems entirely broken? Not sure what this is supposed to do.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/compatibility.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.connectivity-Union{Tuple{Dict{String,var&quot;#s117&quot;} where var&quot;#s117&quot;&lt;:AbstractArray{LGIrrep{D},1}}, Tuple{D}} where D" href="#Crystalline.connectivity-Union{Tuple{Dict{String,var&quot;#s117&quot;} where var&quot;#s117&quot;&lt;:AbstractArray{LGIrrep{D},1}}, Tuple{D}} where D"><code>Crystalline.connectivity</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connectivity(lgirsd)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/compatibility.jl#L161-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.find_compatible_kvec-Tuple{KVec,Array{KVec,1}}" href="#Crystalline.find_compatible_kvec-Tuple{KVec,Array{KVec,1}}"><code>Crystalline.find_compatible_kvec</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_compatible_kvec(kv, kvsâ€²)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/compatibility.jl#L75-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.findequiv-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{SymOperation{D},1},Char}} where D" href="#Crystalline.findequiv-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{SymOperation{D},1},Char}} where D"><code>Crystalline.findequiv</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findequiv(op::SymOperation, ops::AbstractVector{SymOperation{D}}, cntr::Char) 
                                            --&gt; Tuple{Int, Vector{Float64}}</code></pre><p>Search for an operator <code>opâ€²</code> in <code>ops</code> which is equivalent, modulo differences by <em>primitive</em> lattice translations <code>Î”w</code>, to <code>op</code>. Return the index of <code>opâ€²</code> in  <code>ops</code>, as well as the primitive translation difference <code>Î”w</code>. If no match is found returns <code>(nothing, nothing)</code>.</p><p>The small irreps of <code>op</code> at wavevector k, Dâ±¼áµ[<code>op</code>], can be computed from  the small irreps of <code>opâ€²</code>, Dâ±¼áµ[<code>opâ€²</code>], via Dâ±¼áµ[<code>op</code>] = exp(2Ï€ikâ‹…<code>Î”w</code>)Dâ±¼áµ[<code>opâ€²</code>]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L663-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.fractionify!" href="#Crystalline.fractionify!"><code>Crystalline.fractionify!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fractionify!(io::IO, x::Real, forcesign::Bool=true, tol::Real=1e-4)</code></pre><p>Write a string representation of the nearest fraction (within a tolerance <code>tol</code>) of <code>x</code> to  <code>io</code>. If <code>forcesign</code> is true, the sign character of <code>x</code> is printed whether <code>+</code> or <code>-</code>  (otherwise, only printed if <code>-</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/utils.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.freeparams-Tuple{Crystalline.AbstractVec}" href="#Crystalline.freeparams-Tuple{Crystalline.AbstractVec}"><code>Crystalline.freeparams</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">freeparams(v)
</code></pre><p>Return a vector whose entries are <code>true</code> (<code>false</code>) if the free parameters Î±,Î²,Î³,  respectively, occur with nonzero (zero) coefficients in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.is_compatible_kvec-Tuple{KVec,KVec}" href="#Crystalline.is_compatible_kvec-Tuple{KVec,KVec}"><code>Crystalline.is_compatible_kvec</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_compatible_kvec(kv, kvâ€²)
</code></pre><p>Check whether a special k-point <code>kv</code> is compatible with a non-special k-point <code>kvâ€²</code>. If so, return an <code>Î±Î²Î³â€²</code> value such that <code>kv = kvâ€²(Î±Î²Î³â€²)</code>.</p><p>TODO: This method should eventually be merged with the equivalently named method in       PhotonicBandConnectivity/src/connectivity.jl, which handles everything more correctly,       but currently has a slightly incompatible API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/compatibility.jl#L95-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.isapproxin-Tuple{Any,Any,Vararg{Any,N} where N}" href="#Crystalline.isapproxin-Tuple{Any,Any,Vararg{Any,N} where N}"><code>Crystalline.isapproxin</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isapproxin(x, itr) --&gt; Bool</code></pre><p>Determine whether <code>x</code> âˆˆ <code>itr</code> with approximate equality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/utils.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.lattice_from_mpbparams-Tuple{IO}" href="#Crystalline.lattice_from_mpbparams-Tuple{IO}"><code>Crystalline.lattice_from_mpbparams</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lattice_from_mpbparams(filepath::String)</code></pre><p>This will load an input file with path <code>filepath</code> that was previously created by <code>prepare_mpbcalc(!)</code> and return the associated lattice as Julia objects.</p><p>Output:</p><pre><code class="language-jl">    Rs::DirectBasis,
    flat::ModulatedFourierLattice,
    isoval::Float64,
    epsin::Float64,
    epsout::Float64
    kvecs::Vector{SVector{D, Float64}}</code></pre><p>Note that <code>flat</code> does not retain information about orbit groupings, since we flatten the  orbits into a single vector in <code>lattice2mpb</code>. This doesn&#39;t matter as we typically just want to plot the saved lattice (see <code>plot_lattice_from_mpbparams</code> from <code>compat/pyplot.jl</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/export2mpb.jl#L252-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.matching_littlegroups-Tuple{BandRepSet}" href="#Crystalline.matching_littlegroups-Tuple{BandRepSet}"><code>Crystalline.matching_littlegroups</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matching_littlegroups(BRS::BandRepSet)</code></pre><p>Finds the matching little groups for each <em>k</em>-point referenced in <code>BRS</code>. This is mainly a  a convenience accessor, since e.g. <code>littlegroup(::SpaceGroup, ::KVec)</code> could already give the required little groups. The benefit here is that the resulting operator sorting of the returned little group is identical ISOTROPY&#39;s, so we can rely on that later on.</p><p>Returns a <code>Vector{&lt;:LittleGroup}</code> with ordering identical to that of the k-point labels in  <code>BRS</code>. Note that this is different from the return type of <code>get_littlegroups</code> which returns an unordered <code>Dict</code>.</p><p><strong>Note 1</strong></p><p>The little groups from ISOTROPY do not include copies of operators that would be identical when transformed to a primitive basis. The operators are, however, still given in a conventional basis.</p><p><strong>Note 2</strong></p><p>An error is thrown if a referenced little group cannot be found (currently, this can happen for certain k-points in <span>$Î¦-Î©$</span>, see src/special<em>representation</em>domain_kpoints.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bandrep.jl#L323-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.nfreeparams-Tuple{Crystalline.AbstractVec}" href="#Crystalline.nfreeparams-Tuple{Crystalline.AbstractVec}"><code>Crystalline.nfreeparams</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nfreeparams(v)
</code></pre><p>Return total number of free parameters occuring in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/types.jl#L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.parsefraction-Tuple{AbstractString}" href="#Crystalline.parsefraction-Tuple{AbstractString}"><code>Crystalline.parsefraction</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parsefraction(str::AbstractString)</code></pre><p>Parse a string <code>str</code>, allowing fraction inputs (e.g. <code>&quot;1/2&quot;</code>), return as <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/utils.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivebasismatrix" href="#Crystalline.primitivebasismatrix"><code>Crystalline.primitivebasismatrix</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">primitivebasismatrix(cntr::Char, D::Integer) -&gt; ::Matrix{Float64}</code></pre><p>Given a centering type <code>cntr</code> and a dimensionality <code>D</code>, calculates a  transformation matrix <code>P</code> from a conventional to a primitive unit cell, using dictionary lookup.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L361-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.read_sgops_xyzt" href="#Crystalline.read_sgops_xyzt"><code>Crystalline.read_sgops_xyzt</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_sgops_xyzt(sgnum::Integer, dim::Integer=3)</code></pre><p>Obtains the symmetry operations in xyzt format for a given space group number <code>sgnum</code> by reading from json files; see <code>spacegroup</code> for additional details. Much faster than crawling; generally preferred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/symops.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.relrand-Tuple{Tuple{var&quot;#s129&quot;,var&quot;#s129&quot;} where var&quot;#s129&quot;&lt;:Real}" href="#Crystalline.relrand-Tuple{Tuple{var&quot;#s129&quot;,var&quot;#s129&quot;} where var&quot;#s129&quot;&lt;:Real}"><code>Crystalline.relrand</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relrand(lims::NTuple{2,Real}, N=1) --&gt; Vector{Float64}</code></pre><p>Computes a random number in the range specified by the two-element  tuple <code>lims</code>. The random numbers are sampled from two uniform  distributions, namely [<code>lims[1]</code>, 1] and [1, <code>lims[2]</code>], in such a way as to ensure that the sampling is uniform over the joint   interval [-1/<code>lims[1]</code>, -1] âˆª [1, <code>lims[2]</code>].</p><p>This is useful for ensuring an even sampling of numbers that are either smaller or larger than unity. Eg. for <code>x = relrand((0.2,5.0))</code>, <code>x</code> is equally probable to fall in inv(<code>x</code>)âˆˆ[1,5] or <code>x</code>âˆˆ[1,5].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bravais.jl#L183-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.rotation_order-Tuple{AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Real}" href="#Crystalline.rotation_order-Tuple{AbstractArray{var&quot;#s58&quot;,2} where var&quot;#s58&quot;&lt;:Real}"><code>Crystalline.rotation_order</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotation_order(W::Matrix{&lt;:Real}) --&gt; Int
rotation_order(op::SymOperation)  --&gt; Int</code></pre><p>Determine the integer rotation order of a point group operation, input either as a matrix <code>W</code> or <code>op::SymOperation</code>.</p><p>The rotation order of</p><ul><li>Proper rotations is positive.</li><li>Improper (mirrors, inversion, roto-inversions) is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/notation.jl#L325-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.rotation_order_3d-Tuple{Real,Real}" href="#Crystalline.rotation_order_3d-Tuple{Real,Real}"><code>Crystalline.rotation_order_3d</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotation_order_3d(detW::Real, trW::Real) --&gt; Int</code></pre><p>Determine the integer rotation order of a 3D point group operation with a 3Ã—3 matrix  representation <code>W</code> (alternatively specified by its determinant <code>detW</code> and its trace <code>trW</code>).</p><p>The rotation order of</p><ul><li>Proper rotations is positive.</li><li>Improper (mirrors, inversion, roto-inversions) is negative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/notation.jl#L285-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.uniquetol-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T" href="#Crystalline.uniquetol-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T"><code>Crystalline.uniquetol</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uniquetol(a; kwargs)</code></pre><p>Computes approximate-equality unique with tolerance specifiable via keyword arguments <code>kwargs</code> in O(nÂ²) runtime.</p><p>Copied from https://github.com/JuliaLang/julia/issues/19147#issuecomment-256981994</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/utils.jl#L235-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.wyckbasis-Tuple{BandRepSet}" href="#Crystalline.wyckbasis-Tuple{BandRepSet}"><code>Crystalline.wyckbasis</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wyckbasis(BRS::BandRepSet) --&gt; Vector{Vector{Int64}}</code></pre><p>Computes the (band representation) basis for bands generated by localized orbitals placed at the Wyckoff positions. Any band representation that can be expanded on this basis with positive integer coefficients correspond to a trivial insulators (i.e. deformable to atomic limit). Conversely, bands that cannot are topological, either fragily (some negative coefficients) or strongly (fractional coefficients).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/5086e2847d555547a04cf7e6ea9b466390fdd681/src/bandrep.jl#L206-L215">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">Â« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 9 December 2020 22:01">Wednesday 9 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
