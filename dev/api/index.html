<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Crystalline.jl</title><meta name="title" content="API · Crystalline.jl"/><meta property="og:title" content="API · Crystalline.jl"/><meta property="twitter:title" content="API · Crystalline.jl"/><meta name="description" content="Documentation for Crystalline.jl."/><meta property="og:description" content="Documentation for Crystalline.jl."/><meta property="twitter:description" content="Documentation for Crystalline.jl."/><meta property="og:url" content="https://thchr.github.io/Crystalline.jl/api/"/><meta property="twitter:url" content="https://thchr.github.io/Crystalline.jl/api/"/><link rel="canonical" href="https://thchr.github.io/Crystalline.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="Crystalline.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="Crystalline.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Crystalline.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../operations/">Symmetry operations</a></li><li><a class="tocitem" href="../groups/">Groups</a></li><li><a class="tocitem" href="../irreps/">Irreps</a></li><li><a class="tocitem" href="../bravais/">Bravais types &amp; bases</a></li><li><a class="tocitem" href="../bandreps/">Band representations</a></li><li><a class="tocitem" href="../lattices/">Lattices</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Exported-types"><span>Exported types</span></a></li><li><a class="tocitem" href="#Exported-methods"><span>Exported methods</span></a></li><li><a class="tocitem" href="#Exported-macros"><span>Exported macros</span></a></li><li><a class="tocitem" href="#Exported-constants"><span>Exported constants</span></a></li></ul></li><li><a class="tocitem" href="../internal-api/">Internal API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/thchr/Crystalline.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/thchr/Crystalline.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><hr/><h2 id="Exported-types"><a class="docs-heading-anchor" href="#Exported-types">Exported types</a><a id="Exported-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.BandRep" href="#Crystalline.BandRep"><code>Crystalline.BandRep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BandRep &lt;: AbstractVector{Int64}</code></pre><ul><li><p><code>wyckpos::String</code></p></li><li><p><code>sitesym::String</code></p></li><li><p><code>label::String</code></p></li><li><p><code>dim::Int64</code></p></li><li><p><code>spinful::Bool</code></p></li><li><p><code>irvec::Vector{Int64}</code></p></li><li><p><code>irlabs::Vector{String}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L1026-L1028">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.BandRepSet" href="#Crystalline.BandRepSet"><code>Crystalline.BandRepSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BandRepSet &lt;: AbstractVector{BandRep}</code></pre><ul><li><p><code>sgnum::Int64</code></p></li><li><p><code>bandreps::Vector{BandRep}</code></p></li><li><p><code>kvs::Vector{&lt;:KVec}</code></p></li><li><p><code>klabs::Vector{String}</code></p></li><li><p><code>irlabs::Vector{String}</code></p></li><li><p><code>spinful::Bool</code></p></li><li><p><code>timereversal::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L1067-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.CharacterTable" href="#Crystalline.CharacterTable"><code>Crystalline.CharacterTable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CharacterTable{D} &lt;: Crystalline.AbstractCharacterTable</code></pre><ul><li><p><code>ops::Array{SymOperation{D}, 1} where D</code></p></li><li><p><code>irlabs::Vector{String}</code></p></li><li><p><code>table::Matrix{ComplexF64}</code></p></li><li><p><code>tag::String</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L935-L937">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.Collection" href="#Crystalline.Collection"><code>Crystalline.Collection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Collection{T} &lt;: AbstractVector{T}</code></pre><p>A wrapper around a <code>Vector{T}</code>, that allows custom printing and dispatch rules of custom <code>T</code> (e.g., <code>AbstractIrrep</code> &amp; <code>NewBandRep</code>).</p><p>In Crystalline, it is assumed that all elements of the wrapped vector are associated with the <em>same</em> space, point, or little group. Accordingly, if <code>T</code> implements <a href="#Crystalline.dim-Tuple{BandRep}"><code>dim</code></a> or  <a href="#Crystalline.num-Tuple{Crystalline.AbstractGroup}"><code>num</code></a>, either must return the same value for each element of the <code>Collection</code> (and is equal to <code>dim(::Collection)</code> and <code>num(::Collection)</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L883-L894">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.CompositeBandRep" href="#Crystalline.CompositeBandRep"><code>Crystalline.CompositeBandRep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompositeBandRep{D} &lt;: AbstractSymmetryVector{D}</code></pre><p>A type representing a linear rational-coefficient combination of <code>NewBandRep{D}</code>s. </p><p>Although the coefficients may be rational numbers in general, their superposition must correspond to integer-valued irrep multiplicities and band occupation numbers; in particular, if they do not, conversion to a <code>SymmetryVector</code> will error.</p><p>See also <a href="../internal-api/#Crystalline.CompositeBandRep_from_indices-Tuple{Vector{Int64}, Collection{&lt;:NewBandRep}}"><code>CompositeBandRep_from_indices</code></a> for construction from a vector included indices into <code>brs</code>.</p><p><strong>Fields</strong></p><ul><li><code>coefs::Vector{Rational{Int}}</code>: a coefficient vector associated with each band representation in <code>brs</code>; the coefficient of the <code>i</code>th band representation <code>brs[i]</code> is <code>coefs[i]</code>.</li><li><code>brs::Collection{NewBandRep{D}}</code>: the band representations referenced by <code>coefs</code>.</li></ul><p><strong>Example</strong></p><p><strong>Fragile symmetry vector</strong></p><p>As a first example, we build a <code>CompositeBandRep</code> representing a fragilely topological configuration (i.e., featuring negative integer coefficients):</p><pre><code class="language-julia hljs">julia&gt; brs = calc_bandreps(2);

julia&gt; coefs = [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, -1];

julia&gt; cbr = CompositeBandRep(coefs, brs)
16-irrep CompositeBandRep{3}:
 (1g|Ag) + (1f|Aᵤ) + (1e|Ag) - (1a|Aᵤ) (2 bands)</code></pre><p>We can build the associated <a href="#Crystalline.SymmetryVector"><code>SymmetryVector</code></a> to inspect the associated irrep  content:</p><pre><code class="language-julia hljs">julia&gt; SymmetryVector(cbr)
 [2Z₁⁺, 2Y₁⁻, 2U₁⁻, 2X₁⁺, 2T₁⁺, 2Γ₁⁺, 2V₁⁺, 2R₁⁺] (2 bands)</code></pre><p>Similarly, we can confirm that <code>cbr</code> is indeed a simple linear combination of the associated band representations:</p><pre><code class="language-julia hljs">julia&gt; sum(c * brs[i] for (i, c) in enumerate(coefs)) == cbr
true</code></pre><p>And we can even do simple arithmetic with <code>cbr</code> (a <code>CompositeBandRep</code> is an element of a monoid:</p><pre><code class="language-julia hljs">julia&gt; cbr + 2cbr
3(1g|Ag) + 3(1f|Aᵤ) + 3(1e|Ag) - 3(1a|Aᵤ) (6 bands)</code></pre><p><strong>Nontrivial symmetry vector</strong></p><p>The coefficients of a <code>CompositeBandRep</code> can be non-integer, provided the associated irrep multiplicities of the overall summation are integer. Accordingly, a <code>CompositeBandRep</code> may also be used to represent a topologically nontrivial symmetry vector (and, by extension, any physical symmetry vector):</p><pre><code class="language-julia hljs">julia&gt; coefs = [-1//4, 0, -1//4, 0, -1//4, 0, 1//4, 0, 1//4, 0, 1//4, 0, -1//4, 0, 1//4, 1];

julia&gt; cbr = CompositeBandRep{3}(coefs, brs)
16-irrep CompositeBandRep{3}:
 -(1/4)×(1h|Ag) - (1/4)×(1g|Ag) - (1/4)×(1f|Ag) + (1/4)×(1e|Ag) + (1/4)×(1d|Ag) + (1/4)×(1c|Ag) - (1/4)×(1b|Ag) + (1/4)×(1a|Ag) + (1a|Aᵤ) (1 band)

julia&gt; SymmetryVector(cbr)
16-irrep SymmetryVector{3}:
 [Z₁⁺, Y₁⁻, U₁⁻, X₁⁻, T₁⁻, Γ₁⁻, V₁⁻, R₁⁻] (1 band)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L450-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D" href="#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>Crystalline.KVec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KVec{D}(str::AbstractString) --&gt; KVec{D}
KVec(str::AbstractString)    --&gt; KVec
KVec(::AbstractVector, ::AbstractMatrix) --&gt; KVec
KVec{D}(::AbstractVector, ::AbstractMatrix) --&gt; KVec{D}</code></pre><p>Return a <code>KVec</code> by parsing the string representations <code>str</code>, supplied in one of the following formats:</p><pre><code class="language-jl hljs">&quot;($1,$2,$3)&quot;
&quot;[$1,$2,$3]&quot;
&quot;$1,$2,$3&quot;</code></pre><p>where the coordinates <code>$1</code>,<code>$2</code>, and <code>$3</code> are strings that may contain fractions, decimal numbers, and &quot;free&quot; parameters {<code>&#39;α&#39;</code>,<code>&#39;β&#39;</code>,<code>&#39;γ&#39;</code>} (or, alternatively and equivalently, {<code>&#39;u&#39;</code>,<code>&#39;v&#39;</code>,<code>&#39;w&#39;</code>} or {<code>&#39;x&#39;</code>,<code>&#39;y&#39;</code>,<code>&#39;z&#39;</code>}).</p><p>Fractions such as <code>1/2</code> and decimal numbers can be parsed: but use of any other special operator besides <code>/</code> will produce undefined behavior (e.g. do not use <code>*</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; KVec(&quot;0.25,α,0&quot;)
[1/4, α, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L257-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.LGIrrep" href="#Crystalline.LGIrrep"><code>Crystalline.LGIrrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LGIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>g::LittleGroup</code></p></li><li><p><code>matrices::Vector{Matrix{ComplexF64}}</code></p></li><li><p><code>translations::Vector{Vector{Float64}}</code></p></li><li><p><code>reality::Reality</code></p></li><li><p><code>iscorep::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L836-L838">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.LittleGroup" href="#Crystalline.LittleGroup"><code>Crystalline.LittleGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LittleGroup{D} &lt;: Crystalline.AbstractGroup{D, SymOperation{D}}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>kv::KVec</code></p></li><li><p><code>klab::String</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L626-L628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.MSpaceGroup" href="#Crystalline.MSpaceGroup"><code>Crystalline.MSpaceGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MSpaceGroup{D} &lt;: Crystalline.AbstractGroup{D, MSymOperation{D}}</code></pre><ul><li><p><code>num::Tuple{Int64, Int64}</code></p></li><li><p><code>operations::Array{MSymOperation{D}, 1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/magnetic/types.jl#L39-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.MSymOperation" href="#Crystalline.MSymOperation"><code>Crystalline.MSymOperation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MSymOperation{D} &lt;: Crystalline.AbstractOperation{D}</code></pre><ul><li><p><code>op::SymOperation</code></p></li><li><p><code>tr::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/magnetic/types.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.ModulatedFourierLattice" href="#Crystalline.ModulatedFourierLattice"><code>Crystalline.ModulatedFourierLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModulatedFourierLattice{D} &lt;: AbstractFourierLattice{D}</code></pre><p>A <code>D</code>-dimensional concrete Fourier (plane wave) lattice, derived from  a <a href="../internal-api/#Crystalline.UnityFourierLattice"><code>UnityFourierLattice{D}</code></a> by scaling and modulating its orbit coefficients  by complex numbers; in general, the coefficients do not have unit norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.MultTable" href="#Crystalline.MultTable"><code>Crystalline.MultTable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MultTable{O} &lt;: AbstractArray{O, 2}</code></pre><ul><li><p><code>operations::Vector</code></p></li><li><p><code>table::Matrix{Int64}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L134-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.MultTable-Tuple{Any}" href="#Crystalline.MultTable-Tuple{Any}"><code>Crystalline.MultTable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultTable(ops::AbstractVector, modτ=true)</code></pre><p>Compute the multiplication (or Cayley) table of <code>ops</code>, an iterable of <code>SymOperation</code>s.</p><p>A <code>MultTable</code> is returned, which contains symmetry operations resulting from composition  of <code>row</code> and <code>col</code> operators; the table of indices give the symmetry operators relative to the ordering of <code>ops</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>modτ</code> (default: <code>true</code>): whether composition of operations is taken modulo lattice</li></ul><p>vectors (<code>true</code>) or not (<code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L305-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.PGIrrep" href="#Crystalline.PGIrrep"><code>Crystalline.PGIrrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PGIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>g::PointGroup</code></p></li><li><p><code>matrices::Vector{Matrix{ComplexF64}}</code></p></li><li><p><code>reality::Reality</code></p></li><li><p><code>iscorep::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L820-L822">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.PointGroup" href="#Crystalline.PointGroup"><code>Crystalline.PointGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PointGroup{D} &lt;: Crystalline.AbstractGroup{D, SymOperation{D}}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>label::String</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L613-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D" href="#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>Crystalline.RVec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RVec{D}(str::AbstractString) --&gt; RVec{D}
RVec(str::AbstractString)    --&gt; RVec
RVec(::AbstractVector, ::AbstractMatrix) --&gt; RVec
RVec{D}(::AbstractVector, ::AbstractMatrix) --&gt; RVec{D}</code></pre><p>Return a <code>RVec</code> by parsing the string representations <code>str</code>, supplied in one of the following formats:</p><pre><code class="language-jl hljs">&quot;($1,$2,$3)&quot;
&quot;[$1,$2,$3]&quot;
&quot;$1,$2,$3&quot;</code></pre><p>where the coordinates <code>$1</code>,<code>$2</code>, and <code>$3</code> are strings that may contain fractions, decimal numbers, and &quot;free&quot; parameters {<code>&#39;α&#39;</code>,<code>&#39;β&#39;</code>,<code>&#39;γ&#39;</code>} (or, alternatively and equivalently, {<code>&#39;u&#39;</code>,<code>&#39;v&#39;</code>,<code>&#39;w&#39;</code>} or {<code>&#39;x&#39;</code>,<code>&#39;y&#39;</code>,<code>&#39;z&#39;</code>}).</p><p>Fractions such as <code>1/2</code> and decimal numbers can be parsed: but use of any other special operator besides <code>/</code> will produce undefined behavior (e.g. do not use <code>*</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; RVec(&quot;0.25,α,0&quot;)
[1/4, α, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L257-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.Reality" href="#Crystalline.Reality"><code>Crystalline.Reality</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Reality &lt;: Enum{Int8}</code></pre><p>Enum type with instances</p><pre><code class="language-julia hljs">REAL = 1
PSEUDOREAL = -1
COMPLEX = 0</code></pre><p>The return value of <a href="#Crystalline.reality-Tuple{Crystalline.AbstractIrrep}"><code>reality(::AbstractIrrep)</code></a> and <a href="#Crystalline.calc_reality-Union{Tuple{D}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}, Union{Nothing, Vector{&lt;:Real}}}} where D"><code>calc_reality</code></a> is an instance of <code>Reality</code>. The reality type of an irrep is relevant for constructing &quot;physically real&quot; irreps (co-reps) via <a href="#Crystalline.realify-Tuple{AbstractDict{&lt;:AbstractString, &lt;:AbstractVector{&lt;:Crystalline.AbstractIrrep}}}"><code>realify</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L692-L706">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SiteGroup" href="#Crystalline.SiteGroup"><code>Crystalline.SiteGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SiteGroup{D} &lt;: Crystalline.AbstractGroup{D, SymOperation{D}}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>wp::WyckoffPosition</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li><li><p><code>cosets::Array{SymOperation{D}, 1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L644-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SiteIrrep" href="#Crystalline.SiteIrrep"><code>Crystalline.SiteIrrep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SiteIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>g::SiteGroup</code></p></li><li><p><code>matrices::Vector{Matrix{ComplexF64}}</code></p></li><li><p><code>reality::Reality</code></p></li><li><p><code>iscorep::Bool</code></p></li><li><p><code>pglabel::String</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L866-L868">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SpaceGroup" href="#Crystalline.SpaceGroup"><code>Crystalline.SpaceGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SpaceGroup{D} &lt;: Crystalline.AbstractGroup{D, SymOperation{D}}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L603-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SubperiodicGroup" href="#Crystalline.SubperiodicGroup"><code>Crystalline.SubperiodicGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SubperiodicGroup{D, P} &lt;: Crystalline.AbstractGroup{D, SymOperation{D}}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>operations::Array{SymOperation{D}, 1} where D</code></p></li></ul><p>A subperiodic group of embedding dimension <code>D</code> and periodicity dimension <code>P</code>. </p><p>Fields: </p><ul><li><code>operations</code>: the <code>SymOperation</code>s of the finite factor group <span>$G/T$</span>, where <span>$G$</span> is the</li></ul><p>subperiodic group and <span>$T$</span> is the translation group of the associated lattice.</p><ul><li><code>num</code>: the canonical number of the group, following the International Tables for</li></ul><p>Crystallography, Volume E.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/subperiodic.jl#L156-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SymOperation" href="#Crystalline.SymOperation"><code>Crystalline.SymOperation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SymOperation{D} &lt;: Crystalline.AbstractOperation{D}</code></pre><ul><li><p><code>rotation::Crystalline.SquareStaticMatrices.SqSMatrix{D, Float64} where D</code></p></li><li><p><code>translation::StaticArraysCore.SVector{D, Float64} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L41-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SymmetryVector" href="#Crystalline.SymmetryVector"><code>Crystalline.SymmetryVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymmetryVector{D} &lt;: AbstractSymmetryVector{D}</code></pre><p>A symmetry vector in dimension <code>D</code>, containing the featured irreps and their multiplicities and overall band occupation number.</p><p><strong>Fields</strong></p><ul><li><code>lgirsv :: Vector{Collection{LGIrrep{D}}}</code> (<code>const</code>): a vector of <code>LGIrrep{D}</code> collections associated with each high-symmetry <strong>k</strong>-point of a space group.</li><li><code>multsv :: JaggedVector{Int}}</code> (<code>const</code>): a vector of vectors of associated irrep multiplicities, with a <code>JaggedVector</code> representation. The irrep <code>lgirsv[i][j]</code> occurs with multiplicity <code>multsv[i][j]</code> in the symmetry vector.</li><li><code>occupation :: Int</code>: the occupation (number of bands) associated with the symmetry vector.</li></ul><p><strong>Interface</strong></p><ul><li>The irreps, multiplicities, and band occupation of a <code>SymmetryVector</code> can be obtained via <code>irreps</code>, <code>multiplicities</code>, and <code>occupation</code>, respectively.</li><li>The irrep-labels, <strong>k</strong>-labels, space group number of a <code>SymmetryVector</code> are available via <code>irreplabels</code>, <code>klabels</code>, and <code>num</code>, respectively.</li><li>The <code>SymmetryVector</code> can be converted to a &quot;raw&quot; concatenated vector representation via <code>Vector</code>.</li></ul><p><strong>Construction</strong></p><ul><li>From strings: see <code>parse(::Type{SymmetryVector{D}}, ::AbstractString, ::Vector{Collection{LGIrrep{D}}})</code>.</li><li>From &quot;raw&quot; concatenated vectors: see <a href="#Crystalline.SymmetryVector"><code>SymmetryVector</code></a><code>(::AbstractVector{&lt;:Integer}, ...)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L8-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SymmetryVector-Tuple{Crystalline.AbstractSymmetryVector}" href="#Crystalline.SymmetryVector-Tuple{Crystalline.AbstractSymmetryVector}"><code>Crystalline.SymmetryVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymmetryVector(n::AbstractSymmetryVector) -&gt; SymmetryVector</code></pre><p>Return a <code>SymmetryVector</code> realization of <code>n</code>. If <code>n</code> is already a <code>SymmetryVector</code>, return <code>n</code> directly; usually, the returned value will directly reference information in <code>n</code> (i.e., will not be a copy).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L284-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SymmetryVector-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Integer}, AbstractVector{String}, AbstractDict{String, &lt;:AbstractArray{LGIrrep{D}, 1}}}} where D" href="#Crystalline.SymmetryVector-Union{Tuple{D}, Tuple{AbstractVector{&lt;:Integer}, AbstractVector{String}, AbstractDict{String, &lt;:AbstractArray{LGIrrep{D}, 1}}}} where D"><code>Crystalline.SymmetryVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymmetryVector(
    nv :: AbstractVector{&lt;:Integer},
    irlabs_nv :: AbstractVector{&lt;:AbstractString},
    lgirsd :: AbstractDict{String, &lt;:AbstractVector{LGIrrep{D}}}) --&gt; SymmetryVector{D}</code></pre><p>Build a structured <code>SymmetryVector</code> representation of a &quot;raw&quot; vector <code>nv</code> of irrep multiplicities, whose <code>i</code>th element gives the irrep multiplicity of the irrep whose label  is <code>irlabs_nv[i]</code>. The corresponding full irrep information is inferred by comparison of labels in <code>irlabs_nv</code> and a provided set of covering irreps in <code>lgirsd</code>.</p><p>The raw vector <code>nv</code> must contain its band occupation number as its last element. The <code>irlabs_nv</code> vector must consequently have length <code>length(nv)-1</code>.</p><p>The sorting of irrep labels in <code>lgirsd</code> and (<code>nv</code>, <code>irlabs_nv</code>) is allowed to differ: this is the main utility of the function: to map between differently sorted raw vectors and a structured irrep storage in <code>lgirsd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L158-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.TopologyKind" href="#Crystalline.TopologyKind"><code>Crystalline.TopologyKind</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>TYPEDSIGNATURES</p><p>Enum type enumerating the possible &quot;coarse&quot; topological classifications diagnosable by symmetry within the topological quantum chemistry / symmtry indicator frameworks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/tqc_analysis.jl#L6-L11">source</a></section></article><h2 id="Exported-methods"><a class="docs-heading-anchor" href="#Exported-methods">Exported methods</a><a id="Exported-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{T} where T&lt;:SymOperation" href="#Base.inv-Tuple{T} where T&lt;:SymOperation"><code>Base.inv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(op::SymOperation{D}) --&gt; SymOperation{D}</code></pre><p>Compute the inverse {W|w}⁻¹ ≡ {W⁻¹|-W⁻¹w} of an operator <code>op</code> ≡ {W|w}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isapprox-Union{Tuple{T}, Tuple{D}, Tuple{T, T}, Tuple{T, T, Union{Nothing, Char, AbstractMatrix{&lt;:Real}}}, Tuple{T, T, Union{Nothing, Char, AbstractMatrix{&lt;:Real}}, Bool}} where {D, T&lt;:Crystalline.AbstractVec{D}}" href="#Base.isapprox-Union{Tuple{T}, Tuple{D}, Tuple{T, T}, Tuple{T, T, Union{Nothing, Char, AbstractMatrix{&lt;:Real}}}, Tuple{T, T, Union{Nothing, Char, AbstractMatrix{&lt;:Real}}, Bool}} where {D, T&lt;:Crystalline.AbstractVec{D}}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isapprox(v1::T, v2::T, 
         [cntr::Union{Char, Nothing, AbstractMatrix{&lt;:Real}}, modw::Bool];
         kwargs...) --&gt; Bool</code></pre><p>Compute approximate equality of two vector quantities <code>v1</code> and <code>v2</code> of type, <code>T = Union{&lt;:AbstractVec, &lt;:AbstractPoint}</code>. </p><p>If <code>modw = true</code>, equivalence is considered modulo lattice vectors. If <code>v1</code> and <code>v2</code> are in the conventional setting of a non-primitive lattice, the centering type <code>cntr</code> (see <a href="../bravais/#Bravais.centering"><code>Bravais.centering</code></a>) should be given to ensure that the relevant (primitive) lattice vectors are used in the comparison.</p><p><strong>Optional arguments</strong></p><ul><li><code>cntr</code>: if not provided, the comparison will not account for equivalence by primitive lattice vectors (equivalent to setting <code>cntr=nothing</code>), only equivalence by lattice vectors in the basis of <code>v1</code> and <code>v2</code>. <code>cntr</code> may also be provided as a <code>D</code>×<code>D</code> <code>AbstractMatrix</code> to give the relevant transformation matrix directly.</li><li><code>modw</code>: whether vectors that differ by multiples of a lattice vector are considered equivalent.</li><li><code>kwargs...</code>: optional keyword arguments (e.g., <code>atol</code> and <code>rtol</code>) to be forwarded to <code>Base.isapprox</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L346-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.position-Tuple{Crystalline.AbstractGroup}" href="#Base.position-Tuple{Crystalline.AbstractGroup}"><code>Base.position</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">position(x::Union{AbstractGroup, AbstractIrrep})</code></pre><p>If a position is associated with <code>x</code>, return it; if no position is associated, return <code>nothing</code>.</p><p>Applicable cases include <code>LittleGroup</code> (return the associated <strong>k</strong>-vector) and <code>SiteGroup</code> (returns the associated Wyckoff position), as well as their associated irrep types (<code>LGIrrep</code> and <code>SiteIrrep</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L577-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D}, DirectBasis{D}}} where D" href="#Bravais.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D}, DirectBasis{D}}} where D"><code>Bravais.cartesianize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cartesianize(op::SymOperation{D}, Rs::DirectBasis{D}) --&gt; SymOperation{D}</code></pre><p>Converts <code>opˡ</code> from a lattice basis to a Cartesian basis, by computing the transformed operators <code>opᶜ = 𝐑*opˡ*𝐑⁻¹</code> via the Cartesian basis matrix 𝐑 (whose columns are the <code>DirectBasis</code> vectors <code>Rs[i]</code>). </p><p><strong>Note 1</strong></p><p>The matrix 𝐑 maps vectors coefficients in a lattice basis 𝐯ˡ to coefficients in a Cartesian basis 𝐯ᶜ as 𝐯ˡ = 𝐑⁻¹𝐯ᶜ and vice versa as 𝐯ᶜ = 𝐑𝐯ˡ. Since a general transformation P  transforms an &quot;original&quot; vectors with coefficients 𝐯 to new coefficients 𝐯′ via 𝐯′ = P⁻¹𝐯 and since we here here consider the lattice basis as the &quot;original&quot; basis we have P = 𝐑⁻¹.  As such, the transformation of the operator <code>op</code> transforms as <code>opᶜ = P⁻¹*opˡ*P</code>, i.e. <code>opᶜ = transform(opˡ,P) = transform(opˡ,𝐑⁻¹)</code>.</p><p><strong>Note 2</strong></p><p>The display (e.g. Seitz and xyzt notation) of <code>SymOperation</code>s e.g. in the REPL implicitly assumes integer coefficients for its point-group matrix: as a consequence, displaying  <code>SymOperation</code>s in a Cartesian basis may produce undefined behavior. The matrix representation remains valid, however.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L826-L846">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.centering-Union{Tuple{Union{LittleGroup{D}, SpaceGroup{D}}}, Tuple{D}} where D" href="#Bravais.centering-Union{Tuple{Union{LittleGroup{D}, SpaceGroup{D}}}, Tuple{D}} where D"><code>Bravais.centering</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centering(g::AbstractGroup) --&gt; Char</code></pre><p>Return the conventional centering type of a group. </p><p>For groups without lattice structure (e.g., point groups), return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/notation.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D" href="#Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conventionalize(flat::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flat′)</code></pre><p>Given <code>flat</code> referred to a primitive basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flat′</code> referred to the associated conventional basis. </p><p>See also the complementary method <a href="../bravais/#Bravais.primitivize-Tuple{Crystalline.AbstractFourierLattice, Char}"><code>primitivize(::AbstractFourierLattice, ::Char)</code></a> for additional details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L301-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D" href="#Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conventionalize(v′::AbstractVec, cntr::Char)  --&gt;  v::typeof(v′)</code></pre><p>Transforms a primitive coordinate vector <code>v′</code> back to a standard conventional basis (specified by the centering type <code>cntr</code>), returning the conventional coordinate vector <code>v</code>.</p><p>See also <a href="../bravais/#Bravais.primitivize"><code>primitivize</code></a> and <a href="../bravais/#Bravais.transform"><code>transform</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L486-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.conventionalize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D" href="#Bravais.conventionalize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D"><code>Bravais.conventionalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conventionalize(op′::SymOperation, cntr::Char, modw::Bool=true) --&gt; typeof(op)</code></pre><p>Return a symmetry operation <code>op</code> <span>$= \{W|w\}$</span> in a conventional setting, transformed from an input symmetry operation <code>op′</code> <span>$≡ \{W&#39;|w&#39;\}$</span> in a primitive setting.</p><p>See <a href="../bravais/#Bravais.primitivize-Tuple{SymOperation, Char, Bool}"><code>primitivize(::SymOperation, ::Char, ::Bool)</code></a> for description of the centering argument <code>cntr</code> and optional argument <code>modw</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L666-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D" href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primitivize(flat::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flat)</code></pre><p>Given <code>flat</code> referred to a conventional basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flat′</code> referred to the associated primitive basis. </p><p>Specifically, if <code>flat</code> refers to a direct conventional basis <code>Rs</code> <span>$≡ (\mathbf{a} \mathbf{b} \mathbf{c})$</span> [with coordinate vectors <span>$\mathbf{r} ≡ (r_1, r_2, r_3)^{\mathrm{T}}$</span>] then <code>flat′</code> refers to a direct primitive basis <code>Rs′</code> <span>$≡ (\mathbf{a}&#39; \mathbf{b}&#39; \mathbf{c}&#39;) ≡ (\mathbf{a} \mathbf{b} \mathbf{c})\mathbf{P}$</span> [with coordinate vectors  <span>$\mathbf{r}&#39; ≡ (r_1&#39;, r_2&#39;, r_3&#39;)^{\mathrm{T}} = \mathbf{P}^{-1}\mathbf{r}$</span>], where <span>$\mathbf{P}$</span> denotes the basis-change matrix obtained from <code>primitivebasismatrix(...)</code>.</p><p>To compute the associated primitive basis vectors, see <a href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>primitivize(::DirectBasis, ::Char)</code></a> [specifically, <code>Rs′ = primitivize(Rs, cntr)</code>].</p><p><strong>Examples</strong></p><p>A centered (&#39;c&#39;) lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires a backend of Makie.jl, e.g., GLMakie.jl):</p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 5; D = 2; cntr = centering(sgnum, D)  # &#39;c&#39; (body-centered)

julia&gt; Rs   = directbasis(sgnum, Val(D))     # conventional basis (rectangular)
julia&gt; flat = levelsetlattice(sgnum, Val(D)) # Fourier lattice in basis of Rs
julia&gt; flat = modulate(flat)                 # modulate the lattice coefficients
julia&gt; plot(flat, Rs)

julia&gt; Rs′   = primitivize(Rs, cntr)    # primitive basis (oblique)
julia&gt; flat′ = primitivize(flat, cntr)  # Fourier lattice in basis of Rs′

julia&gt; using GLMakie
julia&gt; plot(flat′, Rs′)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L253-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D" href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primitivize(v::AbstractVec, cntr::Char)  --&gt;  v′::typeof(v)</code></pre><p>Transforms a conventional coordinate vector <code>v</code> to a standard primitive basis (specified by the centering type <code>cntr</code>), returning the primitive coordinate vector <code>v′</code>.</p><p>Note that a basis change matrix <span>$\mathbf{P}$</span> (as returned e.g. by <a href="../bravais/#Bravais.primitivebasismatrix"><code>Bravais.primitivebasismatrix</code></a>) transforms direct coordinate vectors (<a href="#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>RVec</code></a>) as <span>$\mathbf{r}&#39; = \mathbf{P}^{-1}\mathbf{r}$</span> but transforms reciprocal coordinates (<a href="#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>KVec</code></a>) as <span>$\mathbf{k}&#39; = \mathbf{P}^{\text{T}}\mathbf{k}$</span> <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>. Recall also the distinction between transforming a basis and the coordinates of a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L462-L476">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.primitivize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D" href="#Bravais.primitivize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --&gt; typeof(op)</code></pre><p>Return a symmetry operation <code>op′</code> <span>$≡ \{W&#39;|w&#39;\}$</span> in a primitive setting, transformed from an input symmetry operation <code>op</code> <span>$= \{W|w\}$</span> in a conventional setting. The operations <span>$\{W&#39;|w&#39;\}$</span> and <span>$\{W|w\}$</span> are related by a transformation <span>$\{P|p\}$</span> via (cf. Section 1.5.2.3 of <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>):</p><p class="math-container">\[\{W&#39;|w&#39;\} = \{P|p\}⁻¹\{W|w\}\{P|p\}.\]</p><p>where <span>$P$</span> and <span>$p$</span> are the basis change matrix and origin shifts, respectively. The relevant transformation <span>$\{P|p\}$</span> is inferred from the centering type, as provided by <code>cntr</code> (see also <a href="../bravais/#Bravais.centering"><code>Bravais.centering</code></a>).</p><p>By default, translation parts of <code>op′</code>, i.e. <span>$w&#39;$</span> are reduced modulo 1 (<code>modw = true</code>); to disable this, set <code>modw = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L635-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.primitivize-Union{Tuple{SiteGroup{D}}, Tuple{D}} where D" href="#Bravais.primitivize-Union{Tuple{SiteGroup{D}}, Tuple{D}} where D"><code>Bravais.primitivize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primitivize(siteg::SiteGroup{D}) where D</code></pre><p>Transform the operations, cosets, and Wyckoff position associated with <code>siteg</code> to a primitive setting. </p><p>If the input site group is associated with an trivially centered space group (i.e., centering <code>&#39;P&#39;</code> or <code>&#39;p&#39;</code>), a direct reference to the input is returned; if not, a new site group is built and returned, sharing no memory with the input.</p><p>The transformation of operations and cosets is performed <em>without</em> reduction of translations (i.e., passing <code>modw = false</code> to <a href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>primitivize(::SymOperation)</code></a>), consistent with Crystalline&#39;s convention of not reducing translations Wyckoff positions. The number of coset operations returned will be pruned, however, if this count is not equal to the number of positions in the primitive-cell orbit. Note that this is different from the behavior of e.g., <code>primitivize(::LittleGroup)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/wyckoff.jl#L361-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{&lt;:Real}}" href="#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{&lt;:Real}}"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform(v::AbstractVec, P::AbstractMatrix)  --&gt;  v′::typeof(v)</code></pre><p>Return a transformed coordinate vector <code>v′</code> from an original coordinate vector <code>v</code> using a basis change matrix <code>P</code>.</p><p>Note that a basis change matrix <span>$\mathbf{P}$</span> transforms direct coordinate vectors (<code>RVec</code>) as <span>$\mathbf{r}&#39; = \mathbf{P}^{-1}\mathbf{r}$</span> but transforms reciprocal coordinates (<code>KVec</code>) as <span>$\mathbf{k}&#39; = \mathbf{P}^{\mathrm{T}}\mathbf{k}$</span> <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L434-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Bravais.transform-Union{Tuple{D}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}, Union{Nothing, AbstractVector{&lt;:Real}}}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}, Union{Nothing, AbstractVector{&lt;:Real}}, Bool}} where D" href="#Bravais.transform-Union{Tuple{D}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}, Union{Nothing, AbstractVector{&lt;:Real}}}, Tuple{SymOperation{D}, AbstractMatrix{&lt;:Real}, Union{Nothing, AbstractVector{&lt;:Real}}, Bool}} where D"><code>Bravais.transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform(op::SymOperation, P::AbstractMatrix{&lt;:Real}, 
          p::Union{AbstractVector{&lt;:Real}, Nothing}=nothing,
          modw::Bool=true)                           --&gt; SymOperation</code></pre><p>Transforms a <code>op</code> <span>$= \{\mathbf{W}|\mathbf{w}\}$</span> by a rotation matrix <code>P</code> and a translation vector <code>p</code> (can be <code>nothing</code> for zero-translations), producing a new symmetry operation  <code>op′</code> <span>$= \{\mathbf{W}&#39;|\mathbf{w}&#39;\}$</span> (cf. Section 1.5.2.3 of <sup class="footnote-reference"><a id="citeref-ITA6" href="#footnote-ITA6">[ITA6]</a></sup>)</p><p class="math-container">\[\{\mathbf{W}&#39;|\mathbf{w}&#39;\} = \{\mathbf{P}|\mathbf{p}\}^{-1}\{\mathbf{W}|\mathbf{w}\}
\{\mathbf{P}|\mathbf{p}\}\]</p><p>with</p><p class="math-container">\[\mathbf{W}&#39; = \mathbf{P}^{-1}\mathbf{W}\mathbf{P}
\text{ and }
\mathbf{w}&#39; = \mathbf{P}^{-1}(\mathbf{w}+\mathbf{W}\mathbf{p}-\mathbf{p})\]</p><p>By default, the translation part of <code>op′</code>, i.e. <span>$\mathbf{w}&#39;$</span>, is reduced to the range <span>$[0,1)$</span>, i.e. computed modulo 1. This can be disabled by setting <code>modw = false</code> (default, <code>modw = true</code>).</p><p>See also <a href="../bravais/#Bravais.primitivize-Tuple{SymOperation, Char, Bool}"><code>Bravais.primitivize(::SymOperation, ::Char, ::Bool)</code></a> and <a href="../bravais/#Bravais.conventionalize-Tuple{SymOperation, Char, Bool}"><code>Bravais.conventionalize(::SymOperation, ::Char, ::Bool)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L685-L716">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.:⊕-Tuple{T, Vararg{T}} where T&lt;:Crystalline.AbstractIrrep" href="#Crystalline.:⊕-Tuple{T, Vararg{T}} where T&lt;:Crystalline.AbstractIrrep"><code>Crystalline.:⊕</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊕(ir1::T, ir2::T, ir3::T...) where T&lt;:AbstractIrrep --&gt; T</code></pre><p>Compute the representation obtained from direct sum of the irreps <code>ir1</code>, <code>ir2</code>, <code>ir3</code>, etc. The resulting representation is reducible and has dimension <code>irdim(ir1) + irdim(ir2) + irdim(ir3) + …</code>.</p><p>The groups of the provided irreps must be identical. If <code>T isa LGIrrep</code>, the irrep translation factors must also be identical (due to an implementation detail of the <code>LGIrrep</code> type).</p><p>Also provided via <code>Base.:+</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L802-L814">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.SymmetryVectors-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:Integer}}, AbstractVector{String}, AbstractDict{String, &lt;:AbstractArray{LGIrrep{D}, 1}}}} where D" href="#Crystalline.SymmetryVectors-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:Integer}}, AbstractVector{String}, AbstractDict{String, &lt;:AbstractArray{LGIrrep{D}, 1}}}} where D"><code>Crystalline.SymmetryVectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymmetryVectors(
    nvs :: AbstractVector{&lt;:Integer},
    irlabs_nv :: AbstractVector{&lt;:AbstractString},
    lgirsd :: AbstractDict{String, &lt;:AbstractVector{LGIrrep{D}}}) 
                                                        --&gt; Vector{SymmetryVector{D}}</code></pre><p>Similar to <a href="#Crystalline.SymmetryVector">`SymmetryVector(::AbstractVector{&lt;:Integer}, ::AbstractVector{&lt;:AbstractString}, ::AbstractDict)</a>, but for a vector of distinct raw multiplicy vectors <code>nvs</code>, rather than a single vector, returning a <code>Vector{SymmetryVector{D}}</code>.</p><p>The returned <code>SymmetryVector</code>s, <code>ns</code>, will share the same underlying irrep information such that <code>irreps(n) === irreps(n′)</code> for all <code>n</code> and <code>n′</code> in <code>ns</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L213-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.bandreps" href="#Crystalline.bandreps"><code>Crystalline.bandreps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bandreps(sgnum::Integer, D::Integer=3; 
         allpaths::Bool=false, spinful::Bool=false, timereversal::Bool=true) --&gt; BandRepSet</code></pre><p>Return the elementary band representations (EBRs) as a <code>BandRepSet</code> for space group <code>sgnum</code> and dimension <code>D</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>allpaths</code>: include a minimal sufficient set (<code>false</code>, default) or all (<code>true</code>)              <strong>k</strong>-vectors. </li><li><code>spinful</code>: single- (<code>false</code>, default) or double-valued (<code>true</code>) irreps, as appropriate for            spinless and spinful particles, respectively. Only available for <code>D=3</code>.</li><li><code>timereversal</code>: assume presence (<code>true</code>, default) or absence (<code>false</code>) of time-reversal                 symmetry.</li></ul><p><strong>References</strong></p><p>3D EBRs are obtained from the Bilbao Crystallographic Server&#39;s  <a href="http://www.cryst.ehu.es/cgi-bin/cryst/programs/bandrep.pl">BANDREP program</a>; please reference the original research papers noted there if used in published work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/bandrep.jl#L94-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.basisdim-Tuple{BandRepSet}" href="#Crystalline.basisdim-Tuple{BandRepSet}"><code>Crystalline.basisdim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">basisdim(brs::BandRepSet) --&gt; Int</code></pre><p>Return the dimension of the (linearly independent parts) of a band representation set. This is <span>$d^{\text{bs}} = d^{\text{ai}}$</span> in the notation of <a href="https://doi.org/10.1038/s41467-017-00133-2">Po, Watanabe, &amp; Vishwanath, Nature Commun. <strong>8</strong>, 50 (2017)</a>, or  equivalently, the rank of <code>stack(brs)</code> over the ring of integers. This is the number of linearly independent basis vectors that span the expansions of a band structure viewed as symmetry data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/bandrep.jl#L128-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.calc_bandreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D" href="#Crystalline.calc_bandreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D"><code>Crystalline.calc_bandreps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_bandreps(sgnum::Integer, Dᵛ::Val{D}=Val(3);
              timereversal::Bool=true,
              allpaths::Bool=false,
              explicitly_real::Bool=timereversal) 
                                                --&gt; Collection{NewBandRep{D}}</code></pre><p>Compute the band representations of space group <code>sgnum</code> in dimension <code>D</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>timereversal</code> (default, <code>true</code>): whether the irreps used to induce the band representations are assumed to be time-reversal invariant (i.e., are coreps, see  <a href="#Crystalline.realify-Tuple{AbstractDict{&lt;:AbstractString, &lt;:AbstractVector{&lt;:Crystalline.AbstractIrrep}}}"><code>realify</code></a>).</li><li><code>allpaths</code> (default, <code>false</code>): whether the band representations are projected to all distinct <strong>k</strong>-points returned by <code>lgirreps</code> (<code>allpaths = false</code>), including high-symmetry <strong>k</strong>-lines and -plane, or only to the maximal <strong>k</strong>-points (<code>allpaths = true</code>), i.e., just to high-symmetry points.</li><li><code>explicitly_real</code> (default, <code>timereversal</code>): whether, if <code>timereversal = true</code>, to ensure that the site symmetry irreps accompanying the band representations are chosen to be explicitly real (or &quot;physically&quot; real; see <a href="#Crystalline.physical_realify-Tuple{Union{PGIrrep, SiteIrrep}}"><code>physical_realify</code></a>). This is helpful for subsequent analysis of the action of time-reversal symmetry.</li></ul><p><strong>Notes</strong></p><p>All band representations associated with maximal Wyckoff positions are returned,  irregardless of whether they are elementary (i.e., no regard is made to whether the band representation is &quot;composite&quot;). As such, the returned band representations generally are a superset of the set of elementary band representations (and so contain all elementary band representations).</p><p><strong>Implementation</strong></p><p>The implementation is based on Cano, Bradlyn, Wang, Elcoro, et al., <a href="https://doi.org/10.1103/PhysRevB.97.035139">Phys. Rev. B <strong>97</strong>, 035139 (2018)</a>, Sections II.C-D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/calc_bandreps.jl#L255-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.calc_reality-Union{Tuple{D}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}, Union{Nothing, Vector{&lt;:Real}}}} where D" href="#Crystalline.calc_reality-Union{Tuple{D}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}, Union{Nothing, Vector{&lt;:Real}}}} where D"><code>Crystalline.calc_reality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_reality(lgir::LGIrrep, 
             sgops::AbstractVector{SymOperation{D}},
             αβγ::Union{Vector{&lt;:Real},Nothing}=nothing) --&gt; ::(Enum Reality)</code></pre><p>Compute and return the reality of a <code>lgir::LGIrrep</code> using the Herring criterion.</p><p>The computed value is one of three integers in <span>${1,-1,0}$</span>. In practice, this value is returned via a member of the Enum <code>Reality</code>, which has instances <code>REAL = 1</code>, <code>PSEUDOREAL = -1</code>, and <code>COMPLEX = 0</code>.</p><p><strong>Optional arguments</strong></p><p>As a sanity check, a value of <code>αβγ</code> can be provided to check for invariance along a symmetry symmetry line/plane/general point in k-space. The reality must be invariant to this choice.</p><p><strong>Note</strong></p><p>The provided space group operations <code>sgops</code> <strong>must</strong> be the set reduced by primitive translation vectors; i.e. using <code>spacegroup(...)</code> directly is <strong>not</strong> allowable in general (since the irreps we reference only include these &quot;reduced&quot; operations). This reduced set of operations can be obtained e.g. from the Γ point irreps of ISOTROPY&#39;s dataset, or alternatively, from <code>reduce_ops(spacegroup(...), true)</code>.</p><p><strong>Implementation</strong></p><p>The Herring criterion evaluates the following sum</p><p><span>$[∑ χ({β|b}²)]/[g_0/M(k)]$</span></p><p>over symmetry operations <span>${β|b}$</span> that take <span>$k → -k$</span>. Here <span>$g_0$</span> is the order of the point group of the space group and <span>$M(k)$</span> is the order of star(<span>$k$</span>) [both in a primitive basis].</p><p>See e.g. Cornwell, p. 150-152 &amp; 187-188 (which we mainly followed), Inui Eq. (13.48),  Dresselhaus, p. 618, or <a href="https://doi.org/10.1103/PhysRev.52.361">Herring&#39;s original paper</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/irreps_reality.jl#L397-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.calc_topology-Tuple{AbstractVector{&lt;:Integer}, Smith}" href="#Crystalline.calc_topology-Tuple{AbstractVector{&lt;:Integer}, Smith}"><code>Crystalline.calc_topology</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_topology(
    n::AbstractVector{&lt;:Integer},
    F::Smith;
    allow_incompatible,
    allow_negative
) -&gt; TopologyKind
</code></pre><p>Return whether a symmetry vector <code>n</code> is a band-combination that is trivial or nontrivial from a symmetry perspective, i.e. whether it has an integer-coefficient expansion in the elementary band representation (EBR) basis or not (i.e. a rational-coefficient expansion). Returns a value from the Enum <a href="#Crystalline.TopologyKind"><code>TopologyKind</code></a> (<code>TRIVIAL</code> or <code>NONTRIVIAL</code>).</p><p>No distinction is made between fragile and trivial symmetry vectors: i.e., a <code>TRIVIAL</code> return value may in fact be a <code>FRAGILE</code> state on more careful inspection: such a distinction can be made by <code>calc_detailed_topology</code> from <a href="https://github.com/thchr/SymmetryBases.jl">SymmetryBases.jl</a></p><p>See also <a href="#Crystalline.symmetry_indicators-Tuple{AbstractVector{&lt;:Integer}, Smith}"><code>symmetry_indicators</code></a> to obtain the associated symmetry indicators of a nontrivial symmetry vector.</p><p><strong>Input</strong></p><p>The EBR basis can be provided as <code>::BandRepSet</code>, <code>::Matrix{&lt;:Integer}</code>, or a <code>Smith</code> decomposition. The length of <code>n</code> must equal the EBR basis&#39; number of irreps or the number of irreps plus 1 (i.e. include the band connectivity).</p><p><strong>Implementation</strong></p><p>We check whether an integer-coefficient expansion exists via the Smith normal decomposition of the EBR matrix <span>$\mathbf{B} = \mathbf{S}\boldsymbol{\Lambda}\mathbf{T}$</span>. If</p><p class="math-container">\[    (\mathbf{S}^{-1}\mathbf{n})_j = 0 \mod \lambda_j\]</p><p>for all <span>$j = 1, \ldots, d^{\text{bs}}$</span> (<span>$d^{\text{bs}}$</span> is the number of non-zero diagonal elements of <span>$\boldsymbol{\Lambda}$</span>, i.e. the invariant factors of <span>$\mathbf{B}$</span>), there exists a solution to <span>$\mathbf{B}\mathbf{c} = \mathbf{n}$</span> with integer coefficients <span>$c_j \in \mathbb{Z}$</span>.</p><p><strong>Keyword arguments</strong></p><p>If <code>n</code> is not a compatible band structure (i.e., if <code>iscompatible(n, [...]) = false</code>), an error is thrown. This behavior can be controlled by two boolean keyword arguments:</p><ul><li><code>allow_incompatible</code> (<code>false</code>): if <code>true</code>, disables the compatibility check entirely.</li><li><code>allow_negative</code> (<code>false</code>): if <code>true</code>, allows negative symmetry content, but maintain requirement that <code>n</code> respects the compatibilty relations in an algebraic sense.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/tqc_analysis.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.characters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D" href="#Crystalline.characters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D"><code>Crystalline.characters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">characters(irs::AbstractVector{&lt;:AbstractIrrep}, αβγ=nothing)</code></pre><p>Compute the character table associated with vector of <code>AbstractIrrep</code>s <code>irs</code>, returning a <code>CharacterTable</code>.</p><p><strong>Optional arguments</strong></p><p>Optionally, an <code>αβγ::AbstractVector{&lt;:Real}</code> variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for <code>LGIrrep</code>s, a concrete <strong>k</strong>-vector sampled from a &quot;line-irrep&quot;). Defaults to <code>nothing</code>, indicating it being either  irrelevant (e.g., for <code>PGIrrep</code>s) or all free parameters implicitly set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L954-L966">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.classcharacters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D" href="#Crystalline.classcharacters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D"><code>Crystalline.classcharacters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classcharacters(irs::AbstractVector{&lt;:AbstractIrrep}, αβγ=nothing)</code></pre><p>Compute the character table associated with the conjugacy classes of a vector of <code>AbstractIrrep</code>s <code>irs</code>, returning a <code>ClassCharacterTable</code>.</p><p>Since characters depend only on the conjugacy class (this is not true for ray, or projective, irreps), the class-specific characters often more succintly communicate the same information as the characters for each operation (as returned by <a href="#Crystalline.characters-Union{Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{&lt;:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{&lt;:Real}}}} where D"><code>characters</code></a>).</p><p>See also: <a href="#Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}, Bool}} where D"><code>classes</code></a>.</p><p><strong>Optional arguments</strong></p><p>Optionally, an <code>αβγ::AbstractVector{&lt;:Real}</code> variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for <code>LGIrrep</code>s, a concrete <strong>k</strong>-vector sampled from a &quot;line-irrep&quot;). Defaults to <code>nothing</code>, indicating it being either  irrelevant (e.g., for <code>PGIrrep</code>s) or all free parameters implicitly set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L987-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}, Bool}} where D" href="#Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}, Bool}} where D"><code>Crystalline.classes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classes(ops::AbstractVector{SymOperation{D}}, [cntr::Union{Char, Nothing}])
                                                --&gt;  Vector{Vector{SymOperation{D}}}</code></pre><p>Return the conjugacy classes of a group <span>$G$</span> defined by symmetry operations <code>ops</code>.</p><p><strong>Definitions</strong></p><p>Two elements <span>$a$</span> and <span>$b$</span> in <span>$G$</span> are considered conjugate if there exists a <span>$g ∈ G$</span> such that <span>$gag^{-1} = b$</span>. This defines an equivalence relation <span>$\sim$</span>, i.e., we say that <span>$a \sim b$</span> if <span>$a$</span> and <span>$b$</span> are conjugate. The conjugacy classes of <span>$G$</span> are the distinct equivalence classes that can be identified under this equivalence relation, i.e. the grouping of <span>$G$</span> into subsets that are equivalent under conjugacy.</p><p><strong>Extended help</strong></p><p>If <code>ops</code> describe operations in a crystal system that is not primitive (i.e., if its <a href="../bravais/#Bravais.centering"><code>centering</code></a> type is not <code>p</code> or <code>P</code>) but is presented in a conventional setting, the centering symbol <code>cntr</code> <em>must</em> be given. If <code>ops</code> is not in a centered crystal system, or if <code>ops</code> is already reduced to a primitive setting, <code>cntr</code> should be given as <code>nothing</code> (default behavior) or, alternatively, as <code>P</code> or <code>p</code> (depending on dimensionality).</p><p>A single-argument calls to <code>classes</code> with <code>SpaceGroup</code> or <code>LittleGroup</code> types will assume that <code>ops</code> is provided in a conventional setting, i.e., will forward the method call to <code>classes(ops, centering(ops, dim(ops)))</code>. To avoid this behavior (if <code>ops</code> was already reduced to a primitive setting prior to calling <code>classes</code>), <code>cntr</code> should be provided explicitly as <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/conjugacy.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.collect_compatible-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}}, Collection{NewBandRep{D}}}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}}, Collection{NewBandRep{D}}, Smith{var&quot;#s37&quot;, Q, V} where {var&quot;#s37&quot;&lt;:Integer, Q&lt;:AbstractMatrix{var&quot;#s37&quot;}, V&lt;:AbstractVector{var&quot;#s37&quot;}}}} where D" href="#Crystalline.collect_compatible-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}}, Collection{NewBandRep{D}}}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}}, Collection{NewBandRep{D}}, Smith{var&quot;#s37&quot;, Q, V} where {var&quot;#s37&quot;&lt;:Integer, Q&lt;:AbstractMatrix{var&quot;#s37&quot;}, V&lt;:AbstractVector{var&quot;#s37&quot;}}}} where D"><code>Crystalline.collect_compatible</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collect_compatible(
    symeigsv::AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}},
    brs::Collection{NewBandRep{D}};
    ...
) -&gt; Array{SymmetryVector{_A}, 1} where _A
collect_compatible(
    symeigsv::AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}},
    brs::Collection{NewBandRep{D}},
    F::Smith{var&quot;#s37&quot;, Q, V} where {var&quot;#s37&quot;&lt;:Integer, Q&lt;:AbstractMatrix{var&quot;#s37&quot;}, V&lt;:AbstractVector{var&quot;#s37&quot;}};
    kws...
) -&gt; Array{SymmetryVector{_A}, 1} where _A
</code></pre><p>Given a vector of symmetry eigenvalue data <code>symeigsv</code> and an associated set of band representations, <code>brs</code>, return a set of bands, as a <code>Vector{SymmetryVector{D}}</code>, each element of which is a minimum-occupation and compatibility-respecting band grouping. The lowest-lying bands are returned first.</p><p><strong>Input arguments</strong></p><ul><li><code>symeigsv</code>: a triply-nested vector of symmetry eigenvalues, with the following indexing convention that <code>symeigsv[kidx][bandidx][opidx]</code> gives the symmetry eigenvalue of the <code>kidx</code>th <strong>k</strong>-point and the <code>bandidx</code>th band, under the action of the <code>opidx</code>th symmetry  operation in the little group of the <code>kidx</code>th <strong>k</strong>-point. The sorting of little group  operations must correspond to those in <code>group(irreps(brs)[kidx])</code>.</li><li><code>brs :: Collection{NewBandRep{D}}</code>: a collection of band representations, iterating a set  of <code>NewBandRep{D}</code> objects, obtained from <a href="#Crystalline.calc_bandreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D"><code>calc_bandreps</code></a>, and is expected to be  provided in <code>primitivized</code> form (see <a href="#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D"><code>primitivize(::Collection{&lt;:NewBandRep})</code></a>).  The little group irreps are implicitly specified via <code>brs</code> as well (via <code>irreps(brs)</code>),  as are the corresponding little groups and their associated operator sorting (via  <code>group.(irreps(brs))</code>). It assumed that the sorting of symmetry eigenvalues in <code>symeigsv</code>  is such that <code>group(irreps(brs)[kidx])[opidx]</code> matches the elements of   <code>symeigsv[kidx][:][opidx]</code>.</li><li><code>F::Smith{&lt;:Integer}</code>: optional argument, corresponding to the Smith normal form of the  band representation matrix <code>stack(brs)</code>. Can be supplied explicitly to avoid repeated  recalculations for repeated calls to this function (see <code>smith</code>).</li></ul><p><strong>Keyword arguments</strong></p><p>Keyword arguments <code>kws</code> are forwarded to <a href="../internal-api/#Crystalline.find_multiplicities-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:Number}}, Collection{LGIrrep{D}}}} where D"><code>find_multiplicities</code></a>, which determines the irrep multiplicities from the symmetry eigenvalues <code>symeigsv</code>.</p><p>For low-resolution calculations (i.e., if <code>symeigsv</code> has appreciable numerical error), it can be worthwhile to increase the absolute tolerance <code>atol</code> (default, 0.02) used by <a href="../internal-api/#Crystalline.find_multiplicities-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:Number}}, Collection{LGIrrep{D}}}} where D"><code>find_multiplicities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symeigs_analysis.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.collect_irrep_annotations-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}}, AbstractArray{Collection{LGIrrep{D}}, 1}}} where D" href="#Crystalline.collect_irrep_annotations-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}}, AbstractArray{Collection{LGIrrep{D}}, 1}}} where D"><code>Crystalline.collect_irrep_annotations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collect_irrep_annotations(
    symeigsv::AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}},
    lgirsv::AbstractArray{Collection{LGIrrep{D}}, 1};
    multiplicity_kws...
) -&gt; Dict
</code></pre><p>Given a list of symmetry eigenvalue listings <code>symeigsv</code> and little group irrep collections <code>lgirsv</code>, indexed over different <strong>k</strong>-points, return a dictionary of formatted irrep annotations, giving the band-indices and associated irrep labels at each <strong>k</strong>-point.</p><p>Indexing into <code>symeigsv</code> is assumed to be such that <code>symeigsv[kidx][bandidx][opidx]</code> returns the symmetry eigenvalue of <code>bandidx</code>th energy band at the <code>kidx</code>th <strong>k</strong>-point for the <code>opidx</code>th little group operation, corresponding to <code>group(lgirsv[kidx])[opidx]</code>.</p><p>See also <a href="#Crystalline.collect_irrep_annotations-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}}, AbstractArray{Collection{LGIrrep{D}}, 1}}} where D"><code>collect_irrep_annotations(symeigs, lgirs)</code></a> for a single <strong>k</strong>-point variant.</p><p>Keyword arguments are passed to <a href="../internal-api/#Crystalline.find_multiplicities-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:Number}}, Collection{LGIrrep{D}}}} where D"><code>Crystalline.find_multiplicities</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symeigs_analysis.jl#L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.collect_irrep_annotations-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:Number}}, Collection{LGIrrep{D}}}} where D" href="#Crystalline.collect_irrep_annotations-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:Number}}, Collection{LGIrrep{D}}}} where D"><code>Crystalline.collect_irrep_annotations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collect_irrep_annotations(
    symeigs::AbstractVector{&lt;:AbstractVector{&lt;:Number}},
    lgirs::Collection{LGIrrep{D}};
    multiplicity_kws...
) -&gt; Vector
</code></pre><p>Given a list of symmetry eigenvalues, <code>symeigs</code> and an associated collection of little group irreps <code>lgirs</code>, return a vector of formatted irrep annotations, each element giving band-indices and associated irrep labels a single band or degenerate set of bands.</p><p>Indexing into <code>symeigs</code> is assumed to be such that <code>symeigs[bandidx][opidx]</code> returns the symmetry eigenvalue of <code>bandidx</code>th energy band and the <code>opidx</code>th little group operation, corresponding to <code>group(lgirs)[opidx]</code>.</p><p>See also <a href="#Crystalline.collect_irrep_annotations-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:AbstractVector{&lt;:Number}}}, AbstractArray{Collection{LGIrrep{D}}, 1}}} where D"><code>collect_irrep_annotations(symeigsv, lgirsv)</code></a> for a multiple <strong>k</strong>-point variant, returning a dictionary of irrep annotations.</p><p><strong>Keyword arguments</strong></p><p>Keyword arguments are passed to <a href="../internal-api/#Crystalline.find_multiplicities-Union{Tuple{D}, Tuple{AbstractVector{&lt;:AbstractVector{&lt;:Number}}, Collection{LGIrrep{D}}}} where D"><code>Crystalline.find_multiplicities</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lgirs = lgirreps(17, Val(2))[&quot;Γ&quot;];
julia&gt; symeigs = [[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
                  [1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0],
                  [2.0, -1.0, -1.0, -2.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]
julia&gt; collect_irrep_annotations(symeigs, lgirs)
3-element Vector{Pair{UnitRange{Int64}, String}}:
 1:1 =&gt; &quot;Γ₁&quot;
 2:2 =&gt; &quot;Γ₄&quot;
 3:3 =&gt; &quot;Γ₆&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symeigs_analysis.jl#L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, KVec{D}}, Tuple{SymOperation{D}, KVec{D}, Bool}} where D" href="#Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, KVec{D}}, Tuple{SymOperation{D}, KVec{D}, Bool}} where D"><code>Crystalline.compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(op::SymOperation, kv::KVec[, checkabc::Bool=true])  --&gt;  KVec</code></pre><p>Return the composition <code>op</code> <span>$= \{\mathbf{W}|\mathbf{w}\}$</span> and a reciprocal-space vector <code>kv</code> <span>$= \mathbf{k}$</span>.</p><p>The operation is assumed to be specified the direct lattice basis, and <code>kv</code> in the reciprocal lattice basis. If both were specified in the Cartesian basis, <code>op</code> would act directly via its rotation part. However, because of the different bases, it now acts as:</p><p class="math-container">\[    \mathbf{k}&#39; = (\mathbf{W}^{\text{T}})^{-1}\mathbf{k}.\]</p><p>Note the transposition <em>and</em> inverse of <span>$\mathbf{W}$</span>, arising as a result of the implicit real-space basis of <span>$\{\mathbf{W}|\mathbf{w}\}$</span> versus the reciprocal-space basis of <span>$\mathbf{k}$</span> and the requirement that  <span>$\mathbf{k} \cdot \mathbf{r} = \mathbf{k}&#39; \cdot \mathbf{r}&#39;$ for rotated (no translation, $\mathbf{w} = \mathbf{0}$) vectors$</span>\mathbf{k}&#39;<span>$and$</span>\mathbf{r}&#39;``.</p><p>Note also that the composition of <span>$\{\mathbf{W}|\mathbf{w}\}$</span> with <span>$\mathbf{k}$</span> is independent of <span>$\mathbf{w}$</span>, i.e., translations do not act in reciprocal space.</p><p><strong>Extended help</strong></p><p>If <code>checkabc = false</code>, the free part of <code>KVec</code> is not transformed (can be improve  performance in situations when <code>kabc</code> is zero, and several transformations are requested).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L567-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, RVec{D}}} where D" href="#Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, RVec{D}}} where D"><code>Crystalline.compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(op::SymOperation, rv::RVec)  --&gt;  RVec</code></pre><p>Return the composition of <code>op</code> <span>$= \{\mathbf{W}|\mathbf{w}\}$</span> and a real-space vector <code>rv</code> <span>$= \mathbf{r}$</span>.</p><p>The operation is taken to act directly, returning</p><p class="math-container">\[    \mathbf{r}&#39; = \{\mathbf{W}|\mathbf{w}\}\mathbf{r} = \mathbf{W}\mathbf{r} + \mathbf{w}.\]</p><p>The corresponding inverse action <span>$\{\mathbf{W}|\mathbf{w}\}^{-1}\mathbf{r} =  \mathbf{W}^{-1}\mathbf{r} - \mathbf{W}^{-1}\mathbf{w}$</span> can be obtained via  <code>compose(inv(op), rv)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L605-L618">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.compose-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Bool}} where T&lt;:SymOperation" href="#Crystalline.compose-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Bool}} where T&lt;:SymOperation"><code>Crystalline.compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(op1::T, op2::T, modτ::Bool=true) where T&lt;:SymOperation</code></pre><p>Compose two symmetry operations <code>op1</code> <span>$= \{W₁|w₁\}$</span> and <code>op2</code> <span>$= \{W₂|w₂\}$</span> using the composition rule (in Seitz notation)</p><p><span>$\{W₁|w₁\}\{W₂|w₂\} = \{W₁W₂|w₁+W₁w₂\}$</span></p><p>By default, the translation part of the <span>$\{W₁W₂|w₁+W₁w₂\}$</span> is reduced to the range <span>$[0,1[$</span>, i.e. computed modulo 1. This can be toggled off (or on) by the Boolean flag <code>modτ</code> (enabled, i.e. <code>true</code>, by default). Returns another <code>SymOperation</code>.</p><p>The multiplication operator <code>*</code> is overloaded for <code>SymOperation</code>s to call <code>compose</code>, in the manner <code>op1 * op2 = compose(op1, op2, modτ=true)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L213-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.conjugacy_relations-Union{Tuple{D}, Tuple{Crystalline.GroupRelationGraph{D}, Integer, Integer}} where D" href="#Crystalline.conjugacy_relations-Union{Tuple{D}, Tuple{Crystalline.GroupRelationGraph{D}, Integer, Integer}} where D"><code>Crystalline.conjugacy_relations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conjugacy_relations(gr::GroupRelationGraph, sgnumᴳ, sgnumᴴ) --&gt; Vector{&lt;:ConjugacyTransform}</code></pre><p>Given a graph <code>gr</code> representing a sub- or supergroup relation, return the possible transformations that make up the conjugacy classes between the groups <code>sgnumᴳ</code> and <code>sgnumᴴ</code>.</p><p>The returned transforms <code>ts</code> bring <code>G</code> into the setting of <code>H</code> via <code>transform.(G, Ref(t.P), Ref(t.p))</code>, where <code>t</code> is an element of <code>ts</code>, i.e., one possible conjugacy transform, and <code>t.P</code> and <code>t.p</code> denote the associated transform&#39;s rotation and translation, respectively. </p><p>Note that the transforms need not preserve volume: accordingly, some operations may be redundant after transformation (use <a href="#Crystalline.reduce_ops-Union{Tuple{Pdim}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Char}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool, Bool}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool, Bool, Val{Pdim}}} where {D, Pdim}"><code>reduce_ops</code></a> or <code>unique!</code> to remove these).</p><p><strong>Example</strong></p><p>Consider the following example, which looks at the subgroup relationship between space groups ⋕168 and ⋕3:</p><pre><code class="language-julia-repl hljs">julia&gt; gr = maximal_subgroups(168)
GroupRelationGraph (subgroups) of SpaceGroup{3} ⋕168 with 4 vertices:
 ⋕168
 ├─►⋕143ᵀ (index 2)  ╌╌►⋕1ᵀ (index 3)
 └─►⋕3ᵀ (index 3)  ╌╌►⋕1ᵀ (index 2)

julia&gt; sg168 = spacegroup(168)
SpaceGroup{3} ⋕168 (P6) with 6 operations:
 1
 3₀₀₁⁺
 3₀₀₁⁻
 2₀₀₁
 6₀₀₁⁻
 6₀₀₁⁺

julia&gt; sg3 = spacegroup(3)
SpaceGroup{3} ⋕3 (P2) with 2 operations:
 1
 2₀₁₀</code></pre><p>Note that the symmetry operation 2₀₁₀ (from ⋕3) and 2₀₀₁ (from ⋕168) differ by a transformation; even though they are isomorphic, this is not clearly reflected because they are in different settings. We can use <code>conjugacy_relations</code> to find the transformations that brings ⋕168 into the setting of ⋕3:</p><pre><code class="language-julia-repl hljs">julia&gt; ts = conjugacy_relations(gr, 168, 3) # possible transforms from ⋕168 to ⋕3
1-element Vector{Crystalline.ConjugacyTransform{3}}:
 P = [0 0 1; 1 0 0; 0 1 0]

julia&gt; sg168′ = transform.(sg168, Ref(ts[1].P), Ref(ts[1].p))
6-element Vector{SymOperation{3}}:
 1
 3₀₁₀⁺
 3₀₁₀⁻
 2₀₁₀
 6₀₁₀⁻
 6₀₁₀⁺

julia&gt; issubgroup(sg168, sg3) # not identified as subgroup, since settings differ
false

julia&gt; issubgroup(sg168′, sg3) # settings now agree, and subgroup relationship is evident
true</code></pre><p>Here, there is only one possible transformation: in general, however, there may be many.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/grouprelations/grouprelations.jl#L104-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.cosets-Tuple{SiteGroup}" href="#Crystalline.cosets-Tuple{SiteGroup}"><code>Crystalline.cosets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cosets(g::SiteGroup) -&gt; Array{SymOperation{D}, 1} where D
</code></pre><p>Return the left coset representatives of a <code>SiteGroup</code> <code>g</code> (in its parent space group).</p><p>The cosets generate the orbit of the Wyckoff position <a href="#Base.position-Tuple{Crystalline.AbstractGroup}"><code>position(g)</code></a> (see also <a href="#Crystalline.orbit-Tuple{SiteGroup}"><code>orbit(::SiteGroup)</code></a>) and furnish a left-coset decomposition of the underlying space group, jointly with the operations in <code>g</code> itself.</p><p>See also <a href="#Crystalline.cosets-Tuple{SiteGroup}"><code>cosets(::AbstractVector, ::AbstractVector)</code></a>. This method is equivalent (but may return different representatives in general) to <code>cosets(spacegroup(sgnum), g)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L656">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.cosets-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Crystalline.AbstractOperation" href="#Crystalline.cosets-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Crystalline.AbstractOperation"><code>Crystalline.cosets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cosets(G, H)</code></pre><p>For a subgroup <code>H</code> <span>$=H$</span> of <code>G</code> = <span>$G$</span>, find a set of (left) coset representatives  <span>$\{g_i\}$</span> of <span>$H$</span> in <span>$G$</span>, such that (see e.g., Inui et al., Section 2.7)</p><p class="math-container">\[    G = \bigcup_i g_i H.\]</p><p>The identity operation <span>$1$</span> is always included in <span>$\{g_i\}$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = pointgroup(&quot;6mm&quot;);

julia&gt; H = pointgroup(&quot;3&quot;);

julia&gt; Q = cosets(G, H)
4-element Vector{SymOperation{3}}:
 1
 2₀₀₁
 m₁₁₀
 m₁₋₁₀</code></pre><p>To generate the associated cosets, simply compose the representatives with <code>H</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; [compose.(Ref(q), H) for q in Q]
4-element Vector{Vector{SymOperation{3}}}:
 [1, 3₀₀₁⁺, 3₀₀₁⁻]
 [2₀₀₁, 6₀₀₁⁻, 6₀₀₁⁺]
 [m₁₁₀, m₁₀₀, m₀₁₀]
 [m₁₋₁₀, m₁₂₀, m₂₁₀]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L510-L542">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.dim-Tuple{BandRep}" href="#Crystalline.dim-Tuple{BandRep}"><code>Crystalline.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(BR::BandRep) --&gt; Int</code></pre><p>Return the number of bands included in the provided <code>BandRep</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L1044-L1048">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.dim-Union{Tuple{Crystalline.AbstractGroup{D}}, Tuple{D}} where D" href="#Crystalline.dim-Union{Tuple{Crystalline.AbstractGroup{D}}, Tuple{D}} where D"><code>Crystalline.dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dim(g::AbstractGroup) -&gt; Int</code></pre><p>Return the dimensionality of the coordinate space of the group <code>g</code>. This is a statically known number, either equaling 1, 2, or 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L557-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.filling2isoval-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Real}, Tuple{Crystalline.AbstractFourierLattice{D}, Real, Integer}} where D" href="#Crystalline.filling2isoval-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Real}, Tuple{Crystalline.AbstractFourierLattice{D}, Real, Integer}} where D"><code>Crystalline.filling2isoval</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filling2isoval(
    flat::Crystalline.AbstractFourierLattice{D}
) -&gt; Any
filling2isoval(
    flat::Crystalline.AbstractFourierLattice{D},
    filling::Real
) -&gt; Any
filling2isoval(
    flat::Crystalline.AbstractFourierLattice{D},
    filling::Real,
    nsamples::Integer
) -&gt; Any
</code></pre><p>Return the isovalue of <code>flat</code> such that the interior of the thusly defined levelset isosurface encloses a fraction <code>filling</code> of the unit cell.</p><p>The keyword argument <code>nsamples</code> specifies the grid-resolution used in evaluating this answer (via Statistics.jl&#39;s <code>quantile</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L501-L509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.find_isomorphic_parent_pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D" href="#Crystalline.find_isomorphic_parent_pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>Crystalline.find_isomorphic_parent_pointgroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_isomorphic_parent_pointgroup(g::AbstractVector{SymOperation{D}}) 
                                                --&gt; PointGroup{D}, Vector{Int}, Bool</code></pre><p>Given a group <code>g</code> (or a collection of operators, defining a group), identifies a &quot;parent&quot; point group that is isomorphic to <code>g</code>.</p><p>Three variables are returned:</p><ul><li><code>pg</code>: the identified &quot;parent&quot; point group, with operators sorted to match the sorting of <code>g</code>&#39;s operators.</li><li><code>Iᵖ²ᵍ</code>: a permutation vector which transforms the standard sorting of point group operations (as returned by <a href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>pointgroup(::String)</code></a>) to the operator sorting of <code>g</code>.</li><li><code>equal</code>: a boolean, identifying whether the point group parts of <code>g</code> operations are identical (<code>true</code>) or merely isomorphic to the point group operations in <code>g</code>. In practice, this indicates whether <code>pg</code> and <code>g</code> are in the same setting or not.</li></ul><p><strong>Implementation</strong></p><p>The identification is made partly on the basis of comparison of operators (this is is sufficient for the <code>equal = true</code> case) and partly on the basis of comparison of  multiplication tables (<code>equal = false</code> case); the latter can be combinatorially slow if the sorting of operators is unlucky (i.e., if permutation between sortings in <code>g</code> and <code>pg</code> differ by many pairwise permutations).</p><p>Beyond mere isomorphisms of multiplication tables, the search also guarantees that all rotation orders are shared between <code>pg</code> and <code>g</code>; similarly, the rotation senses (e.g., 4⁺ &amp; 4⁻ have opposite rotation senses or directions) are shared. This disambiguates point groups  that are intrinsically isomorphic to eachother, e.g. &quot;m&quot; and &quot;-1&quot;, but which still differ in their spatial interpretation.</p><p><strong>Properties</strong></p><p>The following properties hold for <code>g</code>, <code>pg</code>, and <code>Iᵖ²ᵍ</code>:</p><pre><code class="language-jl hljs">pg, Iᵖ²ᵍ, equal = find_isomorphic_parent_pointgroup(g)
@assert MultTable(pg) == MultTable(pointgroup(g))
pg′ = pointgroup(label(pg), dim(pg)) # &quot;standard&quot; sorting
@assert pg′[Iᵖ²ᵍ] == pg</code></pre><p>If <code>equal = true</code>, the following also holds:</p><pre><code class="language-jl hljs">pointgroup(g) == operations(pg) == operations(pg′)[Iᵖ²ᵍ]</code></pre><p><strong>Example</strong></p><pre><code class="language-jl hljs">sgnum = 141
wp    = wyckoffs(sgnum, Val(3))[end] # 4a Wyckoff position
sg    = spacegroup(sgnum, Val(3))
siteg = sitegroup(sg, wp)
pg, Iᵖ²ᵍ, equal = find_isomorphic_parent_pointgroup(siteg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/pointgroup.jl#L206-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.find_representation" href="#Crystalline.find_representation"><code>Crystalline.find_representation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_representation(
    symeigs::AbstractVector{&lt;:AbstractVector{&lt;:Number}},
    irs::AbstractVector{&lt;:Crystalline.AbstractIrrep};
    ...
) -&gt; Any
find_representation(
    symeigs::AbstractVector{&lt;:AbstractVector{&lt;:Number}},
    irs::AbstractVector{&lt;:Crystalline.AbstractIrrep},
    bands::AbstractVector{Int64};
    ...
) -&gt; Any
find_representation(
    symeigs::AbstractVector{&lt;:AbstractVector{&lt;:Number}},
    irs::AbstractVector{&lt;:Crystalline.AbstractIrrep},
    bands::AbstractVector{Int64},
    assert_return_T::Type{&lt;:Union{AbstractFloat, Integer}};
    kws...
) -&gt; Any
</code></pre><p>Given a set of <em>band</em>-resolved symmetry eigenvalues <code>symeigs</code>, a set of irreps <code>irs</code>, and a selection of band indices <code>bands</code> into <code>symeigs</code>, return the associated multiplicities of corresponding to <code>irs</code>.</p><p>The <code>symeigs</code> argument is a vector of symmetry eigenvalues, or symmetry characters, for individual bands. The <code>symeigs[n][i]</code>th entry gives the symmetry eigenvalue <span>$x_n(g_i)$</span> of the <code>n</code>th band and the <span>$g_i =$</span> <code>group(irs)[i]</code> symmetry operation, with:</p><pre><code class="language-julia hljs">```math
x_n(g_i) = \langle \psi_n | g_i | \psi_n \rangle
```</code></pre><p>If unset, <code>bands</code> contains all bands in <code>symeigs</code>, i.e., is equal to <code>eachindex(symeigs)</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>kws</code>: Additional keyword arguments passed to <a href="#Crystalline.find_representation"><code>find_representation(::AbstractVector{&lt;:Number})</code></a> (e.g., <code>αβγ</code>, <code>atol</code>, <code>maxresnorm</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symeigs2irrep.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.find_representation" href="#Crystalline.find_representation"><code>Crystalline.find_representation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_representation(
    symvals::AbstractVector{&lt;:Number}, 
    lgirs::AbstractVector{&lt;:AbstractIrrep},
    assert_return_T::Type{&lt;:Union{Integer, AbstractFloat}}=Int);
    αβγ::Union{AbstractVector{&lt;:Real},Nothing}=nothing,
    atol::Real=DEFAULT_ATOL,
    maxresnorm::Real=1e-3,
    verbose::Bool=false
)                                          --&gt; Union{Nothing, Vector{assert_return_T}}</code></pre><p>From a vector (or vector of vectors) of symmetry eigenvalues <code>symvals</code> sampled along all the operations of a group gᵢ, whose irreps are contained in <code>irs</code> (evaluated with optional free  parameters <code>αβγ</code>), return the multiplicities of each irrep.</p><p>Optionally, the multiciplities&#39; element type can be specified via the <code>assert_return_T</code> argument (performing checked conversion; returns <code>nothing</code> if representation in  <code>assert_return_T</code> is impossible). This can be useful if one suspects a particular band to  transform like a fraction of an irrep (i.e., the specified symmetry data is incomplete).</p><p>If no valid set of multiplicities exist (i.e., is solvable, and has real-valued and <code>assert_return_T</code> representible type), the sentinel value <code>nothing</code> is returned. Optional debugging information can in this case be shown by setting <code>verbose=true</code>.</p><p><strong>Extended help</strong></p><p>Effectively, this applies the projection operator P⁽ʲ⁾ of each irrep&#39;s character set χ⁽ʲ⁾(gᵢ) (j = 1, ... , Nⁱʳʳ) to the symmetry data sᵢ ≡ <code>symvals</code>:</p><pre><code class="language-julia hljs">P⁽ʲ⁾  ≡ (dⱼ/|g|) ∑ᵢ χ⁽ʲ⁾(gᵢ)*gᵢ         [characters χ⁽ʲ⁾(gᵢ), irrep dimension dⱼ]
P⁽ʲ⁾s = (dⱼ/|g|) ∑ᵢ χ⁽ʲ⁾(gᵢ)*sᵢ = nⱼ,   [number of bands that transform like jth irrep]</code></pre><p>returning the irrep multiplicities mⱼ ≡ nⱼ/dⱼ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symeigs2irrep.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.findmaximal-Union{Tuple{AbstractArray{SiteGroup{D}, 1}}, Tuple{D}} where D" href="#Crystalline.findmaximal-Union{Tuple{AbstractArray{SiteGroup{D}, 1}}, Tuple{D}} where D"><code>Crystalline.findmaximal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findmaximal(sitegs::AbstractVector{&lt;:SiteGroup})</code></pre><p>Given an <code>AbstractVector{&lt;:SiteGroup}</code> over the distinct Wyckoff positions of a space group, return those <code>SiteGroup</code>s that are associated with a maximal Wyckoff positions.</p><p>Results are returned as a <code>view</code> into the input vector (i.e. as an  <code>AbstractVector{&lt;:SiteGroup}</code>). The associated Wyckoff positions can be retrieved via <a href="#Base.position-Tuple{Crystalline.AbstractGroup}"><code>position</code></a>.</p><p><strong>Definition</strong></p><p>A Wyckoff position is maximal if its site symmetry group has higher order than the site symmetry groups of any &quot;nearby&quot; Wyckoff positions (i.e. Wyckoff positions that can be  connected, i.e. made equivalent, through parameter variation to the considered Wyckoff position).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 5;

julia&gt; D = 2;

julia&gt; sg  = spacegroup(sgnum, Val(D));

julia&gt; sitegs = sitegroups(sg)
2-element Vector{SiteGroup{2}}:
 [1] (4b: [α, β])
 [1, m₁₀] (2a: [0, β])

julia&gt; only(findmaximal(sitegs))
SiteGroup{2} ⋕5 (c1m1) at 2a = [0, β] with 2 operations:
 1
 m₁₀</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/wyckoff.jl#L228-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D" href="#Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>Crystalline.generate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate(
    gens::AbstractArray{SymOperation{D}, 1};
    cntr,
    modτ,
    Nmax
) -&gt; Crystalline.GenericGroup
</code></pre><p>Return the group generated from a finite set of generators <code>gens</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>cntr</code> (default, <code>nothing</code>): check equivalence of operations modulo primitive lattice vectors (see also <code>isapprox(::SymOperation, ::SymOperation, cntr::Union{Nothing, Char})</code>;  only nonequivalent operations are included in the returned group.</li><li><code>modτ</code> (default, <code>true</code>): the group composition operation can either be taken modulo lattice vectors (<code>true</code>) or not (<code>false</code>, useful e.g. for site symmetry groups). In this case, the provided generators will also be taken modulo integer lattice translations.</li><li><code>Nmax</code> (default, <code>256</code>): the maximum size of the generated group. This is essentially a cutoff set to ensure halting of execution in case the provided set of generators do not define a <em>finite</em> group (especially relevant if <code>modτ=false</code>). If more operations than <code>Nmax</code> are generated, the method throws an overflow error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L1011">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.generators-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D" href="#Crystalline.generators-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D"><code>Crystalline.generators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generators(num::Integer, T::Type{AbstractGroup{D}}[, optargs])
generators(pgiuc::String, T::PointGroup{D}})              --&gt;  Vector{SymOperation{D}}</code></pre><p>Return the generators of the group type <code>T</code> which may be a <code>SpaceGroup{D}</code> or a  <code>PointGroup{D}</code> parameterized by its dimensionality <code>D</code>. Depending on <code>T</code>, the group is determined by inputting as the first argument:</p><ul><li><code>SpaceGroup{D}</code>: the space group number <code>num::Integer</code>.</li><li><code>PointGroup{D}</code>: the point group IUC label <code>pgiuc::String</code> (see also [<code>pointgroup(::String)</code>) or the canonical point group number <code>num::Integer</code>, which can optionally be supplemented by an integer-valued setting choice <code>setting::Integer</code> (see also <a href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>pointgroup(::Integer, ::Integer, ::Integer)</code></a>]).</li><li><code>SubperiodicGroup{D}</code>: the subperiodic group number <code>num::Integer</code>.</li></ul><p>Setting choices match those in <a href="#Crystalline.spacegroup-Union{Tuple{Any}, Tuple{D}, Tuple{Any, Val{D}}} where D"><code>spacegroup</code></a>, <a href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>pointgroup</code></a>, and <a href="#Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}"><code>subperiodicgroup</code></a>.</p><p>Iterated composition of the returned symmetry operations will generate all operations of the associated space or point group (see <a href="#Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>generate</code></a>). As an example, <code>generate(generators(num,</code>SpaceGroup{D}))<code>and</code>spacegroup(num, D)` return identical operations (with different sorting typically); and similarly so for point and subperiodic groups.</p><p><strong>Example</strong></p><p>Generators of space group 200:</p><pre><code class="language-julia-repl hljs">julia&gt; generators(200, SpaceGroup{3})
4-element Vector{SymOperation{3}}:
 2₀₀₁
 2₀₁₀
 3₁₁₁⁺
 -1</code></pre><p>Generators of point group m-3m:</p><pre><code class="language-julia-repl hljs">julia&gt; generators(&quot;2/m&quot;, PointGroup{3})
2-element Vector{SymOperation{3}}:
 2₀₁₀
 -1</code></pre><p>Generators of the Frieze group 𝓅2mg:</p><pre><code class="language-julia-repl hljs">julia&gt; generators(7, SubperiodicGroup{2, 1})
2-element Vector{SymOperation{2}}:
 2
 {m₁₀|½,0}</code></pre><p><strong>Citing</strong></p><p>Please cite the original data sources if used in published work:</p><ul><li>Space groups: <a href="https://doi.org/10.1524/zkri.2006.221.1.15">Aroyo et al., Z. Kristallogr. Cryst. Mater. <strong>221</strong>, 15 (2006)</a>;</li><li>Point group: Bilbao Crystallographic Server&#39;s <a href="https://www.cryst.ehu.es/cryst/get_point_genpos.html">2D and 3D GENPOS</a>;</li><li>Subperiodic groups: Bilbao Crystallographic Server&#39;s <a href="https://www.cryst.ehu.es/subperiodic/get_sub_gen.html">SUBPERIODIC GENPOS</a>.</li></ul><p><strong>Extended help</strong></p><p>Note that the returned generators are not guaranteed to be the smallest possible set of generators; i.e., there may exist other generators with fewer elements (an example is space group 168 (P6), for which the returned generators are <code>[2₀₀₁, 3₀₀₁⁺]</code> even though the group could be generated by just <code>[6₀₀₁⁺]</code>). The returned generators, additionally, are not guaranteed to be <a href="https://en.wikipedia.org/wiki/Generating_set_of_a_module">minimal</a>, i.e., they may include proper subsets that generate the group themselves (e.g., in space group 75 (P4), the returned generators are <code>[2₀₀₁, 4₀₀₁⁺]</code> although the subset <code>[4₀₀₁⁺]</code> is sufficient to generate the group). The motivation for this is to expose as similar generators as possible for similar crystal systems (see e.g. Section 8.3.5 of the International Tables of Crystallography, Vol. A, Ed. 5 (ITA) for further background).</p><p>Note also that, contrary to conventions in ITA, the identity operation is excluded among the returned generators (except in space group 1) since it composes trivially and adds no additional context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/assembly/generators/spacegroup.jl#L1-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.generators-Union{Tuple{P}, Tuple{D}, Tuple{Integer, Type{SubperiodicGroup{D, P}}}} where {D, P}" href="#Crystalline.generators-Union{Tuple{P}, Tuple{D}, Tuple{Integer, Type{SubperiodicGroup{D, P}}}} where {D, P}"><code>Crystalline.generators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generators(num::Integer, ::Type{SubperiodicGroup{D,P}})  --&gt;  ::Vector{SymOperation{D}}</code></pre><p>Return a canonical set of generators for the subperiodic group <code>num</code> of embedding dimension <code>D</code> and periodicity dimension <code>P</code>. See also <a href="#Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}"><code>subperiodicgroup</code></a>.</p><p>See also <a href="#Crystalline.generators-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D"><code>generators(::Integer, ::Type{SpaceGroup})</code></a> and information therein.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; generators(7, SubperiodicGroup{2, 1})
2-element Vector{SymOperation{2}}:
 2
 {m₁₀|½,0}</code></pre><p><strong>Data sources</strong></p><p>The generators returned by this function were originally retrieved from the <a href="https://www.cryst.ehu.es/subperiodic/get_sub_gen.html">Bilbao Crystallographic Database, SUBPERIODIC GENPOS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/assembly/generators/subperiodicgroup.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.indicator_group-Tuple{Smith}" href="#Crystalline.indicator_group-Tuple{Smith}"><code>Crystalline.indicator_group</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indicator_group(F::Smith) -&gt; Any
</code></pre><p>Return the symmetry indicator group <span>$X^{\text{BS}}$</span> associated with an input set of band representations <code>brs</code> (or Smith decomposition thereof, <code>F</code>), i.e., return the the nontrivial (i.e., ≠ {0,1}) elementary factors of the Smith normal form of the band representation matrix. The return value is a <code>Vector{Int}</code> containing the nontrivial factors. If no nontrivial factors exists, the return value is an empty <code>Vector{Int}</code>.</p><p>See also <a href="#Crystalline.indicator_group_as_string-Tuple{AbstractVector{&lt;:Integer}}"><code>indicator_group_as_string</code></a> for a formatted string version.</p><p><strong>Understanding</strong></p><p>The symmetry indicator group answers the question &quot;what direct product of <span>$\mathbb{Z}_n$</span> groups is the the quotient group <span>$X^{\text{BS}} = \{\text{BS}\}/\{\text{AI}\}$</span> isomorphic to?&quot; (see e.g., <a href="https://doi.org/10.1038/s41467-017-00133-2">Po, Watanabe, &amp; Vishwanath, Nature Commun. <strong>8</strong>, 50 (2017)</a> for more information).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; brs = calc_bandreps(2, Val(3));

julia&gt; indicator_group(brs)
4-element Vector{Int64}:
 2
 2
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/tqc_analysis.jl#L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.indicator_group_as_string-Tuple{AbstractVector{&lt;:Integer}}" href="#Crystalline.indicator_group_as_string-Tuple{AbstractVector{&lt;:Integer}}"><code>Crystalline.indicator_group_as_string</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indicator_group_as_string(
    nontriv_Λ::AbstractVector{&lt;:Integer}
)
</code></pre><p>Return the symmetry indicator group <span>$X^{\text{BS}}$</span> as a formatted string (i.e.,  as <code>&quot;Zᵢ×Zⱼ×…&quot;</code>). See also <a href="#Crystalline.indicator_group-Tuple{Smith}"><code>indicator_group</code></a> for a vector representation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; brs = calc_bandreps(2, Val(3));

julia&gt; indicator_group_as_string(brs)
&quot;Z₂×Z₂×Z₂×Z₄&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/tqc_analysis.jl#L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.irdim-Tuple{Crystalline.AbstractIrrep}" href="#Crystalline.irdim-Tuple{Crystalline.AbstractIrrep}"><code>Crystalline.irdim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">irdim(ir::AbstractIrrep) --&gt; Int</code></pre><p>Return the irrep dimension of the irrep <code>ir</code>. This is generally the size of the associated matrix, or, equivalently, the trace of the representation of the identity matrix in <code>ir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L737-L742">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.irreps-Tuple{Crystalline.AbstractSymmetryVector}" href="#Crystalline.irreps-Tuple{Crystalline.AbstractSymmetryVector}"><code>Crystalline.irreps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">irreps(n::AbstractSymmetryVector{D}) -&gt; AbstractVector{&lt;:Collection{&lt;:AbstractIrrep{D}}}</code></pre><p>Return the irreps referenced by <code>n</code>. </p><p>The returned value is an <code>AbstractVector</code> of <code>Collection{&lt;:AbstractIrrep}</code>s, with irreps for distinct groups, usually associated with specific <strong>k</strong>-manifolds, belonging to the same <code>Collection</code>.</p><p>See also <a href="#Crystalline.multiplicities-Tuple{Crystalline.AbstractSymmetryVector}"><code>multiplicities(::AbstractSymmetryVector)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L294-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.is_abelian-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D" href="#Crystalline.is_abelian-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D"><code>Crystalline.is_abelian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_abelian(ops::AbstractVector{SymOperation}, [cntr::Union{Char, Nothing}])  --&gt;  Bool</code></pre><p>Return the whether the group composed of the elements <code>ops</code> is Abelian.</p><p>A group <span>$G$</span> is Abelian if all its elements commute mutually, i.e., if <span>$g = hgh^{-1}$</span> for all <span>$g,h ∈ G$</span>.</p><p>See discussion of the setting argument <code>cntr</code> in <a href="#Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}, Bool}} where D"><code>classes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/conjugacy.jl#L101-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.iscompatible-Tuple{AbstractVector{&lt;:Integer}, Smith}" href="#Crystalline.iscompatible-Tuple{AbstractVector{&lt;:Integer}, Smith}"><code>Crystalline.iscompatible</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iscompatible(
    n::AbstractVector{&lt;:Integer},
    F::Smith;
    allow_negative
) -&gt; Any
</code></pre><p>Test whether a symmetry vector <code>n</code> is a valid band grouping, i.e. whether it fulfils all compatibility relations in the Brillouin zone and is non-negative. That is, test whether <code>n</code> belong to the set of physical band structures {BS}.</p><p>The test compares the symmetry vector <code>n</code> to an set of elementary band representations, provided either as a <code>BandRepSet</code>, a <code>Collection{&lt;:NewBandRep}</code>, a <code>Matrix{&lt;:Integer}</code>, or a <code>Smith</code> decomposition. The irrep sorting of <code>n</code> and this set of EBRs must be identical.</p><p><strong>Keyword arguments</strong></p><ul><li><code>allow_negative</code> (<code>false</code>): if <code>true</code>, allows negative symmetry content. This can be relevant if <code>n</code> contains negative content that may nevertheless respect the compatibility relations in a strictly algebraic sense.</li></ul><p><strong>Implementation</strong></p><p>Belonging to {BS} is tested by comparing to a set of elementary band representations (EBRs). A symmetry vector <span>$\mathbf{n}$</span> is in {BS} if</p><p class="math-container">\[    \tilde{\mathbf{S}}\tilde{\mathbf{S}}^{-1}\mathbf{n} = \mathbf{n}\]</p><p>where <span>$\tilde{\mathbf{S}}$</span> (<span>$\tilde{\mathbf{S}}^{-1}$</span>) denotes the nonsingular columns (rows) of <span>$\mathbf{S}$</span> (<span>$\mathbf{S}^{-1}$</span>) in the Smith normal decomposition of the EBR matrix <span>$\mathbf{A} = \mathbf{S}\boldsymbol{\Lambda}\mathbf{T}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; brs = calc_bandreps(22, Val(3)); # from Crystalline.jl
julia&gt; n = parse(SymmetryVector, &quot;Z₃, T₃, L₁, Y₃, Γ₃&quot;, irreps(brs)) # a compatible vector

# test a compatible symmetry vector
julia&gt; iscompatible(n, brs)
true

# test an invalid symmetry vector
julia&gt; n′ = copy(n);
julia&gt; multiplicities(n′)[1] .= [1,0,0,0]  # change Z₃ to Z₁; incompatible modification
julia&gt; iscompatible(n′, brs)
false

# test a symmetry vector with negative content
julia&gt; n′′ = brs[1] + brs[2] - brs[3];  # contains negative elements
julia&gt; iscompatible(n′′, brs)
false
julia&gt; iscompatible(n′′, brs; allow_negative=true)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/tqc_analysis.jl#L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.isnormal-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D" href="#Crystalline.isnormal-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D"><code>Crystalline.isnormal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isnormal(opsᴳ::AbstractVector{&lt;:SymOperation},
         opsᴴ::AbstractVector{&lt;:SymOperation};
         verbose::Bool=false)                    --&gt; Bool</code></pre><p>Determine whether the operations in group <span>$H$</span> are normal in the group <span>$G$</span> (each with  operations <code>opsᴳ</code> and <code>opsᴴ</code>), in the sense that </p><p class="math-container">\[ghg⁻¹ ∈ H, ∀ g∈G, ∀ h∈H\]</p><p>Returns a Boolean answer (<code>true</code> if normal, <code>false</code> if not).</p><p><strong>Note</strong></p><p>This compares space groups rather than space group types, i.e. the comparison assumes a matching setting choice between <span>$H$</span> and <span>$G$</span>. To compare space group types with different conventional settings, they must first be transformed to a shared setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L969-L987">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.isoval2filling-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Real}, Tuple{Crystalline.AbstractFourierLattice{D}, Real, Integer}} where D" href="#Crystalline.isoval2filling-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Real}, Tuple{Crystalline.AbstractFourierLattice{D}, Real, Integer}} where D"><code>Crystalline.isoval2filling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isoval2filling(
    flat::Crystalline.AbstractFourierLattice{D},
    isoval::Real
) -&gt; Any
isoval2filling(
    flat::Crystalline.AbstractFourierLattice{D},
    isoval::Real,
    nsamples::Integer
) -&gt; Any
</code></pre><p>Return the filling fraction of the interior of the isosurface defined by <code>flat</code> for an isovalue <code>isoval</code>.</p><p>The keyword argument <code>nsamples</code> specifies the grid-resolution used in evaluating this answer (using staircase integration).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L519-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.israyrep" href="#Crystalline.israyrep"><code>Crystalline.israyrep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">israyrep(lgir::LGIrrep, αβγ=nothing) -&gt; (::Bool, ::Matrix)</code></pre><p>Computes whether a given little group irrep <code>ir</code> is a ray representation  by computing the coefficients αᵢⱼ in DᵢDⱼ=αᵢⱼDₖ; if any αᵢⱼ differ  from unity, we consider the little group irrep a ray representation (as opposed to the simpler &quot;vector&quot; representations where DᵢDⱼ=Dₖ). The function returns a boolean (true =&gt; ray representation) and the coefficient matrix αᵢⱼ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/littlegroup_irreps.jl#L185-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.issubgroup-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D" href="#Crystalline.issubgroup-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D"><code>Crystalline.issubgroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issubgroup(opsᴳ::T, opsᴴ::T′) where T⁽′⁾&lt;:AbstractVector{SymOperation} --&gt; Bool</code></pre><p>Determine whether the operations in group <span>$H$</span> are a subgroup of the group <span>$G$</span> (each with  operations <code>opsᴳ</code> and <code>opsᴴ</code>, respectively), i.e. whether <span>$H&lt;G$</span>. Specifically, this requires that <span>$G$</span> and <span>$H$</span> are both groups and that for every <span>$h∈H$</span> there exists an element <span>$g∈G$</span> such that <span>$h=g$</span>.</p><p>Returns a Boolean answer (<code>true</code> if normal, <code>false</code> if not).</p><p><strong>Note</strong></p><p>This compares space groups rather than space group types, i.e. the comparison assumes a matching setting choice between <span>$H$</span> and <span>$G$</span>. To compare space group types with different conventional settings, they must first be transformed to a shared setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L923-L937">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.issymmorph" href="#Crystalline.issymmorph"><code>Crystalline.issymmorph</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issymmorph(sgnum::Integer, D::Integer=3) --&gt; Bool</code></pre><p>Return whether the space group with number <code>sgnum</code> and dimensionality <code>D</code> is symmorphic  (<code>true</code>) or nonsymmorphic (<code>false</code>).</p><p>Equivalent to <code>issymmorph(spacegroup(sgnum, D))</code> but uses memoization for performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L162-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.issymmorph-Tuple{Crystalline.AbstractGroup}" href="#Crystalline.issymmorph-Tuple{Crystalline.AbstractGroup}"><code>Crystalline.issymmorph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issymmorph(sg::Union{SpaceGroup, LittleGroup}) --&gt; Bool</code></pre><p>Return whether a given space group <code>sg</code> is symmorphic (<code>true</code>) or nonsymmorphic (<code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.issymmorph-Union{Tuple{D}, Tuple{SymOperation{D}, Char}} where D" href="#Crystalline.issymmorph-Union{Tuple{D}, Tuple{SymOperation{D}, Char}} where D"><code>Crystalline.issymmorph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issymmorph(op::SymOperation, cntr::Char) --&gt; Bool</code></pre><p>Return whether a given symmetry operation <code>op</code> is symmorphic (<code>true</code>) or nonsymmorphic (<code>false</code>). </p><p>The operation is assumed provided in conventional basis with centering type <code>cntr</code>:  checking symmorphism is then equivalent to checking whether the operation&#39;s translation part is zero or a lattice vector in the associated primitive basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L136-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.iuc" href="#Crystalline.iuc"><code>Crystalline.iuc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iuc(sgnum::Integer, D::Integer=3) --&gt; String</code></pre><p>Return the IUC (International Union of Crystallography) notation for space group number <code>sgnum</code> in dimension <code>D</code> (1, 2, or 3), as used in the International Tables of Crystallography.</p><p>The notation is sometimes also known as the <a href="https://en.wikipedia.org/wiki/Hermann–Mauguin_notation">Hermann-Mauguin notation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/notation.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.klabel" href="#Crystalline.klabel"><code>Crystalline.klabel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">klabel(irlab::AbstractString[, return_as_substring=Val(false)]) --&gt; String or SubString</code></pre><p>Return the <strong>k</strong>-label associated with an irrep label <code>irlab</code> (e.g., <code>&quot;X₃&quot;</code> → <code>&quot;X&quot;</code>, <code>&quot;KA₃⁺&quot;</code> → <code>&quot;KA&quot;</code>, or <code>&quot;Γ′₁⁺&quot;</code> → <code>&quot;Γ′&quot;</code>).</p><p>If optional argument <code>return_as_substring</code> is set to <code>Val(true)</code>, the returned value is a view (<code>SubString</code>) into the original string <code>irlab</code>. Otherwise a new <code>String</code> is allocated and returned (default behavior).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L754-L763">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.levelsetlattice-Union{Tuple{Integer}, Tuple{D′}, Tuple{Integer, Integer}, Tuple{Integer, Integer, NTuple{D′, Int64}}} where D′" href="#Crystalline.levelsetlattice-Union{Tuple{Integer}, Tuple{D′}, Tuple{Integer, Integer}, Tuple{Integer, Integer, NTuple{D′, Int64}}} where D′"><code>Crystalline.levelsetlattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">levelsetlattice(sgnum::Integer, D::Integer=2, idxmax::NTuple=ntuple(i-&gt;2,D))
    --&gt; UnityFourierLattice{D}</code></pre><p>Compute a &quot;neutral&quot;/uninitialized Fourier lattice basis, a <a href="../internal-api/#Crystalline.UnityFourierLattice"><code>UnityFourierLattice</code></a>, consistent with the symmetries of the space group <code>sgnum</code> in dimension <code>D</code>.  The resulting lattice <code>flat</code> is expanded in a Fourier basis split into symmetry-derived orbits, with intra-orbit coefficients constrained by the symmetries of the space-group. The inter-orbit coefficients are, however, free and unconstrained.</p><p>The Fourier resolution along each reciprocal lattice vector is controlled by <code>idxmax</code>: e.g., if <code>D = 2</code> and <code>idxmax = (2, 3)</code>, the resulting Fourier lattice may contain  reciprocal lattice vectors (k₁, k₂) with k₁∈[0,±1,±2] and k₂∈[0,±1,±2,±3], referred  to a 𝐆-basis.</p><p>This &quot;neutral&quot; lattice can, and usually should, be subsequently modulated by <a href="#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}, Union{Nothing, Real}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}, Union{Nothing, Real}, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>modulate</code></a> (which modulates the inter-orbit coefficients, which may eliminate &quot;synthetic symmetries&quot; that can exist in the &quot;neutral&quot; configuration, due to all  inter-orbit coefficients being set to unity).</p><p><strong>Examples</strong></p><p>Compute a <code>UnityFourierLattice</code>, modulate it with random inter-orbit coefficients  via <code>modulate</code>, and finally plot it (via Makie.jl):</p><pre><code class="language-julia-repl hljs">julia&gt; uflat = levelsetlattice(16, Val(2))
julia&gt; flat  = modulate(uflat)
julia&gt; Rs    = directbasis(16, Val(2)) 
julia&gt; using GLMakie
julia&gt; plot(flat, Rs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L48-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D" href="#Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D"><code>Crystalline.lgirreps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lgirreps(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3))
                                        -&gt; Dict{String, Collection{LGIrrep{D}}}</code></pre><p>For given space group number <code>sgnum</code> and dimension <code>D</code>, return the associated little group (or &quot;small&quot;) irreps (<code>LGIrrep{D}</code>s) at high-symmetry k-points, lines, and planes. </p><p>Returns a <code>Dict</code> with little group <strong>k</strong>-point labels as keys and vectors of <code>LGIrrep{D}</code>s as values.</p><p><strong>Notes</strong></p><ul><li>The returned irreps are complex in general. Real irreps (as needed in time-reversal invariant settings) can subsequently be obtained with the <a href="#Crystalline.realify-Tuple{AbstractDict{&lt;:AbstractString, &lt;:AbstractVector{&lt;:Crystalline.AbstractIrrep}}}"><code>realify</code></a> method.</li><li>Returned irreps are spinless.</li><li>The irrep labelling follows CDML conventions.</li><li>Irreps along lines or planes may depend on free parameters <code>αβγ</code> that parametrize the <strong>k</strong> point. To evaluate the irreps at a particular value of <code>αβγ</code> and return the associated matrices, use <code>(lgir::LGIrrep)(αβγ)</code>. If <code>αβγ</code> is an empty tuple in this call, the matrices associated with <code>lgir</code> will be evaluated assuming <code>αβγ = [0,0,...]</code>.</li></ul><p><strong>References</strong></p><p>The underlying data is sourced from the ISOTROPY ISO-IR dataset. Please cite the original reference material associated with ISO-IR:</p><ol><li>Stokes, Hatch, &amp; Campbell,  <a href="https://stokes.byu.edu/iso/irtables.php">ISO-IR, ISOTROPY Software Suite</a>.</li><li>Stokes, Campbell, &amp; Cordes, <a href="https://doi.org/10.1107/S0108767313007538">Acta Cryst. A. <strong>69</strong>, 388-395 (2013)</a>.</li></ol><p>The ISO-IR dataset is occasionally missing some <strong>k</strong>-points that lie outside the basic domain but still resides in the representation domain (i.e. <strong>k</strong>-points with postscripted &#39;A&#39;, &#39;B&#39;, etc. labels, such as &#39;ZA&#39;). In such cases, the missing irreps may instead have been manually sourced from the Bilbao Crystallographic Database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/littlegroup_irreps.jl#L48-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.littlegroup" href="#Crystalline.littlegroup"><code>Crystalline.littlegroup</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">littlegroup(sg::SpaceGroup, kv::KVec) -&gt; LittleGroup
littlegroup(
    sg::SpaceGroup,
    kv::KVec,
    klab::String
) -&gt; LittleGroup
</code></pre><p>Return the little group associated with space group <code>sg</code> at the <strong>k</strong>-vector <code>kv</code>.</p><p>Optionally, an associated <strong>k</strong>-vector label <code>klab</code> can be provided; if not provided, the empty string is used as label.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}} where D" href="#Crystalline.littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}} where D"><code>Crystalline.littlegroups</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">littlegroups(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3)) 
                                                    -&gt; Dict{String, LittleGroup{D}}</code></pre><p>For given space group number <code>sgnum</code> and dimension <code>D</code>, return the associated little groups (<code>LittleGroups{D}</code>s) at high-symmetry k-points, lines, and planes (see also <a href="#Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D"><code>lgirreps</code></a>).</p><p>Returns a <code>Dict</code> with little group <strong>k</strong>-point labels as keys and vectors of <code>LittleGroup{D}</code>s as values.</p><p><strong>Notes</strong></p><p>A conventional crystallographic setting is assumed (as in <a href="#Crystalline.spacegroup-Union{Tuple{Any}, Tuple{D}, Tuple{Any, Val{D}}} where D"><code>spacegroup</code></a>).</p><p>Unlike <code>spacegroup</code>, &quot;centering&quot;-copies of symmetry operations are not included in the returned <code>LittleGroup</code>s; as an example, space group 110 (body-centered, with centering symbol &#39;I&#39;) has a centering translation <code>[1/2,1/2,1/2]</code> in the conventional setting: the symmetry operations returned by <code>spacegroup</code> thus includes e.g. both <code>{1|0}</code> and  <code>{1|½,½,½}</code> while the symmetry operations returned by <code>littlegroups</code> only include <code>{1|0}</code> (and so on).</p><p>Currently, only <code>D = 3</code> is supported.</p><p><strong>References</strong></p><p>The underlying data is sourced from the ISOTROPY dataset: see also <a href="#Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D"><code>lgirreps</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/littlegroup_irreps.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.matrix-Tuple{Crystalline.AbstractOperation}" href="#Crystalline.matrix-Tuple{Crystalline.AbstractOperation}"><code>Crystalline.matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix(op::AbstractOperation{D}) --&gt; SMatrix{D, D+1, Float64}</code></pre><p>Return the <code>D</code>×<code>D+1</code> matrix representation of <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.maximal_subgroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D" href="#Crystalline.maximal_subgroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D"><code>Crystalline.maximal_subgroups</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maximal_subgroups(num::Integer, AG::Type{&lt;:AbstractGroup}=SpaceGrop{3}; kind)</code></pre><p>Returns the graph structure of the maximal subgroups as a <code>GroupRelationGraph</code> for a group of type <code>AG</code> and number <code>num</code>.</p><p><strong>Visualization</strong></p><p>The resulting group structure can be plotted using Makie.jl (e.g., GLMakie.jl) using <code>plot(::GroupRelationGraph)</code>:</p><pre><code class="language-jl hljs">julia&gt; using Crystalline
julia&gt; gr = maximal_subgroups(112, SpaceGroup{3})
julia&gt; using GraphMakie, GLMakie
julia&gt; plot(gr)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>kind</code> (default, <code>Crystalline.TRANSLATIONENGLEICHE</code>): to return klassengleiche relations, set <code>kind = Crystalline.KLASSENGLEICHE</code>). For klassengleiche relationships, only a selection of reasonably low-index relationships are returned.</li></ul><p><strong>Data sources</strong></p><p>The group relationships returned by this function were retrieved from the Bilbao Crystallographic Server&#39;s <a href="https://www.cryst.ehu.es/cryst/maxsub.html">MAXSUB</a> program. Please cite the original reference work associated with MAXSUB:</p><ul><li>Aroyo et al., <a href="https://doi.org/10.1524/zkri.2006.221.1.15">Z. Kristallogr. Cryst. Mater. <strong>221</strong>, 15 (2006)</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/grouprelations/grouprelations.jl#L35-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.minimal_supergroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D" href="#Crystalline.minimal_supergroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D"><code>Crystalline.minimal_supergroups</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimal_supergroups(num::Integer, AG::Type{&lt;:AbstractGroup}=SpaceGrop{3}; kind)</code></pre><p>Returns the graph structure of the minimal supergroups as a <code>GroupRelationGraph</code> for a group of type <code>AG</code> and number <code>num</code>.</p><p><strong>Visualization</strong></p><p>The resulting group structure can be plotted using Makie.jl (e.g., GLMakie.jl) using <code>plot(::GroupRelationGraph)</code>:</p><pre><code class="language-jl hljs">julia&gt; using Crystalline
julia&gt; gr = minimal_supergroups(112, SpaceGroup{3})
julia&gt; using GraphMakie, GLMakie
julia&gt; plot(gr)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>kind</code> (default, <code>Crystalline.TRANSLATIONENGLEICHE</code>): to return klassengleiche relations, set <code>kind = Crystalline.KLASSENGLEICHE</code>). For klassengleiche relationships, only a selection of reasonably low-index relationships are returned.</li></ul><p><strong>Data sources</strong></p><p>The group relationships returned by this function were retrieved from the Bilbao Crystallographic Server&#39;s <a href="https://www.cryst.ehu.es/cryst/maxsub.html">MAXSUB</a> program. Please cite the original reference work associated with MAXSUB:</p><ul><li>Aroyo et al., <a href="https://doi.org/10.1524/zkri.2006.221.1.15">Z. Kristallogr. Cryst. Mater. <strong>221</strong>, 15 (2006)</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/grouprelations/grouprelations.jl#L35-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}, Union{Nothing, Real}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}, Union{Nothing, Real}, Union{Nothing, ReciprocalBasis{D}}}} where D" href="#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}, Union{Nothing, Real}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}, Union{Nothing, Real}, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>Crystalline.modulate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modulate(flat::UnityFourierLattice{D},
modulation::AbstractVector{&lt;:Number}=rand(ComplexF64, length(getcoefs(flat))),
expon::Union{Nothing, Real}=nothing, Gs::Union{ReciprocalBasis{D}, Nothing}=nothing)
                        --&gt; ModulatedFourierLattice{D}</code></pre><p>Derive a concrete, modulated Fourier lattice from a <code>UnityFourierLattice</code> <code>flat</code> (containing the <em>interrelations</em> between orbit coefficients), by  multiplying the &quot;normalized&quot; orbit coefficients by a <code>modulation</code>, a <em>complex</em> modulating vector (in general, should be complex; otherwise restores unintended symmetry to the lattice). Distinct <code>modulation</code> vectors produce distinct  realizations of the same lattice described by the original <code>flat</code>. By default, a random complex vector is used.</p><p>An exponent <code>expon</code> can be provided, which introduces a penalty term to short- wavelength features (i.e. high-|G| orbits) by dividing the orbit coefficients by |G|^<code>expon</code>; producing a &quot;simpler&quot; and &quot;smoother&quot; lattice boundary when <code>expon &gt; 0</code> (reverse for <code>expon &lt; 0</code>). This basically amounts to a  continuous &quot;simplifying&quot; operation on the lattice (it is not necessarily a  smoothing operation; it simply suppresses &quot;high-frequency&quot; components). If <code>expon = nothing</code>, no rescaling is performed. If <code>Gs</code> is provided as <code>nothing</code>, the orbit norm is computed in the reciprocal lattice basis (and, so, may not strictly speaking be a norm if the lattice basis is not cartesian); to account for the basis explicitly, <code>Gs</code> must be provided as a <a href="../bravais/#Bravais.ReciprocalBasis"><code>ReciprocalBasis</code></a>, see also <a href="#Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>normscale</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L320-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.mspacegroup-Union{Tuple{D}, Tuple{Integer, Integer}, Tuple{Integer, Integer, Val{D}}} where D" href="#Crystalline.mspacegroup-Union{Tuple{D}, Tuple{Integer, Integer}, Tuple{Integer, Integer, Val{D}}} where D"><code>Crystalline.mspacegroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mspacegroup(BNS₁, BNS₂)
mspacegroup(OG₃)        --&gt; MSpaceGroup{3}</code></pre><p>Return the magnetic space group with BNS numbers <code>(BNS₁, BNS₂)</code> or the sequential OG number <code>OG₃</code> (from 1 to 1651).</p><p><strong>Data sources</strong></p><p>The data underlying this function was retrieved from ISOTROPY&#39;s compilation of Daniel  Litvin&#39;s magnetic space group tables (http://www.bk.psu.edu/faculty/litvin/Download.html).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/assembly/groups/mspacegroup.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.mulliken-Union{Tuple{PGIrrep{D}}, Tuple{D}} where D" href="#Crystalline.mulliken-Union{Tuple{PGIrrep{D}}, Tuple{D}} where D"><code>Crystalline.mulliken</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mulliken(pgir::PGIrrep{D}) -&gt; String
</code></pre><p>Return the Mulliken label of a point group irrep <code>pgir</code>.</p><p><strong>Notes</strong></p><p>This functionality is a simple mapping between the tabulated CDML point group irrep labels and associated Mulliken labels <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, using the listings from the Bilbao Crystallographic Database <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><p>Ignoring subscript, the rough rules associated with assignment of Mulliken labels are:</p><ol><li><strong>Irrep dimensionality</strong>: <ul><li><strong>1D irreps</strong>: if a real irrep, assign A or B (B if antisymmetric under a principal  rotation); if a complex irrep, assigned label ¹E or ²E.</li><li><strong>2D irreps</strong>: assign label E.</li><li><strong>3D irreps</strong>: assign label T.</li></ul></li><li><strong><em>u</em> and <em>g</em> subscripts</strong>: if the group contains inversion, indicate whether irrep is symmetric (g ~ gerade) or antisymmetric (u ~ ungerade) under inversion.</li><li><strong>Prime superscripts</strong>: if the group contains a mirror <em>m</em> aligned with a principal  rotation axis, but does <em>not</em> contain inversion, indicate whether irrep is symmetric (′)  or antisymmetric (′′) under this mirror.</li><li><strong>Numeral subscripts</strong>: the rules for assignment of numeral subscripts are too complicated in general - and indeed, we are unaware of a general coherent rule – to describe here.</li></ol><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/notation.jl#L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.multiplicities-Tuple{Crystalline.AbstractSymmetryVector}" href="#Crystalline.multiplicities-Tuple{Crystalline.AbstractSymmetryVector}"><code>Crystalline.multiplicities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiplicities(n::AbstractSymmetryVector) -&gt; AbstractVector{&lt;:AbstractVector{Int}}</code></pre><p>Return the multiplicities of the irreps referenced by <code>n</code>.</p><p>See also <a href="#Crystalline.irreps-Tuple{Crystalline.AbstractSymmetryVector}"><code>irreps(::AbstractSymmetryVector)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L307-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.normscale!-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D" href="#Crystalline.normscale!-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>Crystalline.normscale!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normscale!(flat::ModulatedFourierLattice, expon::Real,
           Gs::Union{ReciprocalBasis, Nothing} = nothing) --&gt; ModulatedFourierLattice</code></pre><p>In-place equivalent of <a href="#Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>normscale</code></a>: mutates <code>flat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L386-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D" href="#Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>Crystalline.normscale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normscale(flat::ModulatedFourierLattice, expon::Real, 
          Gs::Union{ReciprocalBasis, Nothing} = nothing)  --&gt; ModulatedFourierLattice</code></pre><p>Applies inverse-orbit norm rescaling of expansion coefficients with a norm exponent <code>expon</code>. If <code>Gs</code> is nothing, the orbit norm is computed in the lattice basis (and, so, is not strictly a norm); by providing <code>Gs</code> as <a href="../bravais/#Bravais.ReciprocalBasis"><code>ReciprocalBasis</code></a>, the norm is evaluated correctly in cartesian setting. See further discussion in <a href="#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}, Union{Nothing, Real}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{&lt;:Number}}, Union{Nothing, Real}, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>modulate</code></a>.</p><p>An in-place equivalent is provided in <a href="#Crystalline.normscale!-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D"><code>normscale!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/fourierlattices.jl#L371-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.num-Tuple{Crystalline.AbstractGroup}" href="#Crystalline.num-Tuple{Crystalline.AbstractGroup}"><code>Crystalline.num</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num(g::AbstractGroup) -&gt; Int</code></pre><p>Return the conventional number assigned to the group <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L543-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.occupation-Tuple{Crystalline.AbstractSymmetryVector}" href="#Crystalline.occupation-Tuple{Crystalline.AbstractSymmetryVector}"><code>Crystalline.occupation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">occupation(n::AbstractSymmetryVector) -&gt; Int</code></pre><p>Return the occupation of (i.e., number of bands contained within) <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.operations-Tuple{Crystalline.AbstractGroup}" href="#Crystalline.operations-Tuple{Crystalline.AbstractGroup}"><code>Crystalline.operations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">operations(g::AbstractGroup) -&gt; Vector{&lt;:AbstractOperation}</code></pre><p>Return an <code>Vector</code> containing the operations of the group <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L550-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.orbit-Tuple{SiteGroup}" href="#Crystalline.orbit-Tuple{SiteGroup}"><code>Crystalline.orbit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orbit(g::SiteGroup)  --&gt;  Vector{WyckoffPosition}</code></pre><p>Compute the orbit of the Wyckoff position associated with the site symmetry group <code>g</code>.</p><p><strong>Extended help</strong></p><p>The orbit of a Wyckoff position <span>$\mathbf{r}$</span> in a space group <span>$G$</span> is defined as the set of inequivalent points in the unit cell that can be obtained by applying the elements of <span>$G$</span> to <span>$\mathbf{r}$</span>. Equivalently, every element of the orbit of <span>$\mathbf{r}$</span> can be written as the composition of a coset representative of the Wyckoff position&#39;s site group in <span>$G$</span> with <span>$\mathbf{r}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/wyckoff.jl#L210-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.orbit-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}, Union{Nothing, AbstractMatrix{&lt;:Real}}}} where D" href="#Crystalline.orbit-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}, Union{Nothing, AbstractMatrix{&lt;:Real}}}} where D"><code>Crystalline.orbit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orbit(g::AbstractVector{&lt;:SymOperation}, kv::KVec, cntr::Char)  --&gt;  Vector{KVec{D}}
orbit(lg::LittleGroup)
orbit(lgir::LGIrrep)</code></pre><p>Return the orbit of of the reciprocal-space vector <code>kv</code> under the action of the group <code>g</code>, also known as the star of <strong>k</strong>.</p><p>The orbit of <code>kv</code> in <code>g</code> is the set of inequivalent <strong>k</strong>-points obtained by composition of all the symmetry operations of <code>g</code> with <code>kv</code>. Two reciprocal vectors <span>$\mathbf{k}$</span> and <span>$\mathbf{k}&#39;$</span> are equivalent if they differ by a primitive reciprocal lattice vector.</p><p>If <code>kv</code> and <code>g</code> are specified in a conventional basis but refer to a non-primitive lattice, the centering type <code>cntr</code> must be provided to ensure that only equivalence by primitive (not conventional) reciprocal lattice vectors are considered. If the centering type of the group <code>g</code> can be inferred from <code>g</code> (e.g., if <code>g</code> is a <code>SpaceGroup</code>), <code>orbit</code> will assume a conventional setting and use the inferred centering type; otherwise, if <code>cntr</code> is neither explicitly set nor inferrable, a primitive setting is assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L471-L490">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.pgirreps" href="#Crystalline.pgirreps"><code>Crystalline.pgirreps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pgirreps(iuclab::String, ::Val{D}=Val(3); mulliken::Bool=false) where D ∈ (1,2,3)
pgirreps(iuclab::String, D; mulliken::Bool=false)</code></pre><p>Return the (crystallographic) point group irreps of the IUC label <code>iuclab</code> of dimension <code>D</code> as a <code>Vector{PGIrrep{D}}</code>.</p><p>See <code>Crystalline.PG_IUC2NUM[D]</code> for possible IUC labels in dimension <code>D</code>.</p><p><strong>Notation</strong></p><p>The irrep labelling follows the conventions of CDML <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> [which occasionally differ from those in e.g. Bradley and Cracknell, <em>The Mathematical Theory of Symmetry in Solids</em>  (1972)].</p><p>To use Mulliken (&quot;spectroscopist&quot;) irrep labels instead, set the keyword argument <code>mulliken = true</code> (default, <code>false</code>). See also <a href="#Crystalline.mulliken-Union{Tuple{PGIrrep{D}}, Tuple{D}} where D"><code>mulliken</code></a>.</p><p><strong>Data sources</strong></p><p>The data is sourced from the Bilbao Crystallographic Server <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. If you are using this  functionality in an explicit fashion, please cite the original reference <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</p><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/pointgroup.jl#L102-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.physical_realify-Tuple{Union{PGIrrep, SiteIrrep}}" href="#Crystalline.physical_realify-Tuple{Union{PGIrrep, SiteIrrep}}"><code>Crystalline.physical_realify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">physical_realify(ir::Union{&lt;:PGIrrep, &lt;:SiteIrrep})</code></pre><p>Return a manifestly real form of an input irrep <code>ir</code> (also called a physically real irrep).</p><p>The input irrep must be either a <a href="#Crystalline.PGIrrep"><code>PGIrrep</code></a> or a <a href="#Crystalline.SiteIrrep"><code>SiteIrrep</code></a> and must be equivalent to a real irrep: i.e., the irrep has <a href="#Crystalline.Reality"><code>Reality</code></a> type <code>REAL</code> or is a <code>PSEUDOREAL</code> or <code>COMPLEX</code> that has already been passed through <code>realify</code> and glued together with its partner (i.e., <code>iscorep(ir) = true</code>).</p><p>See also <a href="#Crystalline.physical_realify-Tuple{Union{PGIrrep, SiteIrrep}}"><code>physical_realify(::Collection{&lt;:Union{&lt;:PGIrrep, &lt;:SiteIrrep}})</code></a> for application to a collection of irreps.</p><p><strong>Implementation</strong></p><p>A symmetric, unitary transformation is found that maps the irrep matrices to a manifestly real form. The resulting transformed irrep matrices <code>Zs</code> have the property that <code>all(Zᵢ -&gt; Zᵢ ≈ conj(Zᵢ), Zs)</code> is true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pgir = pgirreps(19, 3)[end]
Γ₃┌     1: ⎡ 1  0 ⎤
  │        ⎣ 0  1 ⎦
  ├ 3₀₀₁⁺: ⎡ -0.5+0.866im             0 ⎤
  │        ⎣            0  -0.5-0.866im ⎦
  ├ 3₀₀₁⁻: ⎡ -0.5-0.866im             0 ⎤
  │        ⎣            0  -0.5+0.866im ⎦
  ├  m₁₁₀: ⎡ 0  1 ⎤
  │        ⎣ 1  0 ⎦
  ├  m₁₀₀: ⎡            0  -0.5-0.866im ⎤
  │        ⎣ -0.5+0.866im             0 ⎦
  ├  m₀₁₀: ⎡            0  -0.5+0.866im ⎤
  └        ⎣ -0.5-0.866im             0 ⎦

julia&gt; reality(pgir)
REAL::Reality = 1

julia&gt; physical_realify(pgir)
Γ₃┌     1: ⎡ 1  0 ⎤
  │        ⎣ 0  1 ⎦
  ├ 3₀₀₁⁺: ⎡   -0.5  0.866 ⎤
  │        ⎣ -0.866   -0.5 ⎦
  ├ 3₀₀₁⁻: ⎡  -0.5  -0.866 ⎤
  │        ⎣ 0.866    -0.5 ⎦
  ├  m₁₁₀: ⎡ 0  1 ⎤
  │        ⎣ 1  0 ⎦
  ├  m₁₀₀: ⎡ -0.866   -0.5 ⎤
  │        ⎣   -0.5  0.866 ⎦
  ├  m₀₁₀: ⎡ 0.866    -0.5 ⎤
  └        ⎣  -0.5  -0.866 ⎦</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/irreps_physical_reality.jl#L89-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.physical_realify-Union{Tuple{Collection{T}}, Tuple{T}} where T&lt;:(Union{var&quot;#s238&quot;, var&quot;#s237&quot;} where {var&quot;#s238&quot;&lt;:PGIrrep, var&quot;#s237&quot;&lt;:SiteIrrep})" href="#Crystalline.physical_realify-Union{Tuple{Collection{T}}, Tuple{T}} where T&lt;:(Union{var&quot;#s238&quot;, var&quot;#s237&quot;} where {var&quot;#s238&quot;&lt;:PGIrrep, var&quot;#s237&quot;&lt;:SiteIrrep})"><code>Crystalline.physical_realify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">physical_realify(irs::Collection{T}) where T &lt;: Union{&lt;:PGIrrep, &lt;:SiteIrrep}</code></pre><p>Return a manifestly real form of <code>irs</code> (also known as physically real irreps), where <code>irs</code> is a <a href="#Crystalline.Collection"><code>Collection</code></a> of either <a href="#Crystalline.PGIrrep"><code>PGIrrep</code></a>s or <a href="#Crystalline.SiteIrrep"><code>SiteIrrep</code></a>s.</p><p>The input irreps may or may not have already been passed through <a href="#Crystalline.realify-Tuple{AbstractDict{&lt;:AbstractString, &lt;:AbstractVector{&lt;:Crystalline.AbstractIrrep}}}"><code>realify</code></a> (and thus already glued together with any pseudoreal or complex partners); if they have not, the input is first passed through <code>realify</code>.</p><p>See also <a href="#Crystalline.physical_realify-Tuple{Union{PGIrrep, SiteIrrep}}"><code>physical_realify(::Union{&lt;:PGIrrep, &lt;:SiteIrrep})</code></a> for application to individual irreps.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pgirs = pgirreps(9,2);

julia&gt; physical_realify(pgirs)
4-element Collection{PGIrrep{2}} for ⋕9 (6):
Γ₁┌  1: 1
  ├ 3⁺: 1
  ├ 3⁻: 1
  ├  2: 1
  ├ 6⁻: 1
  └ 6⁺: 1

Γ₂┌  1: 1
  ├ 3⁺: 1
  ├ 3⁻: 1
  ├  2: -1
  ├ 6⁻: -1
  └ 6⁺: -1

Γ₃Γ₅┌  1: ⎡ 1  0 ⎤
    │     ⎣ 0  1 ⎦
    ├ 3⁺: ⎡   -0.5  0.866 ⎤
    │     ⎣ -0.866   -0.5 ⎦
    ├ 3⁻: ⎡  -0.5  -0.866 ⎤
    │     ⎣ 0.866    -0.5 ⎦
    ├  2: ⎡ 1  0 ⎤
    │     ⎣ 0  1 ⎦
    ├ 6⁻: ⎡   -0.5  0.866 ⎤
    │     ⎣ -0.866   -0.5 ⎦
    ├ 6⁺: ⎡  -0.5  -0.866 ⎤
    └     ⎣ 0.866    -0.5 ⎦

Γ₄Γ₆┌  1: ⎡ 1  0 ⎤
    │     ⎣ 0  1 ⎦
    ├ 3⁺: ⎡   -0.5  0.866 ⎤
    │     ⎣ -0.866   -0.5 ⎦
    ├ 3⁻: ⎡  -0.5  -0.866 ⎤
    │     ⎣ 0.866    -0.5 ⎦
    ├  2: ⎡ -1   0 ⎤
    │     ⎣  0  -1 ⎦
    ├ 6⁻: ⎡   0.5  -0.866 ⎤
    │     ⎣ 0.866     0.5 ⎦
    ├ 6⁺: ⎡    0.5  0.866 ⎤
    └     ⎣ -0.866    0.5 ⎦</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/irreps_physical_reality.jl#L187-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D" href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D"><code>Crystalline.pointgroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointgroup(ops:AbstractVector{SymOperation{D}})
pointgroup(sg::AbstractGroup)</code></pre><p>Computes the point group associated with a space group <code>sg</code> (characterized by a set of operators <code>ops</code>, which, jointly with lattice translations generate  the space group), obtained by &quot;taking away&quot; any translational parts and  then reducing to the resulting unique rotational operations. (technically, in the language of Bradley &amp; Cracknell, this is the so-called isogonal point group of <code>sg</code>; see Sec. 1.5).</p><p>Returns a <code>Vector</code> of <code>SymOperation</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L190-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.pointgroup-Union{Tuple{AbstractString}, Tuple{D}, Tuple{AbstractString, Val{D}}} where D" href="#Crystalline.pointgroup-Union{Tuple{AbstractString}, Tuple{D}, Tuple{AbstractString, Val{D}}} where D"><code>Crystalline.pointgroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointgroup(iuclab::String, ::Union{Val{D}, Integer}=Val(3))  --&gt;  PointGroup{D}</code></pre><p>Return the symmetry operations associated with the point group identified with label <code>iuclab</code> in dimension <code>D</code> as a <code>PointGroup{D}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/assembly/groups/pointgroup.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.pointgroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Integer}} where D" href="#Crystalline.pointgroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Integer}} where D"><code>Crystalline.pointgroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointgroup(pgnum::Integer, ::Union{Val{D}, Integer}=Val(3), setting::Integer=1)
                                                                  --&gt;  PointGroup{D}</code></pre><p>Return the symmetry operations associated with the point group identfied with canonical number <code>pgnum</code> in dimension <code>D</code> as a <code>PointGroup{D}</code>. The connection between a point group&#39;s numbering and its IUC label is enumerated in <code>Crystalline.PG_NUM2IUC[D]</code> and <code>Crystalline.IUC2NUM[D]</code>.</p><p>Certain point groups feature in multiple setting variants: e.g., IUC labels 321 and 312 both correspond to <code>pgnum = 18</code> and correspond to the same group structure expressed in two different settings. The <code>setting</code> argument allows choosing between these setting variations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/assembly/groups/pointgroup.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.realify!-Tuple{AbstractDict{&lt;:AbstractString, &lt;:AbstractVector{&lt;:Crystalline.AbstractIrrep}}}" href="#Crystalline.realify!-Tuple{AbstractDict{&lt;:AbstractString, &lt;:AbstractVector{&lt;:Crystalline.AbstractIrrep}}}"><code>Crystalline.realify!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">realify!(lgirsd::AbstractDict{&lt;:AbstractIrrep, &lt;:AbstractVector{&lt;:AbstractIrrep}})</code></pre><p>Apply <code>realify</code> to each value of <code>lgirsd</code> in-place, returning the mutated <code>lgirsd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/irreps_reality.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.realify-Tuple{AbstractDict{&lt;:AbstractString, &lt;:AbstractVector{&lt;:Crystalline.AbstractIrrep}}}" href="#Crystalline.realify-Tuple{AbstractDict{&lt;:AbstractString, &lt;:AbstractVector{&lt;:Crystalline.AbstractIrrep}}}"><code>Crystalline.realify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">realify(lgirsd::AbstractDict{&lt;:AbstractIrrep, &lt;:AbstractVector{&lt;:AbstractIrrep}}) 
                    --&gt; Dict{&lt;:AbstractIrrep, &lt;:AbstractVector{&lt;:AbstractIrrep}}</code></pre><p>Apply <code>realify</code> to each value of <code>lgirsd</code>, returning a new <code>Dict</code> of realified irreps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/irreps_reality.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D}, 1}}, Tuple{D}} where D" href="#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D}, 1}}, Tuple{D}} where D"><code>Crystalline.realify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">realify(lgirs::AbstractVector{&lt;:LGIrrep}; verbose::Bool=false)
                                                    --&gt; AbstractVector{&lt;:LGIrrep}</code></pre><p>From <code>lgirs</code>, a vector of <code>LGIrrep</code>s, determine the associated (gray) co-representations, i.e. the &quot;real&quot;, or &quot;physical&quot; irreps that are relevant in scenarios with time-reversal symmetry.</p><p>For <code>LGIrrep</code> that are <code>REAL</code>, or that characterize a k-point 𝐤 which is not equivalent to -𝐤 (i.e. its star does not include both 𝐤 and -𝐤; equivalently, the little group includes time-reversal symmetry), the associated co-representations are just the  original irreps themselves.  For <code>PSEUDOREAL</code> and <code>COMPLEX</code> <code>LGIrrep</code>s where ±𝐤 are equivalent, the associated co-representations are built from pairs of irreps that &quot;stick&quot; together. This method computes this pairing and sets the <code>LGIrrep</code> field <code>iscorep</code> to true, to indicate that the resulting &quot;paired irrep&quot; (i.e. the co-representation) should be doubled with  itself (<code>PSEUDOREAL</code> reality) or its complex conjugate (<code>COMPLEX</code> reality).</p><p><strong>Background</strong></p><p>For background, see p. 650-652 (and p. 622-626 for point groups) in Bradley &amp; Cracknell&#39;s book. Their discussion is for magnetic groups (the &quot;realified&quot; irreps are, in fact, simply co-representations of the &quot;gray&quot; magnetic groups).  Cornwell&#39;s book also explicates this at some length as does Inui et al. (p. 296-299).</p><p><strong>Keyword arguments</strong></p><ul><li><code>verbose::Bool</code>: if set to <code>true</code>, prints details about mapping from small irrep to small</li></ul><p>corep for each <code>LGIrrep</code> (default: <code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/irreps_reality.jl#L24-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.realify-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Crystalline.AbstractIrrep" href="#Crystalline.realify-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Crystalline.AbstractIrrep"><code>Crystalline.realify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">realify(pgirs::AbstractVector{T}) where T&lt;:AbstractIrrep --&gt; Vector{T}</code></pre><p>Return physically real irreps (coreps) from a set of conventional irreps (as produced by e.g. <a href="#Crystalline.pgirreps"><code>pgirreps</code></a>). Fallback method for point-group-like <code>AbstractIrrep</code>s.</p><p><strong>Example</strong></p><pre><code class="language-jl-doctest hljs">julia&gt; pgirs = pgirreps(&quot;4&quot;, Val(3));
julia&gt; characters(pgirs)
CharacterTable{3}: ⋕9 (4)
───────┬────────────────────
       │ Γ₁  Γ₂    Γ₃    Γ₄ 
───────┼────────────────────
     1 │  1   1     1     1
  2₀₀₁ │  1   1    -1    -1
 4₀₀₁⁺ │  1  -1   1im  -1im
 4₀₀₁⁻ │  1  -1  -1im   1im
───────┴────────────────────

julia&gt; characters(realify(pgirs))
CharacterTable{3}: ⋕9 (4)
───────┬──────────────
       │ Γ₁  Γ₂  Γ₃Γ₄ 
───────┼──────────────
     1 │  1   1     2
  2₀₀₁ │  1   1    -2
 4₀₀₁⁺ │  1  -1     0
 4₀₀₁⁻ │  1  -1     0
───────┴──────────────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/irreps_reality.jl#L238-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.reality-Tuple{Crystalline.AbstractIrrep}" href="#Crystalline.reality-Tuple{Crystalline.AbstractIrrep}"><code>Crystalline.reality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reality(ir::AbstractIrrep) --&gt; Reality</code></pre><p>Return the reality of <code>ir</code> (see <a href="#Crystalline.Reality"><code>Reality</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L730-L734">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.reduce_ops-Union{Tuple{Pdim}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Char}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool, Bool}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool, Bool, Val{Pdim}}} where {D, Pdim}" href="#Crystalline.reduce_ops-Union{Tuple{Pdim}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Char}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool, Bool}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool, Bool, Val{Pdim}}} where {D, Pdim}"><code>Crystalline.reduce_ops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_ops(ops::AbstractVector{SymOperation{D}},
           cntr::Char,
           conv_or_prim::Bool=true,
           modw::Bool=true) --&gt; Vector{SymOperation{D}}</code></pre><p>Reduce the operations <code>ops</code>, removing operations that are identical in the primitive basis associated with the centering <code>cntr</code>. </p><p>If <code>conv_or_prim = false</code>, the reduced operations are returned in the primitive basis associated with <code>cntr</code>; otherwise, in the conventional. If <code>modw = true</code>, the comparison in the primitive basis is done modulo unit primitive lattice vectors; otherwise not. A final argument of type <code>::Val{P}</code> can be specified to indicate a subperiodic group of periodicity dimension <code>P</code>, different from the spatial embedding dimension <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L777-L792">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.remap_to_kstar-Union{Tuple{D}, Tuple{AbstractArray{LGIrrep{D}, 1}, KVec{D}}, Tuple{AbstractArray{LGIrrep{D}, 1}, KVec{D}, AbstractArray{SymOperation{D}, 1}}} where D" href="#Crystalline.remap_to_kstar-Union{Tuple{D}, Tuple{AbstractArray{LGIrrep{D}, 1}, KVec{D}}, Tuple{AbstractArray{LGIrrep{D}, 1}, KVec{D}, AbstractArray{SymOperation{D}, 1}}} where D"><code>Crystalline.remap_to_kstar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remap_to_kstar(
    lgirs::AbstractVector{LGIrrep{D}},
    kv′::KVec{D},
    coset_representatives::AbstractVector{SymOperation{D}}
    ) --&gt; Collection{LGIrrep{D}}</code></pre><p>Given an set of <code>LGIrrep</code>s <code>lgirs</code> defined at a <strong>k</strong>-vector <code>kv</code>, remap the irrep data to a different <strong>k</strong>-vector <code>kv′</code> in the star of <code>kv</code>.</p><p>The remapping is done by identifying an operation <code>g</code> s.t. <code>kv′ = g * kv</code> with <code>g</code> in the space group of <code>lgirs</code> (more precisely, from among the coset representatives of the little group in the space group). The original irreps <span>$D(h)$</span> with <span>$h$</span> in the little group of <code>kv</code> are then transformed according to <span>$D&#39;(h&#39;) = D(h) = D(g⁻¹h&#39;g)$</span> with <span>$h&#39;$</span> from the little group of <code>kv&#39;</code>.</p><p>The coset representatives can be specified as an optional argument, to avoid repeated recomputation and simplify the associated computation of <code>g</code>. The coset representatives generate the star of <code>kv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/compatibility.jl#L173-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.rotation-Tuple{Crystalline.AbstractOperation}" href="#Crystalline.rotation-Tuple{Crystalline.AbstractOperation}"><code>Crystalline.rotation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation(op::AbstractOperation{D}) --&gt; SMatrix{D, D, Float64}</code></pre><p>Return the <code>D</code>×<code>D</code> rotation part of <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.schoenflies-Tuple{Integer}" href="#Crystalline.schoenflies-Tuple{Integer}"><code>Crystalline.schoenflies</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schoenflies(sgnum::Integer) --&gt; String</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Schoenflies_notation">Schoenflies notation</a> for space group number <code>sgnum</code> in dimension 3.</p><p>Note that Schoenflies notation is well-defined only for 3D point and space groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/notation.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D" href="#Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D"><code>Crystalline.seitz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">seitz(op::SymOperation) --&gt; String</code></pre><p>Computes the correponding Seitz notation for a symmetry operation in triplet/xyzt form.</p><p>Implementation based on ITA5 Table 11.2.1.1, with 3D point group parts inferred from the trace and determinant of the matrix <span>$\mathb{W}$</span> in the triplet <span>$\{\mathbf{W}|\mathbf{w}\}$</span>.</p><table><tr><th style="text-align: left">detW/trW</th><th style="text-align: right">-3</th><th style="text-align: right">-2</th><th style="text-align: right">-1</th><th style="text-align: right">0</th><th style="text-align: right">1</th><th style="text-align: right">2</th><th style="text-align: right">3</th></tr><tr><td style="text-align: left"><strong>1</strong></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">2</td><td style="text-align: right">3</td><td style="text-align: right">4</td><td style="text-align: right">6</td><td style="text-align: right">1</td></tr><tr><td style="text-align: left"><strong>-1</strong></td><td style="text-align: right">-1</td><td style="text-align: right">-6</td><td style="text-align: right">-4</td><td style="text-align: right">-3</td><td style="text-align: right">m</td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>with the elements of the table giving the type of symmetry operation in in Hermann-Mauguin notation. The rotation axis and the rotation sense are computed following the rules in ITA6 Sec. 1.2.2.4(1)(b-c). See also .</p><p>Note that the orientation of the axis (i.e. its sign) does not necessarily match the orientation picked in Tables 1.4.2.1-5 of ITA6; it is a matter of (arbitrary) convention, and the conventions have not been explicated in ITA.</p><p>2D operations are treated by the same procedure, by elevation in a third dimension; 1D operations by a simple inspection of sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/notation.jl#L180-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.sitegroup-Union{Tuple{D}, Tuple{SpaceGroup{D}, WyckoffPosition{D}}} where D" href="#Crystalline.sitegroup-Union{Tuple{D}, Tuple{SpaceGroup{D}, WyckoffPosition{D}}} where D"><code>Crystalline.sitegroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sitegroup(
    sg::SpaceGroup{D},
    wp::WyckoffPosition{D}
) -&gt; SiteGroup
</code></pre><p>Return the site symmetry group <code>g::SiteGroup</code> for a Wyckoff position <code>wp</code> in space group <code>sg</code> (or with space group number <code>sgnum</code>; in this case, the dimensionality is inferred from <code>wp</code>).</p><p><code>g</code> is a group of operations that are isomorphic to the those listed in <code>sg</code> (in the sense that they might differ by lattice vectors) and that leave the Wyckoff position <code>wp</code> invariant, such that <code>all(op -&gt; wp == compose(op, wp), g) == true</code>.</p><p>The returned <code>SiteGroup</code> also contains the coset representatives of the Wyckoff position (that are again isomorphic to those featured in <code>sg</code>), accessible via <a href="#Crystalline.cosets-Tuple{SiteGroup}"><code>cosets</code></a>, which e.g. generate the orbit of the Wyckoff position (see <a href="#Crystalline.orbit-Tuple{SiteGroup}"><code>orbit(::SiteGroup)</code></a>) and define a left-coset decomposition of <code>sg</code> jointly with the elements in <code>g</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 16;

julia&gt; D = 2;

julia&gt; wp = wyckoffs(sgnum, D)[3] # pick a Wyckoff position
2b: [1/3, 2/3]

julia&gt; sg = spacegroup(sgnum, D);

julia&gt; g  = sitegroup(sg, wp)
SiteGroup{2} ⋕16 (p6) at 2b = [1/3, 2/3] with 3 operations:
 1
 {3⁺|1,1}
 {3⁻|0,1}</code></pre><p>The group structure of a <code>SiteGroup</code> can be inspected with <code>MultTable</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; MultTable(g)
3×3 MultTable{SymOperation{2}}:
──────────┬──────────────────────────────
          │        1  {3⁺|1,1}  {3⁻|0,1} 
──────────┼──────────────────────────────
        1 │        1  {3⁺|1,1}  {3⁻|0,1} 
 {3⁺|1,1} │ {3⁺|1,1}  {3⁻|0,1}         1
 {3⁻|0,1} │ {3⁻|0,1}         1  {3⁺|1,1}
──────────┴──────────────────────────────</code></pre><p>The original space group can be reconstructed from a left-coset decomposition, using the operations and cosets contained in a <code>SiteGroup</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; ops = [opʰ*opᵍ for opʰ in cosets(g) for opᵍ in g];

julia&gt; Set(sg) == Set(ops)
true</code></pre><p><strong>Terminology</strong></p><p>Mathematically, the site symmetry group is a <em>stabilizer group</em> for a Wyckoff position, in the same sense that the little group of <strong>k</strong> is a stabilizer group for a <strong>k</strong>-point.</p><p>See also <a href="#Crystalline.sitegroups-Union{Tuple{SpaceGroup{D}}, Tuple{D}} where D"><code>sitegroups</code></a> for calculation of all site symmetry groups of a given space group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/wyckoff.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.sitegroups-Union{Tuple{SpaceGroup{D}}, Tuple{D}} where D" href="#Crystalline.sitegroups-Union{Tuple{SpaceGroup{D}}, Tuple{D}} where D"><code>Crystalline.sitegroups</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sitegroups(sg::SpaceGroup{D}) -&gt; Any
</code></pre><p>Return all site symmetry groups associated with a space group, specified either as  <code>sg :: SpaceGroup{D}</code> or by its conventional number <code>sgnum</code> and dimension <code>D</code> (if omitted, <code>D</code> defaults to 3).</p><p>See also <a href="#Crystalline.sitegroup-Union{Tuple{D}, Tuple{SpaceGroup{D}, WyckoffPosition{D}}} where D"><code>sitegroup</code></a> for calculation of the site symmetry group of a specific Wyckoff position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/wyckoff.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.siteirreps-Union{Tuple{SiteGroup{D}}, Tuple{D}} where D" href="#Crystalline.siteirreps-Union{Tuple{SiteGroup{D}}, Tuple{D}} where D"><code>Crystalline.siteirreps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">siteirreps(sitegroup::SiteGroup; mulliken::Bool=false]) --&gt; Vector{PGIrrep}</code></pre><p>Return the site symmetry irreps associated with the provided <code>SiteGroup</code>, obtained from a search over isomorphic point groups. The <code>SiteIrrep</code>s are in general a permutation of the irreps of the associated isomorphic point group.</p><p>By default, the labels of the site symmetry irreps are given in the CDML notation; to use the Mulliken notation, set the keyword argument <code>mulliken</code> to <code>true</code> (default, <code>false</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 16;

julia&gt; sg = spacegroup(sgnum, 2);

julia&gt; wp = wyckoffs(sgnum, 2)[3] # pick the third Wyckoff position
2b: [1/3, 2/3]

julia&gt; siteg = sitegroup(sg, wp)
SiteGroup{2} ⋕16 (p6) at 2b = [1/3, 2/3] with 3 operations:
 1
 {3⁺|1,1}
 {3⁻|0,1}

julia&gt; siteirs = siteirreps(siteg)
3-element Collection{SiteIrrep{2}} for ⋕16 (p6) at 2b = [1/3, 2/3]:
Γ₁┌        1: 1
  ├ {3⁺|1,1}: 1
  └ {3⁻|0,1}: 1

Γ₂┌        1: 1
  ├ {3⁺|1,1}: exp(0.6667iπ)
  └ {3⁻|0,1}: exp(-0.6667iπ)

Γ₃┌        1: 1
  ├ {3⁺|1,1}: exp(-0.6667iπ)
  └ {3⁻|0,1}: exp(0.6667iπ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/wyckoff.jl#L303-L342">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.spacegroup-Union{Tuple{Any}, Tuple{D}, Tuple{Any, Val{D}}} where D" href="#Crystalline.spacegroup-Union{Tuple{Any}, Tuple{D}, Tuple{Any, Val{D}}} where D"><code>Crystalline.spacegroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spacegroup(sgnum::Integer, ::Val{D}=Val(3))
spacegroup(sgnum::Integer, D::Integer)          --&gt; SpaceGroup{D}</code></pre><p>Return the space group symmetry operations for a given space group number <code>sgnum</code> and  dimensionality <code>D</code> as a <code>SpaceGroup{D}</code>. The returned symmetry operations are specified relative to the conventional basis vectors, i.e. are not necessarily primitive (see <a href="../bravais/#Bravais.centering"><code>centering</code></a>). If desired, operations for the primitive unit cell can subsequently be generated using  <a href="../bravais/#Bravais.primitivize"><code>primitivize</code></a> or <a href="#Crystalline.reduce_ops-Union{Tuple{Pdim}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Char}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool, Bool}, Tuple{AbstractArray{SymOperation{D}, 1}, Char, Bool, Bool, Val{Pdim}}} where {D, Pdim}"><code>Crystalline.reduce_ops</code></a>.</p><p>The default choices for the conventional basis vectors follow the conventions of the Bilbao Crystallographic Server (or, equivalently, the International Tables of Crystallography),  which are:</p><ul><li>Unique axis <em>b</em> (cell choice 1) for monoclinic space groups.</li><li>Obverse triple hexagonal unit cell for rhombohedral space groups.</li><li>Origin choice 2: inversion centers are placed at (0,0,0). (relevant for certain centrosymmetric space groups with two possible choices; e.g., in the orthorhombic, tetragonal or cubic crystal systems).</li></ul><p>See also <a href="../bravais/#Bravais.directbasis"><code>directbasis</code></a>.</p><p><strong>Data sources</strong></p><p>The symmetry operations returned by this function were originally retrieved from the <a href="https://www.cryst.ehu.es/cryst/get_gen.html">Bilbao Crystallographic Server, SPACEGROUP GENPOS</a>. The associated citation is: (<a href="https://doi.org/10.1524/zkri.2006.221.1.15">Aroyo et al., Z. Kristallogr. Cryst. Mater. <strong>221</strong>, 15 (2006).</a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/assembly/groups/spacegroup.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.subduction_count-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Union{Nothing, AbstractVector{&lt;:Real}}}} where T&lt;:Crystalline.AbstractIrrep" href="#Crystalline.subduction_count-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Union{Nothing, AbstractVector{&lt;:Real}}}} where T&lt;:Crystalline.AbstractIrrep"><code>Crystalline.subduction_count</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subduction_count(Dᴳᵢ, Dᴴⱼ[, αβγᴴⱼ]) --&gt; Int</code></pre><p>For two groups <span>$G$</span> and <span>$H$</span>, where <span>$H$</span> is a subgroup of <span>$G$</span>, i.e. <span>$H&lt;G$</span>, with associated irreducible representations <code>Dᴳᵢ</code> = <span>$D^G_i(g)$</span> and <code>Dᴴⱼ</code> = <span>$D^H_j(g)$</span> over operations <span>$g∈G$</span> and <span>$h∈H&lt;G$</span>, compute the compatibility relation between the two irreps from the subduction reduction formula (or &quot;magic&quot; formula/Schur orthogonality relation), returning how many times <span>$n^{GH}_{ij}$</span> the subduced representation <span>$D^G_i↓H$</span> contains  the irrep <span>$D^H_j$</span>; in other words, this gives the compatibility between the two irreps.</p><p>Optionally, a vector <code>αβγᴴⱼ</code> may be provided, to evaluate the characters/irreps  of <code>Dᴳᵢ</code> at a concrete value of <span>$(α,β,γ)$</span>. This is e.g. meaningful for <code>LGIrrep</code>s at non-special <strong>k</strong>-vectors. Defaults to <code>nothing</code>.</p><p>The result is computed using the reduction formula [see e.g. Eq. (15) of <a href="https://arxiv.org/abs/1706.09272">arXiv:1706.09272v2</a>]:</p><p><span>$n^{GH}_{ij} = |H|^{-1} \sum_h \chi^G_i(h)\chi^H_j(h)^*$</span></p><p><strong>Example</strong></p><p>Consider the two compatible <strong>k</strong>-vectors Γ (a point) and Σ (a line) in space group 207:</p><pre><code class="language-jl hljs">lgirsd  = lgirreps(207, Val(3));
Γ_lgirs = lgirsd[&quot;Γ&quot;]; # at Γ ≡ [0.0, 0.0, 0.0]
Σ_lgirs = lgirsd[&quot;Σ&quot;]; # at Σ ≡ [α, α, 0.0]</code></pre><p>We can test their compatibility via:</p><pre><code class="language-jl hljs">[[subduction_count(Γi, Σj) for Γi in Γ_lgirs] for Σj in Σ_lgirs]
&gt; # Γ₁ Γ₂ Γ₃ Γ₄ Γ₅
&gt;  [ 1, 0, 1, 1, 2] # Σ₁
&gt;  [ 0, 1, 1, 2, 1] # Σ₂</code></pre><p>With following enterpretatation for compatibility relations between irreps at Γ and Σ:</p><table><tr><th style="text-align: right">Compatibility relation</th><th style="text-align: right">Degeneracies</th></tr><tr><td style="text-align: right">Γ₁ → Σ₁</td><td style="text-align: right">1 → 1</td></tr><tr><td style="text-align: right">Γ₂ → Σ₂</td><td style="text-align: right">1 → 1</td></tr><tr><td style="text-align: right">Γ₃ → Σ₁ + Σ₂</td><td style="text-align: right">2 → 1 + 1</td></tr><tr><td style="text-align: right">Γ₄ → Σ₁ + 2Σ₂</td><td style="text-align: right">3 → 1 + 2</td></tr><tr><td style="text-align: right">Γ₅ → 2Σ₁ + Σ₂</td><td style="text-align: right">3 → 2 + 1</td></tr></table><p>where, in this case, all the small irreps are one-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/compatibility.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}" href="#Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}"><code>Crystalline.subperiodicgroup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subperiodicgroup(num::Integer, ::Val{D}=Val(3), ::Val{P}=Val(2))
subperiodicgroup(num::Integer, D::Integer, P::Integer)
                                                        --&gt; ::SubperiodicGroup{D,P}</code></pre><p>Return the operations of the subperiodic group <code>num</code> of embedding dimension <code>D</code> and periodicity dimension <code>P</code> as a <code>SubperiodicGroup{D,P}</code>.</p><p>The setting choices are those of the International Tables for Crystallography, Volume E.</p><p>Allowed combinations of <code>D</code> and <code>P</code> and their associated group names are:</p><ul><li><code>D = 3</code>, <code>P = 2</code>: Layer groups (<code>num</code> = 1, …, 80).</li><li><code>D = 3</code>, <code>P = 1</code>: Rod groups (<code>num</code> = 1, …, 75).</li><li><code>D = 2</code>, <code>P = 1</code>: Frieze groups (<code>num</code> = 1, …, 7).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; subperiodicgroup(7, Val(2), Val(1))
SubperiodicGroup{2, 1} ⋕7 (𝓅2mg) with 4 operations:
 1
 2
 {m₁₀|½,0}
 {m₀₁|½,0}</code></pre><p><strong>Data sources</strong></p><p>The symmetry operations returned by this function were originally retrieved from the <a href="https://www.cryst.ehu.es/subperiodic/get_sub_gen.html">Bilbao Crystallographic Database, SUBPERIODIC GENPOS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/assembly/groups/subperiodicgroup.jl#L14-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.surface_basis-Tuple{DirectBasis{3}, AbstractVector{&lt;:Real}}" href="#Crystalline.surface_basis-Tuple{DirectBasis{3}, AbstractVector{&lt;:Real}}"><code>Crystalline.surface_basis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">surface_basis(Rs, n; cartesian=true)</code></pre><p>Compute a basis for the surface-cell obtained from terminating a 3D lattice <code>Rs</code> over a surface surface specified by its normal vector <code>n</code> (or Miller indices if <code>cartesian=false</code>).</p><p><strong>Output</strong></p><p>The function returns a tuple <code>(rs³ᴰ, rs′²ᴰ, P)</code>, whose elements are described below:</p><ul><li><p><code>rs³ᴰ</code>: a <code>DirectBasis{3}</code>, whose first two basis vectors lie in the plane of the surface, and whose third vector is (positively) aligned with the surface normal. All basis vectors correspond to points in the original direct lattice.</p></li><li><p><code>rs′²ᴰ</code>: a <code>DirectBasis{2}</code>, whose basis vectors are given in the local coordinate system of the surface unit cell; effectively, this is <span>$(x,y)$</span>-components of <code>rs³ᴰ</code> after a rotation that takes <code>n</code> to <span>$\hat{\mathbf{z}}$</span>. The first basis vector is aligned with the <span>$\hat{\mathbf{x}}$</span>-direction of the local coordinate system.</p></li><li><p><code>P</code>: a rotation matrix that takes <code>rs³ᴰ</code> to the local <code>n</code>-to-<span>$\hat{\mathbf{z}}$</span> rotated coordinate system of <code>rs′²ᴰ</code>. In particular, defining <code>rs′³ᴰ = transform.(DirectPoint.(rs³ᴰ), Ref(P))</code>, the following  holds: 	- <code>rs′³ᴰ[i] ≈ [rs′²ᴰ[i]..., 0]</code> for <code>i ∈ 1:2</code>, 	- <code>rs′³ᴰ[3]</code> is (positively) aligned with <code>[0,0,1]</code>. To transform the other way, i.e., from surface-local to lattice-global coordinates, simply use <code>P⁻¹ = transpose(P)</code> instead.</p></li></ul><p>The returned basis is right-handed.</p><p><strong>Keyword arguments</strong></p><ul><li><code>cartesian :: Bool = true</code>: whether the surface normal <code>n</code> is specified in Cartesian coordinates (<code>true</code>) or in the basis of the reciprocal lattice vectors (<code>false</code>), i.e., corresponding to the Cartesian vector <code>n[1]*Gs[1] + n[2]*Gs[2] + n[3]*Gs</code> with <code>Gs</code> denoting the Cartesian representation of the reciprocal lattice vectors, i.e., <code>Gs = dualbasis(Rs)</code>. The latter case (<code>false</code>) is a specification of the surface in terms of its Miller indices: the coordinates of <code>n</code> can then equivalently be interpreted as the inverse of the surface&#39;s intercept with each of the axes spanned by <code>Rs</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sgnum = 195; # P23, a cubic lattice

julia&gt; Rs = directbasis(sgnum, 3)
DirectBasis{3} (cubic):
 [1.0, 0.0, 0.0]
 [0.0, 1.0, 0.0]
 [0.0, 0.0, 1.0]

julia&gt; n = [1,1,1]; # project along 111 direction

julia&gt; rs³ᴰ, rs′²ᴰ, P = surface_basis(Rs, n; cartesian=true);

julia&gt; rs³ᴰ # the surface basis in the original coordinate system
DirectBasis{3} (hexagonal):
 [1.0, -1.5700924586837747e-16, -0.9999999999999998]
 [-0.9999999999999998, 0.9999999999999997, 0.0]
 [1.0, 1.0, 1.0]

julia&gt; rs′²ᴰ # the in-plane surface vectors in a local &quot;surface coordinate system&quot;
DirectBasis{2} (hexagonal):
 [1.414213562373095, 0.0]
 [-0.7071067811865475, 1.2247448713915887]

julia&gt; DirectBasis(transform.(DirectPoint.(rs³ᴰ), Ref(P))) # from rs³ᴰ to rs′²ᴰ coordinates 
DirectBasis{3} (hexagonal):
 [1.414213562373095, -1.1102230246251563e-16, 0.0]
 [-0.7071067811865476, 1.2247448713915885, 0.0]
 [0.0, -1.1102230246251563e-16, 1.7320508075688772]</code></pre><div class="admonition is-warning" id="Warning-6f7f8e6cded745ac"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6f7f8e6cded745ac" title="Permalink"></a></header><div class="admonition-body"><p>This function will likely be moved from Crystalline to Bravais.jl at some point in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/surface_unitcell.jl#L69-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.symmetry_indicators-Tuple{AbstractVector{&lt;:Integer}, Smith}" href="#Crystalline.symmetry_indicators-Tuple{AbstractVector{&lt;:Integer}, Smith}"><code>Crystalline.symmetry_indicators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetry_indicators(
    n::AbstractVector{&lt;:Integer},
    F::Smith;
    allow_incompatible,
    allow_negative
) -&gt; Any
</code></pre><p>Return the symmetry indicator indices of a symmetry vector <code>n</code>, in the context of a set of elementary band representations (EBRs) <code>brs</code>, provided as a <code>Collection{&lt;:NewBandRep}</code>, a <code>BandRepSet</code>, a <code>Matrix{&lt;:Integer}</code>, or a <code>Smith</code> decomposition thereof.</p><p>In detail, the method returns the nontrivial indices <span>$[\nu_1, \ldots, \nu_n]$</span> associated with the symmetry indicator group (see, <a href="#Crystalline.indicator_group-Tuple{Smith}"><code>indicator_group</code></a>) <span>$[\lambda_1, \ldots, \lambda_n]$</span> of the EBR basis. The indices <span>$\nu_i$</span> are elements of a cyclic group of order <span>$\lambda_i$</span>, i.e.  <span>$\nu_i ∈ \mathbb{Z}_{\lambda_i} = \{0, 1, \ldots, \lambda_i-1\}$</span>.</p><p>See also <code>calc_topology</code> to determine whether any symmetry indicator is nonzero (i.e., whether the symmetry vector is topologically nontrivial).</p><p><strong>Implementation</strong></p><p>The indices are computed using the Smith normal decomposition <span>$\mathbf{B} = \mathbf{S} \boldsymbol{\Lambda}\mathbf{T}$</span> of the EBR matrix <span>$\mathbf{B}$</span>.  Specifically, denoting by <span>$\mathbf{s}_i^{-1}$</span> the <span>$i$</span>th nontrivial row of <span>$\mathbf{S}^{-1}$</span>, the symmetry indicator topological indices of a symmetry vector <span>$\mathbf{n}$</span> are computed as <span>$\nu_i = \mathbf{s}_i^{-1}\mathbf{n}$</span>.<sup class="footnote-reference"><a id="citeref-HCP" href="#footnote-HCP">[HCP]</a></sup></p><p><strong>Keyword arguments</strong></p><p>If <code>n</code> is not a compatible band structure (i.e., if <code>iscompatible(n, brs) = false</code>), an error is thrown. This behavior can be controlled by two boolean keyword arguments:</p><ul><li><code>allow_incompatible</code> (<code>false</code>): if <code>true</code>, disables the compatibility check entirely.</li><li><code>allow_negative</code> (<code>false</code>): if <code>true</code>, allows negative symmetry content, but maintain requirement that <code>n</code> respects the compatibilty relations in an algebraic sense.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/tqc_analysis.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.translation-Tuple{Crystalline.AbstractOperation}" href="#Crystalline.translation-Tuple{Crystalline.AbstractOperation}"><code>Crystalline.translation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translation(op::AbstractOperation{D}) --&gt; SVector{D, Float64}</code></pre><p>Return the <code>D</code>-dimensional translation part of <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.wyckoffs-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D" href="#Crystalline.wyckoffs-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D"><code>Crystalline.wyckoffs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wyckoffs(sgnum::Integer) -&gt; Vector{WyckoffPosition{3}}
wyckoffs(sgnum::Integer, ::Val{D}) -&gt; Any
</code></pre><p>Return the Wyckoff positions of space group <code>sgnum</code> in dimension <code>D</code> as a  <code>Vector{WyckoffPosition{D}</code>.</p><p>The positions are given in the conventional basis setting, following the conventions of the Bilbao Crystallographic Server (from which the underlying data is sourced <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; wps = wyckoffs(16, 2)
4-element Vector{WyckoffPosition{2}}:
 6d: [α, β]
 3c: [1/2, 0]
 2b: [1/3, 2/3]
 1a: [0, 0]</code></pre><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/wyckoff.jl#L4">source</a></section></article><h2 id="Exported-macros"><a class="docs-heading-anchor" href="#Exported-macros">Exported macros</a><a id="Exported-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-macros" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.@S_str-Tuple{Any}" href="#Crystalline.@S_str-Tuple{Any}"><code>Crystalline.@S_str</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S&quot;...&quot; --&gt; SymOperation</code></pre><p>Construct a <code>SymOperation</code> from a triplet form given as a string.</p><p>The expressions specify coordinate mappings from initial positions <code>x,y,z</code> (reduced  coordinates relative to lattice basis) with constant terms as translations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S&quot;-y,x&quot;
4⁺ ──────────────────────────────── (-y,x)
 ┌ 0 -1 ╷ 0 ┐
 └ 1  0 ╵ 0 ┘

julia&gt; S&quot;x,-y,z+1/2&quot;
{m₀₁₀|0,0,½} ──────────────── (x,-y,z+1/2)
 ┌ 1  0  0 ╷   0 ┐
 │ 0 -1  0 ┆   0 │
 └ 0  0  1 ╵ 1/2 ┘</code></pre><p>See also <a href="../bravais/#SymOperation"><code>SymOperation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/symops.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.@composite-Tuple{Any}" href="#Crystalline.@composite-Tuple{Any}"><code>Crystalline.@composite</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@composite cᵢ*brs[i] + cⱼ*brs[j] + … + cₖ*brs[k]</code></pre><p>A convenience macro for creating an integer-coefficient <code>CompositeBandRep</code> from an expression involving a single band representation variable, say <code>brs</code> of type <code>Collection{&lt;:NewBandRep}</code> via references to its elements <code>brs[i]</code> and associated literal integer-coefficients <code>cᵢ</code>.</p><p>More explicitly, <code>@composite cᵢ*brs[i] + cⱼ*brs[j] + … + cₖ*brs[k]</code> creates a <code>CompositeBandRep(coefs, brs)</code> with <code>coefs[n]</code> equal to the sum of those <code>cᵢ</code> for which <code>i == n</code>.</p><p>See also <a href="#Crystalline.CompositeBandRep"><code>CompositeBandRep</code></a> and <a href="../internal-api/#Crystalline.CompositeBandRep_from_indices-Tuple{Vector{Int64}, Collection{&lt;:NewBandRep}}"><code>Crystalline.CompositeBandRep_from_indices</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; brs = calc_bandreps(2, Val(3));

julia&gt; cbr = @composite 3brs[1] + 2brs[2] - brs[3] - brs[4]
16-irrep CompositeBandRep{3}:
 3(1h|Ag) + 2(1h|Aᵤ) - (1g|Ag) - (1g|Aᵤ) (3 bands)

julia&gt; n = 3brs[1] + 2brs[2] - brs[3] - brs[4]
16-irrep SymmetryVector{3}:
 [Z₁⁺+2Z₁⁻, Y₁⁺+2Y₁⁻, 2U₁⁺+U₁⁻, X₁⁺+2X₁⁻, 2T₁⁺+T₁⁻, 2Γ₁⁺+Γ₁⁻, 2V₁⁺+V₁⁻, R₁⁺+2R₁⁻] (3 bands)

julia&gt; SymmetryVector(cbr) == n
true</code></pre><p>Coefficients can be positive or negative integers, multiplied onto band representations from the left or right; if from the left, <code>*</code> can be omitted:</p><pre><code class="language-julia-repl hljs">julia&gt; @composite -brs[1] + brs[2]*3 - brs[7]*(-2) + (-3)*brs[end-2]
16-irrep CompositeBandRep{3}:
 -(1h|Ag) + 3(1h|Aᵤ) + 2(1e|Ag) - 3(1b|Aᵤ) (1 band)</code></pre><p><strong>Limitations</strong></p><ul><li>Coefficients must literals: i.e., terms like <code>c*brs[1]</code> involving some variable <code>c</code> are not supported.</li><li>Coefficients must be integers: i.e., rational coefficients are not supported.</li><li>Coefficients cannot be expressions: i.e., terms like <code>(2+2)brs[1]</code>, <code>22*2brs[1]</code>, or <code>2*brs[3]*4</code> are not supported and will result in undefined behavior, including silently wrong results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/types_symmetryvectors.jl#L643-L688">source</a></section></article><h2 id="Exported-constants"><a class="docs-heading-anchor" href="#Exported-constants">Exported constants</a><a id="Exported-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-constants" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.ENANTIOMORPHIC_PAIRS" href="#Crystalline.ENANTIOMORPHIC_PAIRS"><code>Crystalline.ENANTIOMORPHIC_PAIRS</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ENANTIOMORPHIC_PAIRS :: NTuple{11, Pair{Int,Int}}</code></pre><p>Return the space group numbers of the 11 enantiomorphic space group pairs in 3D.</p><p>The space group types associated with each such pair <code>(sgnum, sgnum&#39;)</code> are related by a mirror transformation: i.e. there exists a transformation  <span>$\mathbb{P} = \{\mathbf{P}|\mathbf{p}\}$</span> between the two groups <span>$G = \{g\}$</span> and <span>$G&#39; = \{g&#39;\}$</span> such that <span>$G&#39; = \mathbb{P}^{-1}G\mathbb{P}$</span> where <span>$\mathbf{P}$</span> is improper (i.e. <span>$\mathrm{det}\mathbf{P} &lt; 0$</span>).</p><p>We define distinct space group <em>types</em> as those that cannot be related by a proper transformation (i.e. with <span>$\mathrm{det}\mathbf{P} &gt; 0$</span>). With that view, there are 230 space group types. If the condition is relaxed to allow improper rotations, there are  <span>$230-11 = 219$</span> distinct <em>affine</em> space group types. See e.g. ITA5 Section 8.2.2.</p><p>The enantiomorphic space group types are also chiral space group types in 3D. There are no enantiomorphic pairs in lower dimensions; in 3D all enantiomorphic pairs involve screw symmetries, whose direction is inverted between pairs (i.e. have opposite handedness).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/constants.jl#L64-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.MAX_MSGNUM" href="#Crystalline.MAX_MSGNUM"><code>Crystalline.MAX_MSGNUM</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MAX_MSGNUM :: Tuple{Int,Int,Int}</code></pre><p>Analogous to <code>MAX_SUBGNUM</code>, but for the number of magnetic space groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/constants.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.MAX_MSUBGNUM" href="#Crystalline.MAX_MSUBGNUM"><code>Crystalline.MAX_MSUBGNUM</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MAX_MSUBGNUM :: Tuple{Int,Int,Int}</code></pre><p>Analogous to <code>MAX_SUBGNUM</code>, but for the number of magnetic subperiodic groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/constants.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.MAX_SGNUM" href="#Crystalline.MAX_SGNUM"><code>Crystalline.MAX_SGNUM</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MAX_SGNUM :: Tuple{Int,Int,Int}</code></pre><p>Return the number of distinct space group types across dimensions 1, 2, and 3 (indexable by dimensionality).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/constants.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Crystalline.MAX_SUBGNUM" href="#Crystalline.MAX_SUBGNUM"><code>Crystalline.MAX_SUBGNUM</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MAX_SUBGNUM :: ImmutableDict</code></pre><p>An immutable dictionary with values <code>v::Int</code> and keys <code>k::Tuple{Int,Int}</code>, where <code>v</code> is the number of distinct subperiodic group types for a given key <code>k = (D,P)</code> describing a subperiodic group of dimensionality <code>D</code> and periodicity <code>P</code>:</p><ul><li>layer groups: <code>(D,P) = (3,2)</code></li><li>rod groups: <code>(D,P) = (3,1)</code></li><li>frieze groups: <code>(D,P) = (2,1)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/68595671a2fccc0a4864b7305f6e2abed289b5f5/src/constants.jl#L13-L23">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.</li><li class="footnote" id="footnote-ITA6"><a class="tag is-link" href="#citeref-ITA6">ITA6</a>M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Mulliken, Report on Notation for the Spectra of Polyatomic Molecules,    <a href="https://doi.org/10.1063/1.1740655">J. Chem. Phys. <em>23</em>, 1997 (1955)</a>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Bilbao Crystallographic Database&#39;s   <a href="https://www.cryst.ehu.es/cgi-bin/cryst/programs/representations_point.pl?tipogrupo=spg">Representations PG program</a>.</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Cracknell, Davies, Miller, &amp; Love, Kronecher Product Tables 1 (1979).</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Bilbao Crystallographic Database&#39;s   <a href="https://www.cryst.ehu.es/cgi-bin/cryst/programs/representations_point.pl?tipogrupo=spg">Representations PG program</a>.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Elcoro et al.,    <a href="https://doi.org/10.1107/S1600576717011712">J. of Appl. Cryst. <strong>50</strong>, 1457 (2017)</a></li><li class="footnote" id="footnote-HCP"><a class="tag is-link" href="#citeref-HCP">HCP</a><a href="https://doi.org/10.1088/1361-648X/ab7adb">H.C. Po, J. Phys. Cond. Matter <strong>32</strong>, 263001 (2020)</a>.</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Aroyo, <em>et al.</em>,   <a href="https://doi.org/0.1524/zkri.2006.221.1.15">Z. Kristallogr. <strong>221</strong>, 15-27 (2006)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lattices/">« Lattices</a><a class="docs-footer-nextpage" href="../internal-api/">Internal API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 20 October 2025 07:07">Monday 20 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
