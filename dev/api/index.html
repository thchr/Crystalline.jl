<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Â· Crystalline</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Crystalline</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Exported-types"><span>Exported types</span></a></li><li><a class="tocitem" href="#Exported-methods"><span>Exported methods</span></a></li><li><a class="tocitem" href="#Exported-constants"><span>Exported constants</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/thchr/Crystalline.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><hr/><h2 id="Exported-types"><a class="docs-heading-anchor" href="#Exported-types">Exported types</a><a id="Exported-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Crystalline.BandRep" href="#Crystalline.BandRep"><code>Crystalline.BandRep</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BandRep &lt;: AbstractArray{Int64,1}</code></pre><ul><li><p><code>wyckpos::String</code></p></li><li><p><code>sitesym::String</code></p></li><li><p><code>label::String</code></p></li><li><p><code>dim::Integer</code></p></li><li><p><code>decomposable::Bool</code></p></li><li><p><code>spinful::Bool</code></p></li><li><p><code>irvec::Array{Int64,1}</code></p></li><li><p><code>irlabs::Array{String,1}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L599-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.BandRepSet" href="#Crystalline.BandRepSet"><code>Crystalline.BandRepSet</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BandRepSet &lt;: AbstractArray{BandRep,1}</code></pre><ul><li><p><code>sgnum::Int64</code></p></li><li><p><code>bandreps::Array{BandRep,1}</code></p></li><li><p><code>kvs::Array{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:KVec</code></p></li><li><p><code>klabs::Array{String,1}</code></p></li><li><p><code>irlabs::Array{String,1}</code></p></li><li><p><code>allpaths::Bool</code></p></li><li><p><code>spinful::Bool</code></p></li><li><p><code>timeinvar::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L635-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.CharacterTable" href="#Crystalline.CharacterTable"><code>Crystalline.CharacterTable</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CharacterTable{D}</code></pre><ul><li><p><code>ops::Array{SymOperation{D},1} where D</code></p></li><li><p><code>irlabs::Array{String,1}</code></p></li><li><p><code>chartable::Array{Complex{Float64},2}</code></p></li><li><p><code>tag::String</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L557-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.CharacterTable-Union{Tuple{AbstractArray{var&quot;#s15&quot;,1} where var&quot;#s15&quot;&lt;:Crystalline.AbstractIrrep{D}}, Tuple{D}, Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:Crystalline.AbstractIrrep{D},Union{Nothing, AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real}}} where D" href="#Crystalline.CharacterTable-Union{Tuple{AbstractArray{var&quot;#s15&quot;,1} where var&quot;#s15&quot;&lt;:Crystalline.AbstractIrrep{D}}, Tuple{D}, Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:Crystalline.AbstractIrrep{D},Union{Nothing, AbstractArray{var&quot;#s54&quot;,1} where var&quot;#s54&quot;&lt;:Real}}} where D"><code>Crystalline.CharacterTable</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CharacterTable(irs::AbstractVector{&lt;:AbstractIrrep}, Î±Î²Î³=nothing)</code></pre><p>Returns a <code>CharacterTable</code> associated with vector of <code>AbstractIrrep</code>s <code>irs</code>. </p><p>Optionally, an <code>Î±Î²Î³::AbstractVector{&lt;:Real}</code> variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for <code>LGIrrep</code>s, a concrete k-vector sampled from a &quot;line-irrep&quot;). Defaults to <code>nothing</code>, indicating it being either  irrelevant (e.g., for <code>PGIrrep</code>s) or all free parameters implicitly set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L577-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.DirectBasis" href="#Crystalline.DirectBasis"><code>Crystalline.DirectBasis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DirectBasis{D} &lt;: Basis{D}</code></pre><ul><li><code>vecs::NTuple{D, SVector{D, Float64}}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D" href="#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>Crystalline.KVec</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">KVec{D}(str::AbstractString) --&gt; KVec{D}
KVec(str::AbstractString)    --&gt; KVec
KVec(::AbstractVector, ::AbstractMatrix) --&gt; KVec</code></pre><p>Return a <code>KVec</code> by parsing the string representations <code>str</code>, supplied in one of the following formats:</p><pre><code class="language-jl">&quot;($1,$2,$3)&quot;
&quot;[$1,$2,$3]&quot;
&quot;$1,$2,$3&quot;</code></pre><p>where the coordinates <code>$1</code>,<code>$2</code>, and <code>$3</code> are strings that may contain fractions, decimal numbers, and &quot;free&quot; parameters {<code>&#39;Î±&#39;</code>,<code>&#39;Î²&#39;</code>,<code>&#39;Î³&#39;</code>} (or, alternatively and equivalently, {<code>&#39;u&#39;</code>,<code>&#39;v&#39;</code>,<code>&#39;w&#39;</code>} or {<code>&#39;x&#39;</code>,<code>&#39;y&#39;</code>,<code>&#39;z&#39;</code>}).</p><p>Fractions such as <code>1/2</code> and decimal numbers can be parsed: but use of any other special operator besides <code>/</code> will produce undefined behavior (e.g. do not use <code>*</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; KVec(&quot;0.25,Î±,0&quot;)
[0.25, Î±, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L240-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.LGIrrep" href="#Crystalline.LGIrrep"><code>Crystalline.LGIrrep</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LGIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>lg::LittleGroup{D} where D</code></p></li><li><p><code>matrices::Array{Array{Complex{Float64},2},1}</code></p></li><li><p><code>translations::Array{Array{Float64,1},1}</code></p></li><li><p><code>type::Int64</code></p></li><li><p><code>iscorep::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L445-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.LittleGroup" href="#Crystalline.LittleGroup"><code>Crystalline.LittleGroup</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LittleGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>kv::KVec{D} where D</code></p></li><li><p><code>klab::String</code></p></li><li><p><code>operations::Array{SymOperation{D},1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L384-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.ModulatedFourierLattice" href="#Crystalline.ModulatedFourierLattice"><code>Crystalline.ModulatedFourierLattice</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModulatedFourierLattice{D} &lt;: AbstractFourierLattice{D}</code></pre><p>A <code>D</code>-dimensional concrete Fourier/plane wave lattice, derived from  a <a href="@ref"><code>UnityFourierLattice</code></a> by scaling/modulating its orbit coefficients  by complex numbers; in general, the coefficients do not have unit norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.MultTable" href="#Crystalline.MultTable"><code>Crystalline.MultTable</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MultTable{D} &lt;: AbstractArray{Int64,2}</code></pre><ul><li><p><code>operations::Array{SymOperation{D},1} where D</code></p></li><li><p><code>table::Array{Int64,2}</code></p></li><li><p><code>isgroup::Bool</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L136-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.MultTable-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D" href="#Crystalline.MultTable-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D"><code>Crystalline.MultTable</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MultTable(ops::AbstractVector{&lt;:SymOperation{D}}, modÏ„=true, verbose=false)</code></pre><p>Compute the multiplication (or Cayley) table of <code>ops</code>, an <code>AbstractVector</code> of <code>SymOperation{D}</code>s. The <code>modÏ„</code> keyword argument controls whether composition of operations is taken modulo lattice vectors (<code>true</code>, default) or not (<code>false</code>).</p><p>A <code>MultTable{D}</code> is returned, which contains symmetry operations resulting from composition  of <code>row âˆ˜ col</code> operators; the table of indices give the symmetry operators relative to the ordering of <code>ops</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L300-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.PGIrrep" href="#Crystalline.PGIrrep"><code>Crystalline.PGIrrep</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PGIrrep{D} &lt;: Crystalline.AbstractIrrep{D}</code></pre><ul><li><p><code>cdml::String</code></p></li><li><p><code>pg::PointGroup{D} where D</code></p></li><li><p><code>matrices::Array{Array{Complex{Float64},2},1}</code></p></li><li><p><code>type::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L426-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.PointGroup" href="#Crystalline.PointGroup"><code>Crystalline.PointGroup</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PointGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>label::String</code></p></li><li><p><code>operations::Array{SymOperation{D},1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L372-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D" href="#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D"><code>Crystalline.RVec</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">RVec{D}(str::AbstractString) --&gt; RVec{D}
RVec(str::AbstractString)    --&gt; RVec
RVec(::AbstractVector, ::AbstractMatrix) --&gt; RVec</code></pre><p>Return a <code>RVec</code> by parsing the string representations <code>str</code>, supplied in one of the following formats:</p><pre><code class="language-jl">&quot;($1,$2,$3)&quot;
&quot;[$1,$2,$3]&quot;
&quot;$1,$2,$3&quot;</code></pre><p>where the coordinates <code>$1</code>,<code>$2</code>, and <code>$3</code> are strings that may contain fractions, decimal numbers, and &quot;free&quot; parameters {<code>&#39;Î±&#39;</code>,<code>&#39;Î²&#39;</code>,<code>&#39;Î³&#39;</code>} (or, alternatively and equivalently, {<code>&#39;u&#39;</code>,<code>&#39;v&#39;</code>,<code>&#39;w&#39;</code>} or {<code>&#39;x&#39;</code>,<code>&#39;y&#39;</code>,<code>&#39;z&#39;</code>}).</p><p>Fractions such as <code>1/2</code> and decimal numbers can be parsed: but use of any other special operator besides <code>/</code> will produce undefined behavior (e.g. do not use <code>*</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; RVec(&quot;0.25,Î±,0&quot;)
[0.25, Î±, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L240-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.ReciprocalBasis" href="#Crystalline.ReciprocalBasis"><code>Crystalline.ReciprocalBasis</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReciprocalBasis{D} &lt;: Basis{D}</code></pre><ul><li><code>vecs::NTuple{D, SVector{D, Float64}}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.SiteGroup-Union{Tuple{D}, Tuple{SpaceGroup{D},WyckPos{D}}} where D" href="#Crystalline.SiteGroup-Union{Tuple{D}, Tuple{SpaceGroup{D},WyckPos{D}}} where D"><code>Crystalline.SiteGroup</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SiteGroup(sg, wp)
</code></pre><p>Return the site symmetry group <code>g::SiteGroup</code> for a Wyckoff position <code>wp</code> in space group <code>sg</code> (or with space group number <code>sgnum</code>; in this case, the dimensionality is inferred from <code>wp</code>).</p><p><code>g</code> contains as operations that are isomorphic to the those contained in <code>sg</code> (in the sense that they might differ by lattice vectors) that leave the Wyckoff position <code>wp</code> invariant, such that <code>all(op -&gt; wp == opâˆ˜wp, g)</code> is true.</p><p>The returned <code>SiteGroup</code> also contains the coset representatives of the Wyckoff position (that are again isomorphic to those featured in <code>sg</code>), accessible via <a href="#Crystalline.cosets-Tuple{SiteGroup}"><code>cosets</code></a>, which \eg generate the orbit of the Wyckoff position (see <a href="#Crystalline.orbit-Tuple{AbstractArray{var&quot;#s129&quot;,1} where var&quot;#s129&quot;&lt;:(AbstractArray{var&quot;#s128&quot;,2} where var&quot;#s128&quot;&lt;:Real),AbstractArray{var&quot;#s127&quot;,1} where var&quot;#s127&quot;&lt;:Real}"><code>orbit(::SiteGroup, ::WyckPos)</code></a>) and define a left-coset decomposition of <code>sg</code> jointly with the elements in <code>g</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sgnum = 16; D = 2;

julia&gt; wp = get_wycks(sgnum, D)[3] # pick a Wyckoff position
2b: [0.3333333333333333, 0.6666666666666666]

julia&gt; sg = spacegroup(sgnum, D);

julia&gt; g  = SiteGroup(sg, wp)
SiteGroup{2} #16 at 2b = [0.333333, 0.666667] with 3 operations:
 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (x,y)
 {3âº|1,1} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (-y+1,x-y+1)
 {3â»|0,1} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (-x+y,-x+1)</code></pre><p>The group structure of a <code>SiteGroup</code> can be inspected with <code>MultTable</code>:</p><pre><code class="language-julia-repl">julia&gt; MultTable(g)
3Ã—3 MultTable{2}:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          â”‚        1  {3âº|1,1}  {3â»|0,1} 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        1 â”‚        1  {3âº|1,1}  {3â»|0,1} 
 {3âº|1,1} â”‚ {3âº|1,1}  {3â»|0,1}         1
 {3â»|0,1} â”‚ {3â»|0,1}         1  {3âº|1,1}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></pre><p>The original space group can be reconstructed from a left-coset decomposition, using the operations and cosets contained in a <code>SiteGroup</code>:</p><pre><code class="language-julia-repl">julia&gt; ops = [opÊ°âˆ˜opáµ for opÊ° in cosets(g) for opáµ in g];

julia&gt; Set(sg) == Set(ops)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/wyckoff.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.SpaceGroup" href="#Crystalline.SpaceGroup"><code>Crystalline.SpaceGroup</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SpaceGroup{D} &lt;: Crystalline.AbstractGroup{D}</code></pre><ul><li><p><code>num::Int64</code></p></li><li><p><code>operations::Array{SymOperation{D},1} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L362-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.SymOperation" href="#Crystalline.SymOperation"><code>Crystalline.SymOperation</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SymOperation{D} &lt;: AbstractArray{Float64,2}</code></pre><ul><li><p><code>rotation::Crystalline.SquareStaticMatrices.SqSMatrix{D,Float64} where D</code></p></li><li><p><code>translation::StaticArrays.SArray{Tuple{D},Float64,1,D} where D</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L59-L61">source</a></section></article><h2 id="Exported-methods"><a class="docs-heading-anchor" href="#Exported-methods">Exported methods</a><a id="Exported-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Crystalline.bandreps" href="#Crystalline.bandreps"><code>Crystalline.bandreps</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bandreps(sgnum::Integer, D::Integer=3; 
         allpaths::Bool=false, spinful::Bool=false, timereversal::Bool=true)</code></pre><p>Returns the <code>BandRepSet</code> for space group <code>sgnum</code> (provided by the <a href="http://www.cryst.ehu.es/cgi-bin/cryst/programs/bandrep.pl">Bilbao Crystallographic Server</a>) and dimension <code>D</code>.</p><p>Keyword arguments:</p><ul><li><code>allpaths</code>: include a minimal sufficient set (<code>false</code>, default) or all (<code>true</code>) k-vectors. </li><li><code>spinful</code>: single- (<code>false</code>, default) or double-valued (<code>true</code>) irreps, as appropriate for            spinless and spinful particles, respectively.</li><li><code>timereversal</code>: assume presence (<code>true</code>, default) or absence (<code>false</code>) of time-reversal                 symmetry.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bandrep.jl#L89-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.basisdim-Tuple{BandRepSet}" href="#Crystalline.basisdim-Tuple{BandRepSet}"><code>Crystalline.basisdim</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">basisdim(BRS::BandRepSet) --&gt; Int64</code></pre><p>Computes the dimension of the (linearly independent parts) of a band representation set. This is <span>$d^{\text{bs}} = d^{\text{ai}}$</span> in the notation of Po, Watanabe, &amp; Vishwanath, Nature Commun. <strong>8</strong>, 50 (2017). In other words, this is the number of linearly independent basis vectors that span the expansions of a band structure or atomic insulator viewed as symmetry-data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bandrep.jl#L140-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.calcfourier-Tuple{Any,Crystalline.AbstractFourierLattice}" href="#Crystalline.calcfourier-Tuple{Any,Crystalline.AbstractFourierLattice}"><code>Crystalline.calcfourier</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calcfourier(xyz, flat::AbstractFourierLattice) --&gt; Float64</code></pre><p>Compute the real part of the function evaluation of <code>flat</code> at a point <code>xyz</code> (a tuple, SVector, or a vector), i.e. return     Re[âˆ‘áµ¢ cáµ¢exp(2Ï€iğ†áµ¢â‹…ğ«)] with ğ†áµ¢ denoting a ğ†-vector in an allowed orbit in <code>flat</code>, and  cáµ¢ an associated coefficient (and with ğ« â‰¡ <code>xyz</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L396-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D},DirectBasis{D}}} where D" href="#Crystalline.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D},DirectBasis{D}}} where D"><code>Crystalline.cartesianize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesianize(op::SymOperation{D}, Rs::DirectBasis{D}) --&gt; SymOperation{D}</code></pre><p>Converts <code>opË¡</code> from a lattice basis to a Cartesian basis, by computing the transformed operators <code>opá¶œ = ğ‘*opË¡*ğ‘â»Â¹</code> via the Cartesian basis matrix ğ‘ (whose columns are the <code>DirectBasis</code> vectors <code>Rs[i]</code>). </p><p><strong>Note 1</strong></p><p>The matrix ğ‘ maps vectors coefficients in a lattice basis ğ¯Ë¡ to coefficients in a Cartesian basis ğ¯á¶œ as ğ¯Ë¡ = ğ‘â»Â¹ğ¯á¶œ and vice versa as ğ¯á¶œ = ğ‘ğ¯Ë¡. Since a general transformation P  transforms an &quot;original&quot; vectors with coefficients ğ¯ to new coefficients ğ¯â€² via ğ¯â€² = Pâ»Â¹ğ¯ and since we here here consider the lattice basis as the &quot;original&quot; basis we have P = ğ‘â»Â¹.  As such, the transformation of the operator <code>op</code> transforms as <code>opá¶œ = Pâ»Â¹*opË¡*P</code>, i.e. <code>opá¶œ = transform(opË¡,P) = transform(opË¡,ğ‘â»Â¹)</code>.</p><p><strong>Note 2</strong></p><p>The display (e.g. Seitz and xyzt notation) of <code>SymOperation</code>s e.g. in the REPL implicitly assumes integer coefficients for its point-group matrix: as a consequence, displaying  <code>SymOperation</code>s in a Cartesian basis may produce undefined behavior. The matrix representation remains valid, however.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L660-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.centering" href="#Crystalline.centering"><code>Crystalline.centering</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">centering(sg::SpaceGroup) --&gt; Char
centering(sgnum::Integer, D::Integer=3) --&gt; Char</code></pre><p>Determines the conventional centering type of a given space/plane group <code>sg</code> (alternatively specified by its conventional number <code>sgnum</code> and dimensionality <code>D</code> by comparison with the Hermann-Mauguin notation&#39;s first letter. </p><p>Possible output values, depending on dimensionality <code>D</code>, are (see ITA Sec. 9.1.4):</p><pre><code class="language-none">D=2 â”Œ &#39;p&#39;: no centring (primitive)
    â”” &#39;c&#39;: face centered

D=3 â”Œ &#39;P&#39;: no centring (primitive)
    â”œ &#39;I&#39;: body centred (innenzentriert)
    â”œ &#39;F&#39;: all-face centred
    â”œ &#39;A&#39;, &#39;B&#39;, &#39;C&#39;: one-face centred, (b,c) or (c,a) or (a,b)
    â”” &#39;R&#39;: hexagonal cell rhombohedrally centred</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/notation.jl#L27-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.classification-Tuple{BandRepSet}" href="#Crystalline.classification-Tuple{BandRepSet}"><code>Crystalline.classification</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">classification(BRS::BandRepSet) --&gt; String</code></pre><p>Calculate the symmetry indicator classification of a band representation set, meaning the  index-classification inferrable on the basis of symmetry alone.</p><p>Technically, the calculation answers a question like &quot;what direct product of  <span>$\mathbb{Z}_n$</span> groups is the the quotient group <span>$X^{\text{bs}} = \{\text{BS}\}/\{\text{AI}\}$</span> isomorphic to?&quot;.</p><p>See e.g. Po, Watanabe, &amp; Vishwanath, Nature Commun. <strong>8</strong>, 50 (2017) for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bandrep.jl#L116-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D" href="#Crystalline.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D"><code>Crystalline.conventionalize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conventionalize(flatâ€²::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flatâ€²)</code></pre><p>Given <code>flatâ€²</code> referred to a primitive basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flat</code> referred to the associated conventional basis. </p><p>See also the complementary methods <a href="#Crystalline.transform-Union{Tuple{D}, Tuple{KVec{D},AbstractArray{var&quot;#s131&quot;,2} where var&quot;#s131&quot;&lt;:Real}} where D"><code>transform(::AbstractFourierLattice, ::AbstractMatrix{&lt;:Real})</code></a> and <a href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>primitivize(::AbstractFourierLattice, ::Char)</code></a> for additional details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L296-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.conventionalize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D" href="#Crystalline.conventionalize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D"><code>Crystalline.conventionalize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conventionalize(Rsâ€²::DirectBasis, cntr::Char) --&gt; Rs::DirectBasis</code></pre><p>Transforms a primitive DirectBasis <code>Rsâ€²</code> into its conventional equivalent <code>Rs</code>, with the  transformation dependent on the centering type <code>cntr</code> (P, I, F, R, A, C, and p, c); for centering P and p, the conventional and primive bases coincide.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L463-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.cosets-Tuple{SiteGroup}" href="#Crystalline.cosets-Tuple{SiteGroup}"><code>Crystalline.cosets</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cosets(g)
</code></pre><p>Return the cosets of a <code>SiteGroup</code> <code>g</code>.</p><p>The cosets generate the orbit of the Wyckoff position <code>wyck(g)</code> (see  <a href="#Crystalline.orbit-Tuple{AbstractArray{var&quot;#s129&quot;,1} where var&quot;#s129&quot;&lt;:(AbstractArray{var&quot;#s128&quot;,2} where var&quot;#s128&quot;&lt;:Real),AbstractArray{var&quot;#s127&quot;,1} where var&quot;#s127&quot;&lt;:Real}"><code>orbit(::SiteGroup, ::WyckPos)</code></a>) and furnish a left-coset decomposition of the underlying space group, jointly with the operations in <code>g</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/wyckoff.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.crystal-NTuple{6,Real}" href="#Crystalline.crystal-NTuple{6,Real}"><code>Crystalline.crystal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crystal(a,b,c,Î±,Î²,Î³) --&gt; Rs::DirectBasis{3}</code></pre><p>Calculate basis vectors <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span>, <span>$\mathbf{R}_3$</span> in a 3D Cartesian basis for a right-handed coordinate system with specified basis vector lengths <code>a</code>, <code>b</code>, <code>c</code> (associated with <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span>, &amp; <span>$\mathbf{R}_3$</span>, respectively) and specified interaxial angles  <code>Î±</code> <span>$= âˆ (\mathbf{R}_2,\mathbf{R}_3)$</span>, <code>Î²</code> <span>$= âˆ (\mathbf{R}_3,\mathbf{R}_1)$</span>,  <code>Î³</code> <span>$= âˆ (\mathbf{R}_1,\mathbf{R}_2)$</span>, with <span>$âˆ $</span> denoting the angle between two vectors.</p><p>For definiteness, the <span>$\mathbf{R}_1$</span> basis vector is oriented along the <span>$x$</span>-axis of the Cartesian coordinate system, and the <span>$\mathbf{R}_2$</span> axis is placed in the <span>$xy$</span>-plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.crystal-Tuple{Real,Real,Real}" href="#Crystalline.crystal-Tuple{Real,Real,Real}"><code>Crystalline.crystal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crystal(a,b,Î³) --&gt; DirectBasis{2}</code></pre><p>Calculate basis vectors <span>$\mathbf{R}_1$</span>, <span>$\mathbf{R}_2$</span> in a 2D Cartesian basis for a  right-handed coordinate system with specified basis vector lengths <code>a</code>, <code>b</code> (associated with <span>$\mathbf{R}_1$</span> &amp; <span>$\mathbf{R}_2$</span>, respectively) and specified interaxial angle <code>Î³</code> <span>$= âˆ (\mathbf{R}_1,\mathbf{R}_2)$</span>.</p><p>For definiteness, the <span>$\mathbf{R}_1$</span> basis vector is oriented along the <span>$x$</span>-axis of the Cartesian coordinate system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L36-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.crystal-Tuple{Real}" href="#Crystalline.crystal-Tuple{Real}"><code>Crystalline.crystal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crystal(a)  --&gt; DirectBasis{1}</code></pre><p>Return a one-dimensional crystal with lattice period <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.crystalsystem-Union{Tuple{DirectBasis{D}}, Tuple{D}} where D" href="#Crystalline.crystalsystem-Union{Tuple{DirectBasis{D}}, Tuple{D}} where D"><code>Crystalline.crystalsystem</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crystalsystem(R::DirectBasis{D})</code></pre><p>Determine the crystal system of a point lattice specified in a  <em>conventional</em> <code>DirectBasis{D}</code> of dimension <code>D</code> using Tables 2.1.2.1, 9.1.7.1, &amp; 9.1.7.2 of the International Tables of  Crystallography, Volume 1 (ITA).  There are 4 crystal systems in 2D and 7 in 3D (see ITA 2.1.2(iii)):</p><table><tr><th style="text-align: right"><code>D</code></th><th style="text-align: right">System</th><th style="text-align: right">Conditions</th><th style="text-align: right">Free parameters</th></tr><tr><td style="text-align: right"><em>1D</em></td><td style="text-align: right">linear</td><td style="text-align: right">none</td><td style="text-align: right">a</td></tr><tr><td style="text-align: right"><em>2D</em></td><td style="text-align: right">square</td><td style="text-align: right">a=b &amp; Î³=90Â°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">rectangular</td><td style="text-align: right">Î³=90Â°</td><td style="text-align: right">a,b</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">hexagonal</td><td style="text-align: right">a=b &amp; Î³=120Â°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">oblique</td><td style="text-align: right">none</td><td style="text-align: right">a,b,Î³</td></tr><tr><td style="text-align: right"><em>3D</em></td><td style="text-align: right">cubic</td><td style="text-align: right">a=b=c &amp; Î±=Î²=Î³=90Â°</td><td style="text-align: right">a</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">hexagonal</td><td style="text-align: right">a=b &amp; Î±=Î²=90Â° &amp; Î³=120Â°</td><td style="text-align: right">a,c</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">trigonal</td><td style="text-align: right">a=b &amp; Î±=Î²=90Â° &amp; Î³=120Â°</td><td style="text-align: right">a,c (a,Î± for hR)</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">tetragonal</td><td style="text-align: right">a=b &amp; Î±=Î²=Î³=90Â°</td><td style="text-align: right">a,c</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">orthorhombic</td><td style="text-align: right">Î±=Î²=Î³=90Â°</td><td style="text-align: right">a,b,c</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">monoclinic</td><td style="text-align: right">Î±=Î³=90Â°</td><td style="text-align: right">a,b,c,Î²â‰¥90Â°</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">triclinic</td><td style="text-align: right">none</td><td style="text-align: right">a,b,c,Î±,Î²,Î³</td></tr></table><p>The DirectBasis input is assumed to use <em>conventional</em> basis vectors;  i.e. not necessarily primitive. For primitive basis vectors, the  crystal system can be further reduced into 5 Bravais types in 2D and 14 in 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L79-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.dim-Tuple{BandRep}" href="#Crystalline.dim-Tuple{BandRep}"><code>Crystalline.dim</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dim(BR::BandRep) --&gt; Int64</code></pre><p>Get the number of bands included in a single BandRep <code>BR</code>; i.e. the &quot;band filling&quot; Î½ discussed in Po&#39;s papers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L619-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.directbasis-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D" href="#Crystalline.directbasis-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>Crystalline.directbasis</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">directbasis(sgnum, D=3;    abclims, Î±Î²Î³lims)
directbasis(sgnum, Val(D); abclims, Î±Î²Î³lims) --&gt; DirectBasis{D}</code></pre><p>Generates a (conventional) DirectBasis for a crystal compatible with  the space group number <code>sgnum</code> and dimensionality <code>D</code>. Free parameters in the lattice vectors are chosen randomly, with limits optionally supplied in <code>abclims</code> (lengths) and <code>Î±Î²Î³lims</code> (angles). By convention, the length of the first lattice vector (= <code>a</code>) is set to unity, such that the second and third (= <code>b</code> and <code>c</code>) lattice  vectors&#39; lengths are relative to the first.</p><p>Limits on the relative uniform distribution of lengths <code>b</code> and <code>c</code> can be specified as 2-tuple kwarg <code>abclims</code>; similarly, limits on  the angles <code>Î±</code>, <code>Î²</code>, <code>Î³</code> can be set via Î±Î²Î³lims (only affects  oblique, monoclinic, &amp; triclinic lattices).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L208-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.find_representation" href="#Crystalline.find_representation"><code>Crystalline.find_representation</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_representation(symvals::AbstractVector{Number}, 
                    lgirs::AbstractVector{&lt;:AbstractIrrep},
                    Î±Î²Î³::Union{AbstractVector{&lt;:Real},Nothing}=nothing,
                    assert_return_T::Type{&lt;:Union{Integer, AbstractFloat}}=Int))

                    --&gt; Vector{assert_return_T}</code></pre><p>From a vector (or vector of vectors) of symmetry eigenvalues <code>symvals</code> sampled along all the operations of a group gáµ¢, whose irreps are contained in <code>irs</code> (evaluated with optional free  parameters <code>Î±Î²Î³</code>), return the multiplicities of each irrep.</p><p>Optionally, the multiciplities&#39; element type can be specified via the <code>assert_return_T</code> argument (performing checked conversion; returns <code>nothing</code> if representation in  <code>assert_return_T</code> is impossible). This can be useful if one suspects a particular band to  transform like a fraction of an irrep (i.e., the specified symmetry data is incomplete).</p><p><strong>Extended help</strong></p><p>Effectively, this applies the projection operator Pâ½Ê²â¾ of each irrep&#39;s character set Ï‡â½Ê²â¾(gáµ¢) (j = 1, ... , Nâ±Ê³Ê³) to the symmetry data sáµ¢ â‰¡ <code>symvals</code>:</p><pre><code class="language-none">Pâ½Ê²â¾  â‰¡ (dâ±¼/|g|) âˆ‘áµ¢ Ï‡â½Ê²â¾(gáµ¢)*gáµ¢         [characters Ï‡â½Ê²â¾(gáµ¢), irrep dimension dâ±¼]
Pâ½Ê²â¾s = (dâ±¼/|g|) âˆ‘áµ¢ Ï‡â½Ê²â¾(gáµ¢)*sáµ¢ = nâ±¼,   [number of bands that transform like jth irrep]</code></pre><p>returning the irrep multiplicities mâ±¼ â‰¡ nâ±¼/dâ±¼.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symeigs2irrep.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D" href="#Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D"><code>Crystalline.generate</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Generate a group from a finite set of generators <code>gens</code>. Returns a <code>GenericGroup</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>modÏ„</code> (default, <code>true</code>): the group composition operation can either be taken modulo lattice vectors (<code>true</code>) or not (<code>false</code>, useful e.g. for site symmetry groups). In this case, the provided generators will also be taken modulo integer lattice translations.</li><li><code>Nmax</code> (default, <code>256</code>): the maximum size of the generated group. This is essentially a cutoff set to ensure halting of execution in case the provided set of generators do not define a <em>finite</em> group (especially relevant if <code>modÏ„=false</code>). If more operations than <code>Nmax</code> are generated, the method throws an overflow error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L832-L845">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile},Union{Nothing, JLD2.JLDFile}}} where D" href="#Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile},Union{Nothing, JLD2.JLDFile}}} where D"><code>Crystalline.get_lgirreps</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_lgirreps(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3))
                                                -&gt; Dict{String, Vector{LGIrrep{D}}}</code></pre><p>For given space group number <code>sgnum</code> and dimension <code>D</code>, return the associated little group (or &quot;small&quot;) irreps (<code>LGIrrep{D}</code>s) at high-symmetry k-points, lines, and planes. </p><p>Returns a <code>Dict</code> with little group <strong>k</strong>-point labels as keys and vectors of <code>LGIrrep{D}</code>s as values.</p><p><strong>Notes</strong></p><ul><li>Currently, only <code>D = 3</code> is supported.</li><li>The returned irreps are complex in general. Real irreps (as needed in time-reversal invariant settings) can subsequently be obtained with the <a href="#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D},1}}, Tuple{D}, Tuple{AbstractArray{LGIrrep{D},1},Bool}} where D"><code>realify</code></a> method.</li><li>Returned irreps are spinless.</li></ul><p><strong>References</strong></p><p>The underlying data is sourced from the ISOTROPY ISO-IR dataset. If used in research, please cite the original reference material associated with ISO-IR:</p><ul><li>Stokes, Hatch, &amp; Campbell, <a href="https://stokes.byu.edu/iso/irtables.php">ISO-IR, ISOTROPY Software Suite</a></li><li>Stokes, Campbell, &amp; Cordes, <a href="https://doi.org/10.1107/S0108767313007538">Acta Cryst. A. <strong>69</strong>, 388-395 (2013)</a>.</li></ul><p>The ISO-IR dataset is occasionally missing some <strong>k</strong>-points that lie outside the basic domain but still resides in the representation domain (i.e. <strong>k</strong>-points with postscripted &#39;A&#39;, &#39;B&#39;, etc. labels, such as &#39;ZA&#39;). In such cases, the missing irreps may instead have been manually sourced from the Bilbao Crystallographic Database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/littlegroup_irreps.jl#L63-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.get_littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}} where D" href="#Crystalline.get_littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}} where D"><code>Crystalline.get_littlegroups</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_littegroups(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3)) 
                                                    -&gt; Dict{String, LittleGroup{D}}</code></pre><p>For given space group number <code>sgnum</code> and dimension <code>D</code>, return the associated little groups (<code>LittleGroups{D}</code>s) at high-symmetry k-points, lines, and planes (see also <a href="#Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile},Union{Nothing, JLD2.JLDFile}}} where D"><code>get_lgirreps</code></a>).</p><p>Returns a <code>Dict</code> with little group <strong>k</strong>-point labels as keys and vectors of <code>LittleGroup{D}</code>s as values.</p><p><strong>Notes</strong></p><p>A conventional crystallographic setting is assumed (as in <a href="#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>spacegroup</code></a>).</p><p>Unlike <code>spacegroup</code>, &quot;centering&quot;-copies of symmetry operations are not included in the returned <code>LittleGroup</code>s; as an example, space group 110 (body-centered, with centering symbol &#39;I&#39;) has a centering translation <code>[1/2,1/2,1/2]</code> in the conventional setting: the symmetry operations returned by <code>spacegroup</code> thus includes e.g. both <code>{1|0}</code> and  <code>{1|Â½,Â½,Â½}</code> while the symmetry operations returned by <code>get_littlegroups</code> only include <code>{1|0}</code> (and so on).</p><p>Currently, only <code>D = 3</code> is supported.</p><p><strong>References</strong></p><p>The underlying data is sourced from the ISOTROPY dataset: see also <a href="#Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile}}, Tuple{Integer,Val{D},Union{Nothing, JLD2.JLDFile},Union{Nothing, JLD2.JLDFile}}} where D"><code>get_lgirreps</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/littlegroup_irreps.jl#L4-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.get_pgirreps-Tuple{String,Val{3}}" href="#Crystalline.get_pgirreps-Tuple{String,Val{3}}"><code>Crystalline.get_pgirreps</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_pgirreps(iuclab::String, Val{D}) where D âˆˆ (1,2,3)
get_pgirreps(iuclab::String, D)</code></pre><p>Return the (crystallographic) point group irreps of the IUC label <code>iuclab</code> of dimension <code>D</code> as a vector of <code>PGIrrep{D}</code>s.</p><p><strong>Notes</strong></p><p>The irrep labelling follows the conventions of CDML [1] [which occasionally differ from those in e.g. Bradley and Cracknell, <em>The Mathematical Theory of Symmetry in Solids</em> (1972)].</p><p>The data is sourced from the Bilbao Crystallographic Server [2]. If you are using this  functionality in an explicit fashion, please cite the original reference [3].</p><p><strong>References</strong></p><p>[1] Cracknell, Davies, Miller, &amp; Love, Kronecher Product Tables 1 (1979).</p><p>[2] Bilbao Crystallographic Server:      https://www.cryst.ehu.es/cgi-bin/cryst/programs/representations_point.pl</p><p>[3] Elcoro et al.,      <a href="https://doi.org/10.1107/S1600576717011712">J. of Appl. Cryst. <strong>50</strong>, 1457 (2017)</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/pointgroup.jl#L129-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.get_wycks-Union{Tuple{D}, Tuple{Integer,Val{D}}} where D" href="#Crystalline.get_wycks-Union{Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>Crystalline.get_wycks</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_wycks(sgnum, _)
</code></pre><p>Return the Wyckoff positions of space group <code>sgnum</code> in dimension <code>D</code> as a  <code>Vector{WyckPos{D}</code>.</p><p>The positions are given in the conventional basis setting, following the conventions of the Bilbao Crystallographic Server (from which the underlying data is sourced [1]).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; wps = get_wycks(16, 2)
4-element Array{WyckPos{2},1}:
 6d: [Î±, Î²]
 3c: [0.5, 0.0]
 2b: [0.3333333333333333, 0.6666666666666666]
 1a: [0.0, 0.0]</code></pre><p><strong>References</strong></p><p>[1] Aroyo, et. al. Zeitschrift fuer Kristallographie (2006), 221, 1, 15-27.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/wyckoff.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.herring-Union{Tuple{D}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1}}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1},Union{Nothing, Array{var&quot;#s130&quot;,1} where var&quot;#s130&quot;&lt;:Real}}} where D" href="#Crystalline.herring-Union{Tuple{D}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1}}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1},Union{Nothing, Array{var&quot;#s130&quot;,1} where var&quot;#s130&quot;&lt;:Real}}} where D"><code>Crystalline.herring</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">herring(lgir::LGIrrep, sgops::AbstractVector{SymOperation{D}},
        Î±Î²Î³::Union{Vector{&lt;:Real},Nothing}=nothing)        --&gt; Tuple{Int, Int}</code></pre><p>Computes the Herring criterion for a small irrep <code>lgir::LGIrrep</code>, from </p><p><span>$[âˆ‘ Ï‡(\{Î²|b\}Â²)]/[g_0/M(k)]$</span></p><p>over symmetry operations <span>$\{Î²|b\}$</span> that take <span>$k â†’ -k$</span>.  Here <span>$g_0$</span> is the order of the point group of the space group and <span>$M(k)$</span> is the order of the star(<span>$k$</span>) [both in a primitive basis].</p><p>The returned value, <span>$[âˆ‘ Ï‡(\{Î²|b\}Â²)]/[g_0/M(k)]$</span>, is one of three integers in  <span>$\{1,-1,0\}$</span> corresponding to {real, pseudoreal, complex} reality.  We remind that ISOTROPY&#39;s convention (and hence, the <code>type</code> field of <code>LGIrrep</code>s and  <code>PGIrrep</code>s) of the same reality types is <span>$\{1,2,3\}$</span>.</p><p>The provided space group operations <code>sgops</code> <strong>must</strong> be the set reduced by primitive translation vectors; i.e. using <code>spacegroup(...)</code> directly is <strong>not</strong> allowable in general (since the irreps we reference only include these &quot;reduced&quot; operations). This reduced set of operations can be obtained e.g. from the Î“ point irreps of ISOTROPY&#39;s dataset, or alternatively, from <code>reduce_ops(spacegroup(...), true)</code>.</p><p>As a sanity check, a value of <code>Î±Î²Î³</code> can be provided to check for invariance along a symmetry line/plane/general point in k-space. Obviously, the reality  type should invariant to this choice.</p><p><strong>Implementation:</strong>  See e.g. Inui&#39;s Eq. (13.48), Dresselhaus, p. 618, and  and Herring&#39;s original paper at https://doi.org/10.1103/PhysRev.52.361. We mainly followed Cornwell, p. 150-152 &amp; 187-188.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/irreps_reality.jl#L247-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.interpolate_kvpath-Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:(AbstractArray{var&quot;#s26&quot;,1} where var&quot;#s26&quot;&lt;:Real),Integer}" href="#Crystalline.interpolate_kvpath-Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:(AbstractArray{var&quot;#s26&quot;,1} where var&quot;#s26&quot;&lt;:Real),Integer}"><code>Crystalline.interpolate_kvpath</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolate_kvpath(kvs::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, Ninterp::Integer) 
    --&gt; Vector{Vector{Float64}}, Int64</code></pre><p>Computes an interpolated <span>$k$</span>-path between the discrete <span>$k$</span>-points in <code>kvs</code>, so that the interpolated path has <em>approximately</em> <code>Ninterp</code> points in total (typically fewer).</p><p>Since the actual number of points in the path may deviate from the requested <code>Ninterp</code>, the actual number of points in the path is returned along with the interpolated itself.</p><p>Note that, in general, it is not possible to do this so that all interpolated <span>$k$</span>-points are equidistant; but points are equidistant in-between the initial discrete points provided in <code>kvs</code>.</p><p>See also <a href="#Crystalline.splice_kvpath-Tuple{AbstractArray{var&quot;#s22&quot;,1} where var&quot;#s22&quot;&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real),Integer}"><code>splice_kvpath</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/utils.jl#L255-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.isnormal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:(SymOperation{var&quot;#s15&quot;} where var&quot;#s15&quot;))" href="#Crystalline.isnormal-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:(SymOperation{var&quot;#s15&quot;} where var&quot;#s15&quot;))"><code>Crystalline.isnormal</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isnormal(opsá´³::T, opsá´´::T; verbose::Bool=false) where T&lt;:AbstractVector{SymOperation{D}}
                                                --&gt; Bool</code></pre><p>Determine whether the operations in group <span>$H$</span> are normal in the group <span>$G$</span> (each with  operations <code>opsá´³</code> and <code>opsá´´</code>), in the sense that </p><p><span>$ghgâ»Â¹ âˆˆ H, âˆ€ gâˆˆG, âˆ€ hâˆˆH$</span></p><p>Returns a Boolean answer (<code>true</code> if normal, <code>false</code> if not).</p><p><strong>Note</strong></p><p>This compares space groups rather than space group types, i.e. the  comparison assumes a matching setting choice between <span>$H$</span> and <span>$G$</span>. To compare space  group types with different conventional settings, they must first be transformed to a shared setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L793-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.israyrep" href="#Crystalline.israyrep"><code>Crystalline.israyrep</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">israyrep(lgir::LGIrrep, Î±Î²Î³=nothing) -&gt; (::Bool, ::Matrix)</code></pre><p>Computes whether a given little group irrep <code>ir</code> is a ray representation  by computing the coefficients Î±áµ¢â±¼ in Dáµ¢Dâ±¼=Î±áµ¢â±¼Dâ‚–; if any Î±áµ¢â±¼ differ  from unity, we consider the little group irrep a ray representation (as opposed to the simpler &quot;vector&quot; representations where Dáµ¢Dâ±¼=Dâ‚–). The function returns a boolean (true =&gt; ray representation) and the coefficient matrix Î±áµ¢â±¼.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L527-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issubgroup-Union{Tuple{T}, Tuple{D}, Tuple{T,T}} where T&lt;:AbstractArray{SymOperation{D},1} where D" href="#Crystalline.issubgroup-Union{Tuple{T}, Tuple{D}, Tuple{T,T}} where T&lt;:AbstractArray{SymOperation{D},1} where D"><code>Crystalline.issubgroup</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issubgroup(opsá´³::T, opsá´´::T) where T&lt;:AbstractVector{SymOperation{D}} --&gt; Bool</code></pre><p>Determine whether the operations in group <span>$H$</span> are a subgroup of the group <span>$G$</span> (each with  operations <code>opsá´³</code> and <code>opsá´´</code>, respectively), i.e. whether <span>$H&lt;G$</span>. Specifically, this requires that <span>$G$</span> and <span>$H$</span> are both groups and that for every <span>$hâˆˆH$</span> there exists an element <span>$gâˆˆG$</span> such that <span>$h=g$</span>.</p><p>Returns a Boolean answer (<code>true</code> if normal, <code>false</code> if not).</p><p><strong>Note</strong></p><p>This compares space groups rather than space group types, i.e. the comparison assumes a matching setting choice between <span>$H$</span> and <span>$G$</span>. To compare space group types with different conventional settings, they must first be transformed to a shared setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L748-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph" href="#Crystalline.issymmorph"><code>Crystalline.issymmorph</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issymmorph(sgnum::Integer, D::Integer=3) --&gt; Bool</code></pre><p>Checks whether a given space group <code>sgnum</code> (of dimensionality <code>D</code>) is symmorphic (true) or nonsymmorphic (false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph-Tuple{SymOperation,Char}" href="#Crystalline.issymmorph-Tuple{SymOperation,Char}"><code>Crystalline.issymmorph</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issymmorph(op::SymOperation, cntr::Char) --&gt; Bool</code></pre><p>Checks whether a given symmetry operation <code>op</code> is symmorphic (true) or nonsymmorphic (false). The operation is assumed to be given in a  conventional basis; but the check requires that the translation is zero  in a primitive basis. Accordingly, the centering <code>cntr</code> must provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L160-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.issymmorph-Tuple{Union{LittleGroup, SpaceGroup}}" href="#Crystalline.issymmorph-Tuple{Union{LittleGroup, SpaceGroup}}"><code>Crystalline.issymmorph</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issymmorph(sg::AbstractGroup) --&gt; Bool</code></pre><p>Checks whether a given space group <code>sg</code> is symmorphic (true) or nonsymmorphic (false).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.iuc" href="#Crystalline.iuc"><code>Crystalline.iuc</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iuc(sgnum::Integer, D::Integer=3) --&gt; String</code></pre><p>Returns the IUC (International Union of Crystallography) notation for space group number <code>sgnum</code> and dimensionality <code>D</code>, as used in the International Tables of Crystallography.  The notation is sometimes also known as the Hermann-Mauguin notation; the functionality is consequently aliased by <code>hermannmauguin(sgnum, D)</code>.  IUC/Hermann-Mauguin notation applies in one, two, and three-dimensions.</p><p>For more information, see https://en.wikipedia.org/wiki/Hermann%E2%80%93Mauguin_notation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/notation.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.levelsetlattice" href="#Crystalline.levelsetlattice"><code>Crystalline.levelsetlattice</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">levelsetlattice(sgnum::Integer, D::Integer=2, idxmax::NTuple=ntuple(i-&gt;2,D))
    --&gt; UnityFourierLattice{D}</code></pre><p>Compute a &quot;neutral&quot;/uninitialized Fourier lattice basis, a UnityFourierLattice, consistent with the symmetries of the space group <code>sgnum</code> in dimension <code>D</code>. The resulting lattice <code>flat</code> is expanded in a Fourier basis split into symmetry-derived orbits, with intra-orbit  coefficients constrained by the symmetries of the space-group. The inter-orbit coefficients are, however, free and unconstrained.</p><p>The Fourier resolution along each reciprocal lattice vector is controlled by <code>idxmax</code>: e.g., if <code>D = 2</code> and <code>idxmax = (2, 3)</code>, the resulting Fourier lattice may contain  reciprocal lattice vectors (kâ‚, kâ‚‚) with kâ‚âˆˆ[0,Â±1,Â±2] and kâ‚‚âˆˆ[0,Â±1,Â±2,Â±3], referred  to a ğ†-basis.</p><p>This &quot;neutral&quot; lattice can, and usually should, be subsequently modulated by <code>modulate</code> (modulates the inter-orbit coefficients, which will often eliminate symmetries that may remain in the &quot;neutral&quot; configuration, where all inter-orbit coefficients are unity).</p><p><strong>Examples</strong></p><p>Compute a UnityFourierLattice, modulate it with random inter-orbit coefficients via <code>modulate</code>, and finally plot it (requires <code>using PyPlot</code>):</p><pre><code class="language-julia-repl">julia&gt; uflat = levelsetlattice(16, 2)
julia&gt; flat  = modulate(uflat)
julia&gt; Rs    = directbasis(16, 2) 
julia&gt; plot(flat, Rs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L53-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.matrix" href="#Crystalline.matrix"><code>Crystalline.matrix</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">matrix(BRS::BandRepSet[, includedim::Bool=false])</code></pre><p>Return a matrix representation of <code>BRS::BandRepSet</code>, with band representations as columns  and irreps over rows.</p><p>For <code>includedim=true</code> the band filling (i.e. <code>dim.(BRS)</code>) is included as the last row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/types.jl#L665-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}}}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}},Union{Nothing, Real}}} where D" href="#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}}}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}},Union{Nothing, Real}}} where D"><code>Crystalline.modulate</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">modulate(flat::UnityFourierLattice{D},
modulation::AbstractVector{ComplexF64}=rand(ComplexF64, length(getcoefs(flat))),
expon::Union{Nothing, Real}=nothing)
                        --&gt; ModulatedFourierLattice{D}</code></pre><p>Derive a concrete, modulated Fourier lattice from <code>flat</code>, a UnityFourierLattice  struct (that contains the <em>interrelations</em> between orbit coefficients), by  multiplying the &quot;normalized&quot; orbit coefficients by a <code>modulation</code>, a <em>complex</em> modulating vector (in general, should be complex; otherwise restores unintended symmetry to the lattice). Distinct <code>modulation</code> vectors produce distinct  realizations of the same lattice described by the original <code>flat</code>. By default, a random complex vector is used.</p><p>An exponent <code>expon</code> can be provided, which introduces a penalty term to short- wavelength features (i.e. high-|G| orbits) by dividing the orbit coefficients by |G|^<code>expon</code>; producing a more &quot;localized&quot; and &quot;smooth&quot; lattice boundary when <code>expon &gt; 0</code> (reverse for <code>expon &lt; 0</code>). This basically amounts to a  continuous &quot;simplifying&quot; operation on the lattice (it is not necessarily a  smoothing operation; it simply suppresses &quot;high-frequency&quot; components). If <code>expon = nothing</code>, no rescaling is performed. </p><p>The <code>normscale(!)</code> methods exists to perform subsequent <code>expon</code> norm-rescaling  of a <code>ModulatedFourierLattice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L316-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.normscale!-Tuple{ModulatedFourierLattice,Real}" href="#Crystalline.normscale!-Tuple{ModulatedFourierLattice,Real}"><code>Crystalline.normscale!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normscale!(flat::ModulatedFourierLattice, expon::Real) --&gt; ModulatedFourierLattice</code></pre><p>In-place equivalent of <code>normscale</code>: changes <code>flat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.normscale-Tuple{ModulatedFourierLattice,Real}" href="#Crystalline.normscale-Tuple{ModulatedFourierLattice,Real}"><code>Crystalline.normscale</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normscale(flat::ModulatedFourierLattice, expon::Real) --&gt; ModulatedFourierLattice</code></pre><p>Applies subsequent norm-rescaling via <code>expon</code>; see detailed description  in <code>modulate</code>. An in-place variant is provided as <code>normscale!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L368-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.orbit-Tuple{AbstractArray{var&quot;#s129&quot;,1} where var&quot;#s129&quot;&lt;:(AbstractArray{var&quot;#s128&quot;,2} where var&quot;#s128&quot;&lt;:Real),AbstractArray{var&quot;#s127&quot;,1} where var&quot;#s127&quot;&lt;:Real}" href="#Crystalline.orbit-Tuple{AbstractArray{var&quot;#s129&quot;,1} where var&quot;#s129&quot;&lt;:(AbstractArray{var&quot;#s128&quot;,2} where var&quot;#s128&quot;&lt;:Real),AbstractArray{var&quot;#s127&quot;,1} where var&quot;#s127&quot;&lt;:Real}"><code>Crystalline.orbit</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orbit(Ws, x)</code></pre><p>Computes the orbit of <code>x</code> under a set of point-group operations <code>Ws</code>, i.e. computes the set <code>{gx | gâˆˆG}</code> where <code>g</code> denotes elements of the group <code>G</code> composed of all operations in <code>Ws</code> (possibly iterated, to ensure full coverage).</p><p>At the moment, we only consider <em>point group</em> operations; i.e. there are  no nonsymmorphic <code>Ws</code> parts. </p><p>It is important that <code>Ws</code> and <code>x</code> are given in the same basis. </p><p>[W&#39; = PWPâ»Â¹ if the basis change is from coordinates r to r&#39; = Pr, corresponding  to a new set of basis vectors (xÌ‚&#39;)áµ€=xÌ‚áµ€P; e.g., when going from a direct basis representation to a Cartesian one, the basis change matrix is P = [Râ‚ Râ‚‚ Râ‚ƒ], with Ráµ¢ inserted as column vectors]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L182-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D" href="#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D"><code>Crystalline.pointgroup</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointgroup(ops:AbstractVector{SymOperation{D}})
pointgroup(sg::AbstractGroup)</code></pre><p>Computes the point group associated with a space group <code>sg</code> (characterized by a set of operators <code>ops</code>, which, jointly with lattice translations generate  the space group), obtained by &quot;taking away&quot; any translational parts and  then reducing to the resulting unique rotational operations. (technically, in the language of Bradley &amp; Cracknell, this is the so-called isogonal point group of <code>sg</code>; see Sec. 1.5).</p><p>Returns a <code>Vector</code> of <code>SymOperation</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L190-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.prepare_mpbcalc!-Union{Tuple{D}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real,String}} where D" href="#Crystalline.prepare_mpbcalc!-Union{Tuple{D}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real,String}} where D"><code>Crystalline.prepare_mpbcalc!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prepare_mpbcalc!(...)</code></pre><p>Formats a set of parameters that uniquely specify an MPB calculation, given a  space group number <code>sgnum</code>, a Fourier lattice <code>flat</code>, a DirectBasis <code>Rs</code>, a filling fraction <code>filling</code> for <code>flat</code>, interior and exterior (above, below the contour) permittivities <code>Îµin</code> and <code>Îµout</code>, as well as a list of k-vectors <code>kvecs</code>, an  identifying tag <code>id</code> (to label the calculation for book-keeping purposes), a  resolution for the MPB calculation <code>res</code>, and a selection of calculation type <code>runtype</code> (&quot;all&quot;, &quot;te&quot;, or &quot;tm&quot;). The results are written to requested IO <code>io</code>.</p><p>Our preferred choice is to write these parameters to a bash file, with a name generated by the <code>mpb_calcname(...)</code> method.</p><p>The options are expected to be fed to the <code>fourier-lattice.ctl</code> file, e.g. through a bash script of the following kind:</p><pre><code class="language-sh">    IFS=$&#39;\n&#39;; # stop command-substitutions from word-splitting at space

    PATH_TO_MPB_EXECUTABLE \
        (cat ${calcname}.sh)
        ctl/fourier-lattice.ctl 2&gt;&amp;1 | tee logs/${calcname}.log
        
    unset IFS; # restore usual command-substitution word-splitting practice</code></pre><p>where <code>PATH_TO_MPB_EXECUTABLE</code> is the path to the MPB executable. Locally, in <code>mpb-ctl</code> we have a file <code>run-fourier-lattice.sh</code> which performs the  above, with <code>calcname</code> specified as an input parameter (assumed to be a subfolder <code>/input/</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/export2mpb.jl#L88-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Tuple{KVec,Char}" href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(kv::KVec, cntr::Char) --&gt; kvâ€²::KVec</code></pre><p>Transforms a conventional reciprocal coordinate vector <code>kv</code> to a standard primitive basis (specified by the centering type <code>cntr</code>), returning the associated reciprocal coordinate vector <code>kvâ€²</code>.</p><p>Note that a basis change matrix <span>$P$</span> (as returned by  <a href="@ref"><code>Crystalline.primitivebasismatrix</code></a>) transforms direct coordinate vectors as <span>$râ€²=Pâ»Â¹r$</span> but transforms reciprocal coordinates as <span>$kâ€² = Páµ€k$</span> (see e.g. ITA7 Sec. 1.5.1.2 and 1.5.2.1). Recall also the distinction between transforming a basis and the coordinates of a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L549-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(flat::AbstractFourierLattice, cntr::Char) --&gt; ::typeof(flat)</code></pre><p>Given <code>flat</code> referred to a conventional basis with centering <code>cntr</code>, compute the derived (but physically equivalent) lattice <code>flatâ€²</code> referred to the associated primitive basis. </p><p>Specifically, if <code>flat</code> refers to a direct conventional basis <code>Rs</code> <span>$â‰¡ (ğš ğ› ğœ)$</span> [with  coordinate vectors <span>$ğ« â‰¡ (râ‚, râ‚‚, râ‚ƒ)^T$</span>] then <code>flatâ€²</code> refers to a direct primitive basis <code>Rsâ€²</code> <span>$â‰¡ (ğšâ€² ğ›â€² ğœâ€²) â‰¡ (ğš ğ› ğœ)P$</span> [with coordinate vectors <span>$ğ«â€² â‰¡ (râ‚â€², râ‚‚â€², râ‚ƒâ€²)^T = Pâ»Â¹ğ«$</span>], where <span>$P$</span> denotes the basis-change matrix obtained from <code>primitivebasismatrix(...)</code>.</p><p>To compute the associated primitive basis vectors, see <a href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>primitivize(::DirectBasis, ::Char)</code></a> [specifically, <code>Rsâ€² = primitivize(Rs, cntr)</code>].</p><p><strong>Examples</strong></p><p>A centered (&#39;c&#39;) lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires <code>using PyPlot</code>):</p><pre><code class="language-julia-repl">julia&gt; using PyPlot
julia&gt; sgnum = 5; D = 2; cntr = centering(sgnum, D)  # &#39;c&#39; (body-centered)

julia&gt; Rs   = directbasis(sgnum, D)     # conventional basis (rectangular)
julia&gt; flat = levelsetlattice(sgnum, D) # Fourier lattice in basis of Rs
julia&gt; flat = modulate(flat)            # modulate the lattice coefficients
julia&gt; plot(flat, Rs)

julia&gt; Rsâ€²   = primitivize(Rs, cntr)    # primitive basis (oblique)
julia&gt; flatâ€² = primitivize(flat, cntr)  # Fourier lattice in basis of Rsâ€²
julia&gt; plot(flatâ€², Rsâ€²)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/lattices.jl#L252-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.Basis{D},Integer}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.Basis{D},Integer}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(Vs::Basis, sgnum::Integer) --&gt; Rsâ€²::Basis</code></pre><p>Transforms a conventional <code>Basis</code> (either <code>DirectBasis</code> or <code>ReciprocalBasis</code>) <code>Vs</code> into its primitive equivalent <code>Vsâ€²</code>, provided that its centering differs from the conventional (P or p), by inferring the Bravais type from the space group number <code>sgnum</code> and applying an applying an appropriate (<code>Basis</code>-type specific) transformation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L426-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(Rs::DirectBasis, cntr::Char) --&gt; Rsâ€²::DirectBasis</code></pre><p>Transforms a conventional DirectBasis <code>Rs</code> into its primitive  equivalent <code>Rsâ€²</code>, with the transformation dependent on the centering type <code>cntr</code> (P, I, F, R, A, C, and p, c); for centering P and p, the  conventional and primive bases coincide.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L445-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{ReciprocalBasis{D},Char}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{ReciprocalBasis{D},Char}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(Gs::ReciprocalBasis, cntr::Char) --&gt; Gsâ€²::ReciprocalBasis</code></pre><p>Calculates the <strong>primitive</strong> reciprocal basis associated with an assumed <strong>conventional</strong> reciprocal basis <code>Gs::ReciprocalBasis</code> with centering type <code>cntr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L493-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.primitivize-Union{Tuple{D}, Tuple{SymOperation{D},Char}, Tuple{SymOperation{D},Char,Bool}} where D" href="#Crystalline.primitivize-Union{Tuple{D}, Tuple{SymOperation{D},Char}, Tuple{SymOperation{D},Char,Bool}} where D"><code>Crystalline.primitivize</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --&gt; SymOperation</code></pre><p>Transforms a symmetry operation <code>op</code> <span>$= \{W|w\}$</span> from a conventional cell to a primitive cell (specified by its centering character <code>cntr</code>), then denoted <span>$\{W&#39;|w&#39;\}$</span>; i.e. performs a basis change <code>opâ€²</code> <span>$â‰¡ \{W&#39;|w&#39;\} = \{P|p\}â»Â¹\{W|w\}\{P|p\}$</span> where <span>$P$</span> and <span>$p$</span> are the basis change matrix and origin shifts, respectively, of the transformation.</p><p>By default, translation parts of <code>opâ€²</code>, i.e. <span>$w&#39;$</span> are reduced modulo 1 (<code>modw = true</code>); to disable this, set <code>modw = false</code>.</p><p>For additional details, see ITA6 Sec. 1.5.2.3, p. 84.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L520-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D},1}}, Tuple{D}, Tuple{AbstractArray{LGIrrep{D},1},Bool}} where D" href="#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D},1}}, Tuple{D}, Tuple{AbstractArray{LGIrrep{D},1},Bool}} where D"><code>Crystalline.realify</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">realify(lgirs::AbstractVector{&lt;:LGIrrep}, verbose::Bool=false)
                                                    --&gt; AbstractVector{&lt;:LGIrrep}</code></pre><p>From <code>lgirs</code>, a vector of <code>LGIrrep</code>s, determine the associated (gray) co-representations, i.e. the &quot;real&quot;, or &quot;physical&quot; irreps that are relevant in scenarios with time-reversal symmetry.</p><p>For <code>LGIrrep</code> that are real (<code>type=1</code>), or that characterize a k-point ğ¤ which is not equivalent to -ğ¤ (i.e. its star does not include both ğ¤ and -ğ¤; equivalently, the little group includes time-reversal symmetry), the associated co-representations are just the  original irreps themselves.  For pseudo-real (<code>type=2</code>) and complex (<code>type=3</code>) <code>LGIrrep</code>s where Â±ğ¤ are equivalent, the associated co-representations are built from pairs of irreps that &quot;stick&quot; together. This method computes this pairing and sets the <code>LGIrrep</code> field <code>iscorep</code> to true, to indicate that the resulting &quot;paired irrep&quot; (i.e. the co-representation) should be doubled with  itself (pseudo-real type) or its complex conjugate (complex type).</p><p><strong>Background</strong></p><p>For background, see p. 650-652 (and 622-626 for point groups) in Bradley &amp; Cracknell&#39;s book. Their discussion is for magnetic groups (the &quot;realified&quot; irreps are really correspond to co-representations of &quot;gray&quot; magnetic groups).  Cornwell&#39;s book also does a good job of explicating this, as does Inui (p. 296-299).</p><p><strong>Keyword arguments</strong></p><ul><li><code>verbose::Bool</code>: if set to <code>true</code>, prints details about mapping from small irrep to small</li></ul><p>corep for each <code>LGIrrep</code> (default: <code>false</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/irreps_reality.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.reciprocalbasis-Union{Tuple{Union{Tuple{Vararg{Array{var&quot;#s132&quot;,1} where var&quot;#s132&quot;&lt;:Real,D}}, DirectBasis{D}}}, Tuple{D}} where D" href="#Crystalline.reciprocalbasis-Union{Tuple{Union{Tuple{Vararg{Array{var&quot;#s132&quot;,1} where var&quot;#s132&quot;&lt;:Real,D}}, DirectBasis{D}}}, Tuple{D}} where D"><code>Crystalline.reciprocalbasis</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reciprocalbasis(Rs::DirectBasis{D}) --&gt; Gs::ReciprocalBasis{D}</code></pre><p>Calculates the reciprocal basis associated with a <code>DirectBasis</code> <code>Rs</code> (alternatively supplied as an <code>NTuple</code> of <code>Vector</code>s). Returns a <code>ReciprocalBasis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L395-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.schoenflies-Tuple{Integer}" href="#Crystalline.schoenflies-Tuple{Integer}"><code>Crystalline.schoenflies</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">schoenflies(sgnum::Integer) --&gt; String</code></pre><p>Returns the Schoenflies notation for a given space group number <code>sgnum</code>. Schoenflies notation only applies to point groups and  space groups, not plane groups, so this notation is only relevant in three dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/notation.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D" href="#Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D"><code>Crystalline.seitz</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">seitz(op::SymOperation) --&gt; String</code></pre><p>Computes the correponding Seitz notation for a symmetry operation in triplet/xyzt form.</p><p>Implementation based on ITA5 Table 11.2.1.1, with 3D point group parts inferred from the trace and determinant of the matrix <span>$W$</span> in the triplet <span>${W|w}$</span>.</p><table><tr><th style="text-align: right">detW\trW</th><th style="text-align: right">-3</th><th style="text-align: right">-2</th><th style="text-align: right">-1</th><th style="text-align: right">0</th><th style="text-align: right">1</th><th style="text-align: right">2</th><th style="text-align: right">3</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">2</td><td style="text-align: right">3</td><td style="text-align: right">4</td><td style="text-align: right">6</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">-1</td><td style="text-align: right">-1</td><td style="text-align: right">-6</td><td style="text-align: right">-4</td><td style="text-align: right">-3</td><td style="text-align: right">m</td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>with the elements of the table giving the type of symmetry operation in in Hermann-Mauguin notation. The rotation axis and the rotation sense are  computed following the rules in ITA6 Sec. 1.2.2.4(1)(b-c). The implementation has been checked against the Tables 1.4.2.1-5 of ITA6.</p><p>Note that the orientation of axis (i.e. its sign) is not necessarily equal to the orientation picked in those tables; it is a matter of convention, and the conventions have not been explicated in ITA6.</p><p>2D operations are treated by the same procedure, by elevation in a third dimension; 1D operations by a simple inspection of sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/notation.jl#L182-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D" href="#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>Crystalline.spacegroup</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spacegroup(sgnum::Integer, D::Integer=3) --&gt; SpaceGroup{D}</code></pre><p>Return the space group symmetry operations for a given space group number <code>sgnum</code> and  dimensionality <code>D</code> as a <code>SpaceGroup{D}</code>. The returned symmetry operations are specified relative to the conventional basis vectors, i.e. are not necessarily primitive (see <a href="#Crystalline.centering"><code>centering</code></a>). If desired, operations for the primitive unit cell can subsequently be generated using  <a href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>primitivize</code></a> or <a href="@ref"><code>Crystalline.reduce_ops</code></a>.</p><p>The default choices for the conventional basis vectors follow the conventions of the Bilbao Crystallographic Server (or, equivalently, the International Tables of Crystallography),  which are:</p><ul><li>Unique axis b (cell choice 1) for space groups within the monoclinic system.</li><li>Obverse triple hexagonal unit cell for rhombohedral space groups.</li><li>Origin choice 2: inversion center at (0,0,0). (relevant for the centrosymmetric space groups where there are two origin choices, in the orthorhombic, tetragonal and cubic  systems)</li></ul><p>See also <a href="#Crystalline.directbasis-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D"><code>directbasis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L40-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.splice_kvpath-Tuple{AbstractArray{var&quot;#s22&quot;,1} where var&quot;#s22&quot;&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real),Integer}" href="#Crystalline.splice_kvpath-Tuple{AbstractArray{var&quot;#s22&quot;,1} where var&quot;#s22&quot;&lt;:(AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real),Integer}"><code>Crystalline.splice_kvpath</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">splice_kvpath(kvs::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, Nsplice::Integer) 
                                                            --&gt; Vector{Vector{Float64}}</code></pre><p>Computes an interpolated <span>$k$</span>-path between the discrete <span>$k$</span>-points in <code>kvs</code>, inserting <code>Nsplice</code> points between each pair of adjacent <span>$k$</span>-points.</p><p>See also <a href="#Crystalline.interpolate_kvpath-Tuple{AbstractArray{var&quot;#s12&quot;,1} where var&quot;#s12&quot;&lt;:(AbstractArray{var&quot;#s26&quot;,1} where var&quot;#s26&quot;&lt;:Real),Integer}"><code>interpolate_kvpath</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/utils.jl#L290-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.subduction_count-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Union{Nothing, Array{var&quot;#s129&quot;,1} where var&quot;#s129&quot;&lt;:Real}}} where T&lt;:Crystalline.AbstractIrrep" href="#Crystalline.subduction_count-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Union{Nothing, Array{var&quot;#s129&quot;,1} where var&quot;#s129&quot;&lt;:Real}}} where T&lt;:Crystalline.AbstractIrrep"><code>Crystalline.subduction_count</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subduction_count(Dá´³áµ¢, Dá´´â±¼[, Î±Î²Î³á´´â±¼]) --&gt; Int64</code></pre><p>For two groups G and H, where H is a subgroup of G, i.e. G&gt;H, with associated  irreducible representations <code>Dá´³áµ¢</code><span>$(g)$</span> and <code>Dá´´â±¼</code><span>$(g)$</span> for elements <span>$gâˆˆG$</span> and <span>$hâˆˆH&lt;G$</span>, compute the compatibility relation between the two irreps from the subduction reduction formula (or &quot;magic&quot; formula/Schur orthogonality relation): this is essentially how many times <code>ná´³á´´áµ¢â±¼</code> the subduced representation <code>Dá´³áµ¢</code><span>$â†“H$</span> contains the irrep <code>Dá´´â±¼</code>;  in other words, this gives the compatibility between the two irreps.</p><p>Optionally, a vector <code>Î±Î²Î³á´´â±¼</code> may be provided, to evaluate the characters/irreps  of <code>Dá´³áµ¢</code> at a concrete value of Î±Î²Î³. This is e.g. meaningful for LGIrreps at non- special k-vectors. Defaults to <code>nothing</code>.</p><p>The reduction formula [e.g. Eq. (15) of https://arxiv.org/pdf/1706.09272.pdf] is:</p><p><span>$ná´³á´´áµ¢â±¼ = |H|^{-1}âˆ‘_h Ï‡^G_i(h)Ï‡^H_j(h)*$</span></p><p>As an example, consider space group 207 and the two compatible k-vectors  Î“ (a point) and Î£ (a line):</p><pre><code class="language-none">lgirsd  = get_lgirreps(207, Val(3));
Î“_lgirs = lgirsd[&quot;Î“&quot;]; # at Î“ â‰¡ [0.0, 0.0, 0.0]
Î£_lgirs = lgirsd[&quot;Î£&quot;]; # at Î£ â‰¡ [Î±, Î±, 0.0]</code></pre><p>We can test their compatibility like so:</p><pre><code class="language-none">[[subduction_count(Î“i, Î£j) for Î“i in Î“_lgirs] for Î£j in Î£_lgirs]
&gt; # Î“â‚ Î“â‚‚ Î“â‚ƒ Î“â‚„ Î“â‚…
&gt;  [ 1, 0, 1, 1, 2] # Î£â‚
&gt;  [ 0, 1, 1, 2, 1] # Î£â‚‚</code></pre><p>This entails the following compatibility relations between irreps at Î“ and Î£:</p><table><tr><th style="text-align: right">Compatibility relation</th><th style="text-align: right">Degeneracies</th></tr><tr><td style="text-align: right">Î“â‚ â†’ Î£â‚</td><td style="text-align: right">1 â†’ 1</td></tr><tr><td style="text-align: right">Î“â‚‚ â†’ Î£â‚‚</td><td style="text-align: right">1 â†’ 1</td></tr><tr><td style="text-align: right">Î“â‚ƒ â†’ Î£â‚ + Î£â‚‚</td><td style="text-align: right">2 â†’ 1 + 1</td></tr><tr><td style="text-align: right">Î“â‚„ â†’ Î£â‚ + 2Î£â‚‚</td><td style="text-align: right">3 â†’ 1 + 2</td></tr><tr><td style="text-align: right">Î“â‚… â†’ 2Î£â‚ + Î£â‚‚</td><td style="text-align: right">3 â†’ 2 + 1</td></tr></table><p>where, in this case, all the small irreps are one-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/compatibility.jl#L3-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.transform-Union{Tuple{D}, Tuple{KVec{D},AbstractArray{var&quot;#s131&quot;,2} where var&quot;#s131&quot;&lt;:Real}} where D" href="#Crystalline.transform-Union{Tuple{D}, Tuple{KVec{D},AbstractArray{var&quot;#s131&quot;,2} where var&quot;#s131&quot;&lt;:Real}} where D"><code>Crystalline.transform</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform(kv::KVec, P::AbstractMatrix{&lt;:Real}) --&gt; kvâ€²::KVec</code></pre><p>Returns a transformed reciprocal coordinate vector <code>kvâ€²</code> from an original reciprocal coordinate vector <code>kv</code> and a basis change matrix <code>P</code>.</p><p>Note that a basis change matrix <code>P</code> transforms reciprocal coordinates vectors as <span>$k&#39; = P^{\text{T}}k$</span> but transforms direct coordinate vectors as <span>$r&#39;=P^{-1}r$</span> (see e.g. ITA7 Secs. 1.5.1.2 and 1.5.2.1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/bravais.jl#L534-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.transform-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{var&quot;#s28&quot;,2} where var&quot;#s28&quot;&lt;:Real}, Tuple{SymOperation{D},AbstractArray{var&quot;#s26&quot;,2} where var&quot;#s26&quot;&lt;:Real,Union{Nothing, AbstractArray{var&quot;#s23&quot;,1} where var&quot;#s23&quot;&lt;:Real}}, Tuple{SymOperation{D},AbstractArray{var&quot;#s22&quot;,2} where var&quot;#s22&quot;&lt;:Real,Union{Nothing, AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real},Bool}} where D" href="#Crystalline.transform-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{var&quot;#s28&quot;,2} where var&quot;#s28&quot;&lt;:Real}, Tuple{SymOperation{D},AbstractArray{var&quot;#s26&quot;,2} where var&quot;#s26&quot;&lt;:Real,Union{Nothing, AbstractArray{var&quot;#s23&quot;,1} where var&quot;#s23&quot;&lt;:Real}}, Tuple{SymOperation{D},AbstractArray{var&quot;#s22&quot;,2} where var&quot;#s22&quot;&lt;:Real,Union{Nothing, AbstractArray{var&quot;#s16&quot;,1} where var&quot;#s16&quot;&lt;:Real},Bool}} where D"><code>Crystalline.transform</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform(op::SymOperation, P::Matrix{&lt;:Real}, 
          p::Union{Vector{&lt;:Real}, Nothing}=nothing,
          modw::Bool=true)                          --&gt; SymOperation</code></pre><p>Transforms a <code>op</code> <span>$= \{W|w\}$</span> by a rotation matrix <code>P</code> and a translation vector <code>p</code> (can be <code>nothing</code> for zero-translations), producing a new symmetry operation  <code>opâ€²</code> <span>$= \{W&#39;|w&#39;\}$</span> (see ITA6 Sec. 1.5.2.3):</p><p><span>$\{W&#39;|w&#39;\} = \{P|p\}^{-1}\{W|w\}\{P|p\}$</span></p><p>with</p><p><span>$W&#39; = P^{-1}WP$</span> and <span>$w&#39; = P^{-1}(w+Wp-p)$</span></p><p>By default, the translation part of <code>opâ€²</code>, i.e. <span>$w&#39;$</span>, is reduced to the range <span>$[0,1)$</span>,  i.e. computed modulo 1. This can be disabled by setting <code>modw = false</code> (default, <code>modw = true</code>).</p><p>See also <a href="#Crystalline.primitivize-Tuple{KVec,Char}"><code>primitivize</code></a> and <a href="#Crystalline.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D"><code>conventionalize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/symops.jl#L553-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Crystalline.wyck-Tuple{SiteGroup}" href="#Crystalline.wyck-Tuple{SiteGroup}"><code>Crystalline.wyck</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wyck(g)
</code></pre><p>Return the Wyckoff position associated with a <code>SiteGroup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thchr/Crystalline.jl/blob/a2202324cc7ef097f0df8ec13682a5b7e2cacf73/src/wyckoff.jl#L40-L44">source</a></section></article><h2 id="Exported-constants"><a class="docs-heading-anchor" href="#Exported-constants">Exported constants</a><a id="Exported-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-constants" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">Â« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 21 December 2020 21:10">Monday 21 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
