var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Crystalline","category":"page"},{"location":"api/#Exported-types","page":"API","title":"Exported types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = false\nOrder   = [:types]","category":"page"},{"location":"api/#Exported-methods","page":"API","title":"Exported methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api/#Base.:âˆ˜","page":"API","title":"Base.:âˆ˜","text":"(âˆ˜)(op::SymOperation, kv::KVec, checkabc::Bool=true) --> KVec\n\nComputes the action of the SymOperation op  g on a KVec kv  k using that g acts on k-vectors as k(G) = g(R)áµ€Â¹k(G), with g  in an R-basis and k in a G-basis. Returns a new KVec, that is  possibly distinct from its original only by a reciprocal lattice vector (i.e. multiple of integers).\n\nIf checkabc = false, the free part of KVec is not transformed (can be useful in situation when kabc is zero, and several  transformations are requested).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.:âˆ˜-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Bool}} where T<:SymOperation","page":"API","title":"Base.:âˆ˜","text":"(âˆ˜)(op1::T, op2::T, modÏ„::Bool=true) where T<:SymOperation\n\nCompose two symmetry operations op1={Wâ‚|wâ‚} and op2={Wâ‚‚|wâ‚‚} using the composition rule (in Seitz notation)\n\n{Wâ‚|wâ‚}{Wâ‚‚|wâ‚‚} = {Wâ‚*Wâ‚‚|wâ‚+Wâ‚*wâ‚‚}\n\nfor symmetry operations opáµ¢ = {Wáµ¢|wáµ¢}. By default, the translation part of the {Wâ‚Wâ‚‚|wâ‚+Wâ‚wâ‚‚} is reduced to the range [0,1], i.e. computed modulo 1. This can be toggled off (or on) by the Boolean flag modÏ„ (enabled, i.e.  true, by default). Returns another SymOperation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.bandreps-Tuple{Integer}","page":"API","title":"Crystalline.bandreps","text":"bandreps(sgnum::Integer; \n         allpaths::Bool=false, spinful::Bool=false, timereversal::Bool=true)\n\nReturns the BandRepSet for space group sgnum (provided by the Bilbao Crystallographic Server; http://www.cryst.ehu.es/cgi-bin/cryst/programs/bandrep.pl)\n\nKeyword arguments:\n\nallpaths: include a minimal sufficient set (false, default) or all (true) k-vectors. \nspinful: single- (false, default) or double-valued (true) irreps, as appropriate for            spinless and spinful particles, respectively.\ntimereversal: assume presence (true, default) or absence (false) of time-reversal                 symmetry.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.basisdim-Tuple{BandRepSet}","page":"API","title":"Crystalline.basisdim","text":"basisdim(BRS::BandRepSet) --> Int64\n\nComputes the dimension of the (linearly independent parts) of a band representation set. This is dáµ‡Ë¢ = dáµƒâ± in the notation of Po, Watanabe, & Vishwanath, Nature Commun. 8, 50 (2017). In other words, this is the number of linearly independent basis vectors that span the expansions of a band structure or atomic insulator viewed as symmetry-data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.calcfourier-Tuple{Any,Crystalline.AbstractFourierLattice}","page":"API","title":"Crystalline.calcfourier","text":"calcfourier(xyz, flat::AbstractFourierLattice) --> Float64\n\nCompute the real part of the function evaluation of flat at a point xyz (a tuple, SVector, or a vector), i.e. return     Re[âˆ‘áµ¢ cáµ¢exp(2Ï€iğ†áµ¢â‹…ğ«)] with ğ†áµ¢ denoting a ğ†-vector in an allowed orbit in flat, and  cáµ¢ an associated coefficient (and with ğ« â‰¡ xyz).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.centering","page":"API","title":"Crystalline.centering","text":"centering(sg::SpaceGroup) --> Char\ncentering(sgnum::Integer, D::Integer=3) --> Char\n\nDetermines the conventional centering type of a given space/plane group sg (alternatively specified by its conventional number sgnum and dimensionality D by comparison with the Hermann-Mauguin notation's first letter. \n\nPossible output values, depending on dimensionality D, are (see ITA Sec. 9.1.4):\n\nD=2 â”Œ 'p': no centring (primitive)\n    â”” 'c': face centered\n\nD=3 â”Œ 'P': no centring (primitive)\n    â”œ 'I': body centred (innenzentriert)\n    â”œ 'F': all-face centred\n    â”œ 'A', 'B', 'C': one-face centred, (b,c) or (c,a) or (a,b)\n    â”” 'R': hexagonal cell rhombohedrally centred\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.classification-Tuple{BandRepSet}","page":"API","title":"Crystalline.classification","text":"classification(BRS::BandRepSet) --> String\n\nCalculate the symmetry indicator classification of a band representation set, meaning the  index-classification inferrable on the basis of symmetry alone.\n\nTechnically, the calculation answers a question like \"what direct product of Zâ‚™ groups is the the quotient group Xáµ‡Ë¢ = BSAI isomorphic to?\". \n\nSee e.g. Po, Watanabe, & Vishwanath, Nature Commun. 8, 50 (2017) for more information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.conventionalize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D","page":"API","title":"Crystalline.conventionalize","text":"conventionalize(Rsâ€²::DirectBasis, cntr::Char) --> Rs::DirectBasis\n\nTransforms a primitive DirectBasis Rsâ€² into its conventional equivalent Rs, with the  transformation dependent on the centering type cntr (P, I, F, R, A, C, and p, c); for centering P and p, the conventional and primive bases coincide.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.crystal-NTuple{6,Real}","page":"API","title":"Crystalline.crystal","text":"crystal(a,b,c,Î±,Î²,Î³) --> Rs::DirectBasis{3}\n\nCalculate basis vectors Râ‚, Râ‚‚, Râ‚ƒ in a 3D Cartesian basis  for a right-handed coordinate system with specified basis vector lengths  a, b, c (associated with  Râ‚, Râ‚‚, Râ‚ƒ, respectively) and specified interaxial angles Î±=âˆ (Râ‚‚,Râ‚ƒ), Î²=âˆ (Râ‚ƒ,Râ‚), Î³=âˆ (Râ‚,Râ‚‚), with âˆ â‰¡angle.\n\nFor definiteness, the Râ‚ basis vector is oriented along the x-axis of the Cartesian coordinate system, and the Râ‚‚ axis is  placed in the xy-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.crystal-Tuple{Real,Real,Real}","page":"API","title":"Crystalline.crystal","text":"crystal(a,b,Î³) --> DirectBasis{2}\n\nCalculate basis vectors Râ‚, Râ‚‚ in a 2D Cartesian basis for a  right-handed coordinate system with specified basis vector lengths  a, b (associated with  Râ‚, Râ‚‚, respectively) and specified  interaxial angle Î³=angle(Râ‚, Râ‚‚).\n\nFor definiteness, the Râ‚ basis vector is oriented along the x-axis of the Cartesian coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.crystal-Tuple{Real}","page":"API","title":"Crystalline.crystal","text":"crystal(a)  --> DirectBasis{1}\n\nReturn a one-dimensional crystal with lattice period a.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.crystalsystem-Union{Tuple{DirectBasis{D}}, Tuple{D}} where D","page":"API","title":"Crystalline.crystalsystem","text":"crystalsystem(R::DirectBasis)\n\nDetermine the crystal system of a point lattice specified in a  conventional DirectBasis using Tables 2.1.2.1, 9.1.7.1, & 9.1.7.2 of the International Tables of  Crystallography, Volume 1 (ITA).  There are 4 crystal systems in 2D and 7 in 3D (see ITA 2.1.2(iii)):\n\nDIM SYSTEM CONDITIONS FREE PARAMS\n1D linear none a\nâ€“â€“- â€“â€“â€“â€“â€“â€“â€“ â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“ â€“â€“â€“â€“â€“â€“â€“â€“â€“\n2D square a=b & Î³=90Â° a\n rectangular Î³=90Â° a,b\n hexagonal a=b & Î³=120Â° a\n oblique none a,b,Î³\nâ€“â€“- â€“â€“â€“â€“â€“â€“â€“ â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“ â€“â€“â€“â€“â€“â€“â€“â€“â€“\n3D cubic a=b=c & Î±=Î²=Î³=90Â° a\n hexagonal a=b & Î±=Î²=90Â° & Î³=120Â° a,c\n trigonal a=b & Î±=Î²=90Â° & Î³=120Â° a,c (a,Î± for hR)\n tetragonal a=b & Î±=Î²=Î³=90Â° a,c\n orthorhombic Î±=Î²=Î³=90Â° a,b,c\n monoclinic Î±=Î³=90Â° a,b,c,Î²â‰¥90Â°\n triclinic none a,b,c,Î±,Î²,Î³\n\nThe DirectBasis input is assumed to use conventional basis vectors;  i.e. not necessarily primitive. For primitive basis vectors, the  crystal system can be further reduced into 5 Bravais types in 2D and 14 in 3D.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.dim-Tuple{BandRep}","page":"API","title":"Crystalline.dim","text":"dim(BR::BandRep) --> Int64\n\nGet the number of bands included in a single BandRep BR; i.e. the \"band filling\" Î½ discussed in Po's papers.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.directbasis-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D","page":"API","title":"Crystalline.directbasis","text":"directbasis(sgnum, D=3;    abclims, Î±Î²Î³lims)\ndirectbasis(sgnum, Val(D); abclims, Î±Î²Î³lims) ---> DirectBasis{D}\n\nGenerates a (conventional) DirectBasis for a crystal compatible with  the space group number sgnum and dimensionality D. Free parameters in the lattice vectors are chosen randomly, with limits optionally supplied in abclims (lengths) and Î±Î²Î³lims (angles). By convention, the length of the first lattice vector (= a) is set to unity, such that the second and third (= b and c) lattice  vectors' lengths are relative to the first.\n\nLimits on the relative uniform distribution of lengths b and c can be specified as 2-tuple kwarg abclims; similarly, limits on  the angles Î±, Î², Î³ can be set via Î±Î²Î³lims (only affects  oblique, monoclinic, & triclinic lattices).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.find_representation","page":"API","title":"Crystalline.find_representation","text":"find_representation(symvals::AbstractVector{Number}, \n                    lgirs::AbstractVector{<:AbstractIrrep},\n                    Î±Î²Î³::Union{AbstractVector{<:Real},Nothing}=nothing,\n                    assert_return_T::Type{<:Union{Integer, AbstractFloat}}=Int))\n\n                    --> Vector{assert_return_T}\n\nFrom a vector (or vector of vectors) of symmetry eigenvalues symvals sampled along all the operations of a group gáµ¢, whose irreps are contained in irs (evaluated with optional free  parameters Î±Î²Î³), return the multiplicities of each irrep.\n\nOptionally, the multiciplities' element type can be specified via the assert_return_T argument (performing checked conversion; returns nothing if representation in  assert_return_T is impossible). This can be useful if one suspects a particular band to  transform like a fraction of an irrep (i.e., the specified symmetry data is incomplete).\n\nExtended help\n\nEffectively, this applies the projection operator Pâ½Ê²â¾ of each irrep's character set Ï‡â½Ê²â¾(gáµ¢) (j = 1, ... , Nâ±Ê³Ê³) to the symmetry data sáµ¢ â‰¡ symvals:\n\nPâ½Ê²â¾  â‰¡ (dâ±¼/|g|) âˆ‘áµ¢ Ï‡â½Ê²â¾(gáµ¢)*gáµ¢         [characters Ï‡â½Ê²â¾(gáµ¢), irrep dimension dâ±¼]\nPâ½Ê²â¾s = (dâ±¼/|g|) âˆ‘áµ¢ Ï‡â½Ê²â¾(gáµ¢)*sáµ¢ = nâ±¼,   [number of bands that transform like jth irrep]\n\nreturning the irrep multiplicities mâ±¼ â‰¡ nâ±¼/dâ±¼.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.herring-Union{Tuple{D}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1}}, Tuple{LGIrrep,AbstractArray{SymOperation{D},1},Union{Nothing, Array{var\"#s129\",1} where var\"#s129\"<:Real}}} where D","page":"API","title":"Crystalline.herring","text":"herring(lgir::LGIrrep, sgops::AbstractVector{SymOperation{D}},\n        Î±Î²Î³::Union{Vector{<:Real},Nothing}=nothing)        --> Tuple{Int, Int}\n\nComputes the Herring criterion for a small irrep lgir::LGIrrep, from \n\n[âˆ‘ Ï‡({Î²|b}Â²)]/[gâ‚€/M(k)]\n\nover symmetry operations {Î²,b} that take k â†’ -k. Here gâ‚€ is the order of the point group of the space group and M(k) is the order of the star(k) [both in a primitive basis].\n\nThe returned value, [âˆ‘ Ï‡({Î²|b}Â²)]/[gâ‚€/M(k)], is one of three integers in {1,-1,0}  corresponding to {real, pseudoreal, complex} reality. We remind that ISOTROPY's indication of the same reality types i {1,2,3}.\n\nThe provided space group operations sgops must be the set reduced by primitive translation vectors; i.e. using spacegroup(...) directly is not allowable in general (since the irreps we reference only include these \"reduced\" operations). This reduced set of operations can be obtained e.g. from the Î“ point irreps of ISOTROPY's dataset, or alternatively, from reduce_ops(spacegroup(...), true).\n\nAs a sanity check, a value of Î±Î²Î³ can be provided to check for invariance along a symmetry line/plane/general point in k-space. Obviously, the reality  type should invariant to this choice.\n\nImplementation:  See e.g. Inui's Eq. (13.48), Dresselhaus, p. 618, and  and Herring's original paper at https://doi.org/10.1103/PhysRev.52.361. We mainly followed Cornwell, p. 150-152 & 187-188.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.interpolate_kvpath-Tuple{AbstractArray{var\"#s12\",1} where var\"#s12\"<:(AbstractArray{var\"#s20\",1} where var\"#s20\"<:Real),Integer}","page":"API","title":"Crystalline.interpolate_kvpath","text":"interpolate_kvpath(kvs::AbstractVector{<:AbstractVector{<:Real}}, Ninterp::Integer) \n    --> Vector{Vector{Float64}}, Int64\n\nComputes an interpolated k-path between the discrete k-points in kvs, so that the interpolated path has approximately Ninterp points in total (typically fewer).\n\nSince the actual number of points in the path may deviate from the requested Ninterp, the actual number of points in the path is returned along with the interpolated itself.\n\nNote that, in general, it is not possible to do this so that all interpolated k-points are equidistant; but points are equidistant in-between the initial discrete points provided in kvs.\n\nSee also: splice_kvpath.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.isnormal-Union{Tuple{T}, Tuple{T,T}} where T<:(AbstractArray{var\"#s15\",1} where var\"#s15\"<:(SymOperation{var\"#s13\"} where var\"#s13\"))","page":"API","title":"Crystalline.isnormal","text":"isnormal(opsá´³::T, opsá´´::T; verbose::Bool=false) --> Bool\n\nDetermine whether the operations in group H are normal in the group G (each with  operations opsá´³ and opsá´´, respectively, of type T::AbstractVector{SymOperation{D}}), in the sense that \n\nghgâ»Â¹ âˆˆ H âˆ€ gâˆˆG, hâˆˆH\n\nReturns a Boolean answer (true if normal, false if not).\n\nNote: This that this compares space groups rather than space group types, i.e. the  comparison assumes a matching setting choice between H and G. To compare space  group types with different conventional settings, they must first be transformed to a shared setting.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.israyrep","page":"API","title":"Crystalline.israyrep","text":"israyrep(lgir::LGIrrep, Î±Î²Î³=nothing) -> (::Bool, ::Matrix)\n\nComputes whether a given little group irrep ir is a ray representation  by computing the coefficients Î±áµ¢â±¼ in Dáµ¢Dâ±¼=Î±áµ¢â±¼Dâ‚–; if any Î±áµ¢â±¼ differ  from unity, we consider the little group irrep a ray representation (as opposed to the simpler \"vector\" representations where Dáµ¢Dâ±¼=Dâ‚–). The function returns a boolean (true => ray representation) and the coefficient matrix Î±áµ¢â±¼.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.issubgroup-Union{Tuple{T}, Tuple{D}, Tuple{T,T}} where T<:AbstractArray{SymOperation{D},1} where D","page":"API","title":"Crystalline.issubgroup","text":"issubgroup(opsá´³::T, opsá´´::T) --> Bool\n\nDetermine whether the operations in group H are a subgroup of the group G (each with  operations opsá´³ and opsá´´, respectively, of type T::AbstractVector{SymOperation{D}}), i.e. whether H<G. Specifically, this requires that G and H are both groups and that  for every hâˆˆH there exists an element gâˆˆG such that h=g.\n\nReturns a Boolean answer (true if normal, false if not).\n\nNote: This compares space groups rather than space group types, i.e. the  comparison assumes a matching setting choice between H and G. To compare space  group types with different conventional settings, they must first be transformed to a shared setting.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.issymmorph","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(sgnum::Integer, D::Integer=3) --> Bool\n\nChecks whether a given space group sgnum (of dimensionality D) is symmorphic (true) or nonsymmorphic (false).\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.issymmorph-Tuple{SymOperation,Char}","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(op::SymOperation, cntr::Char) --> Bool\n\nChecks whether a given symmetry operation op is symmorphic (true) or nonsymmorphic (false). The operation is assumed to be given in a  conventional basis; but the check requires that the translation is zero  in a primitive basis. Accordingly, the centering cntr must provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.issymmorph-Tuple{Union{LittleGroup, SpaceGroup}}","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(sg::AbstractGroup) --> Bool\n\nChecks whether a given space group sg is symmorphic (true) or nonsymmorphic (false).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.iuc","page":"API","title":"Crystalline.iuc","text":"iuc(sgnum::Integer, D::Integer=3) --> String\n\nReturns the IUC (International Union of Crystallography) notation for space group number sgnum and dimensionality D, as used in the International Tables of Crystallography.  The notation is sometimes also known as the Hermann-Mauguin notation; the functionality is consequently aliased by hermannmauguin(sgnum, D).  IUC/Hermann-Mauguin notation applies in one, two, and three-dimensions.\n\nFor more information, see https://en.wikipedia.org/wiki/Hermann%E2%80%93Mauguin_notation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.levelsetlattice","page":"API","title":"Crystalline.levelsetlattice","text":"levelsetlattice(sgnum::Integer, D::Integer=2, idxmax::NTuple=ntuple(i->2,D))\n    --> UnityFourierLattice{D}\n\nCompute a \"neutral\"/uninitialized Fourier lattice basis, a UnityFourierLattice, consistent with the symmetries of the space group sgnum in dimension D. The resulting lattice flat is expanded in a Fourier basis split into symmetry-derived orbits, with intra-orbit  coefficients constrained by the symmetries of the space-group. The inter-orbit coefficients are, however, free and unconstrained.\n\nThe Fourier resolution along each reciprocal lattice vector is controlled by idxmax: e.g., if D = 2 and idxmax = (2, 3), the resulting Fourier lattice may contain  reciprocal lattice vectors (kâ‚, kâ‚‚) with kâ‚âˆˆ[0,Â±1,Â±2] and kâ‚‚âˆˆ[0,Â±1,Â±2,Â±3], referred  to a ğ†-basis.\n\nThis \"neutral\" lattice can, and usually should, be subsequently modulated by modulate (modulates the inter-orbit coefficients, which will often eliminate symmetries that may remain in the \"neutral\" configuration, where all inter-orbit coefficients are unity).\n\nExamples\n\nCompute a UnityFourierLattice, modulate it with random inter-orbit coefficients via modulate, and finally plot it (requires using PyPlot):\n\njulia> uflat = levelsetlattice(16, 2)\njulia> flat  = modulate(uflat)\njulia> Rs    = directbasis(16, 2) \njulia> plot(flat, Rs)\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.matrix","page":"API","title":"Crystalline.matrix","text":"matrix(BRS::BandRepSet[, includedim::Bool=false])\n\nReturn a matrix representation of BRS::BandRepSet, with band representations as columns  and irreps over rows.\n\nFor includedim=true the band filling (i.e. dim.(BRS)) is included as the last row.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}}}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}},Union{Nothing, Real}}} where D","page":"API","title":"Crystalline.modulate","text":"modulate(flat::UnityFourierLattice{D},\nmodulation::AbstractVector{ComplexF64}=rand(ComplexF64, length(getcoefs(flat))),\nexpon::Union{Nothing, Real}=nothing)\n                        --> ModulatedFourierLattice{D}\n\nDerive a concrete, modulated Fourier lattice from flat, a UnityFourierLattice  struct (that contains the interrelations between orbit coefficients), by  multiplying the \"normalized\" orbit coefficients by a modulation, a complex modulating vector (in general, should be complex; otherwise restores unintended symmetry to the lattice). Distinct modulation vectors produce distinct  realizations of the same lattice described by the original flat. By default, a random complex vector is used.\n\nAn exponent expon can be provided, which introduces a penalty term to short- wavelength features (i.e. high-|G| orbits) by dividing the orbit coefficients by |G|^expon; producing a more \"localized\" and \"smooth\" lattice boundary when expon > 0 (reverse for expon < 0). This basically amounts to a  continuous \"simplifying\" operation on the lattice (it is not necessarily a  smoothing operation; it simply suppresses \"high-frequency\" components). If expon = nothing, no rescaling is performed. \n\nThe normscale(!) methods exists to perform subsequent expon norm-rescaling  of a ModulatedFourierLattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.multtable-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.multtable","text":"multtable(ops::AbstractVector{<:SymOperation{D}})\n\nCompute the multiplication (or Cayley) table of a set of symmetry operations. A MultTable is returned, which contains symmetry operations  resulting from composition of row âˆ˜ col operators; the table of  indices give the symmetry operators relative to the ordering of  ops.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.normscale!-Tuple{ModulatedFourierLattice,Real}","page":"API","title":"Crystalline.normscale!","text":"normscale!(flat::ModulatedFourierLattice, expon::Real) --> ModulatedFourierLattice\n\nIn-place equivalent of normscale: changes flat.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.normscale-Tuple{ModulatedFourierLattice,Real}","page":"API","title":"Crystalline.normscale","text":"normscale(flat::ModulatedFourierLattice, expon::Real) --> ModulatedFourierLattice\n\nApplies subsequent norm-rescaling via expon; see detailed description  in modulate. An in-place variant is provided as normscale!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.pointgroup","text":"pointgroup(ops:AbstractVector{SymOperation{D}})\npointgroup(sg::AbstractGroup)\n\nComputes the point group associated with a space group sg (characterized by a set of operators ops, which, jointly with lattice translations generate  the space group), obtained by \"taking away\" any translational parts and  then reducing to the resulting unique rotational operations. (technically, in the language of Bradley & Cracknell, this is the so-called isogonal point group of sg; see Sec. 1.5).\n\nReturns a Vector of SymOperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.prepare_mpbcalc!-Union{Tuple{D}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real,String}} where D","page":"API","title":"Crystalline.prepare_mpbcalc!","text":"prepare_mpbcalc!(...)\n\nFormats a set of parameters that uniquely specify an MPB calculation, given a  space group number sgnum, a Fourier lattice flat, a DirectBasis Rs, a filling fraction filling for flat, interior and exterior (above, below the contour) permittivities Îµin and Îµout, as well as a list of k-vectors kvecs, an  identifying tag id (to label the calculation for book-keeping purposes), a  resolution for the MPB calculation res, and a selection of calculation type runtype (\"all\", \"te\", or \"tm\"). The results are written to requested IO io.\n\nOur preferred choice is to write these parameters to a bash file, with a name generated by the mpb_calcname(...) method.\n\nThe options are expected to be fed to the fourier-lattice.ctl file, e.g. through a bash script of the following kind:\n\n    IFS=$'\\n'; # stop command-substitutions from word-splitting at space\n\n    PATH_TO_MPB_EXECUTABLE \\\n        (cat ${calcname}.sh)\n        ctl/fourier-lattice.ctl 2>&1 | tee logs/${calcname}.log\n        \n    unset IFS; # restore usual command-substitution word-splitting practice\n\non gbar, PATH_TO_MPB_EXECUTABLE is ~/postdoc/mpb-transform-dev/1.8-dev/bin/mpb. Locally, in mpb-ctl we have a file run-fourier-lattice.sh which performs the  above, with calcname specified as an input parameter (assumed to be a subfolder /input/).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(flat::AbstractFourierLattice, cntr::Char) --> AbstractFourierLattice\n\nGiven flat referred to a conventional basis with centering cntr, compute the  derived (but physically equivalent) lattice flatâ€² referred to the associated  primitive basis. \n\nSpecifically, if flat refers to a direct conventional basis Rsâ‰¡(ğš ğ› ğœ) [with  coordinate-vectors ğ«â‰¡(râ‚, râ‚‚, râ‚ƒ)áµ€] then flatâ€² refers to a direct primitive  basis Rsâ€²â‰¡(ğšâ€² ğ›â€² ğœâ€²)â‰¡(ğš ğ› ğœ)P [with coordinate-vectors ğ«â€²â‰¡(râ‚â€², râ‚‚â€², râ‚ƒâ€²)áµ€=Pâ»Â¹ğ«], where P denotes the basis-change matrix obtained from primitivebasismatrix(...).\n\nTo compute the associated primitive basis vectors, see primitivize(::DirectBasis) [specifically, Rsâ€² = primitivize(Rs, cntr)].\n\nExamples\n\nA centered ('c') lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires using PyPlot):\n\njulia> sgnum = 5; D = 2; cntr = centering(sgnum, D)  # 'c' (body-centered)\n\njulia> Rs   = directbasis(sgnum, D)     # conventional basis (rectangular)\njulia> flat = levelsetlattice(sgnum, D) # Fourier lattice in basis of Rs\njulia> flat = modulate(flat)            # modulate the lattice coefficients\njulia> plot(flat, Rs)\n\njulia> Rsâ€²   = primitivize(Rs, cntr)    # primitive basis (oblique)\njulia> flatâ€² = primitivize(flat, cntr)  # Fourier lattice in basis of Rsâ€²\njulia> plot(flatâ€², Rsâ€²)\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.Basis{D},Integer}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(Vs::Basis, sgnum::Integer) --> Rsâ€²::Basis\n\nTransforms a conventional Basis (either DirectBasis or ReciprocalBasis) Vs into its primitive equivalent Vsâ€², provided that its centering differs from the conventional (P or p), by inferring the Bravais type from the space group number sgnum and applying an applying an appropriate (Basis-type specific) transformation. \n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(Rs::DirectBasis, cntr::Char) --> Rsâ€²::DirectBasis\n\nTransforms a conventional DirectBasis Rs into its primitive  equivalent Rsâ€², with the transformation dependent on the centering type cntr (P, I, F, R, A, C, and p, c); for centering P and p, the  conventional and primive bases coincide.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{ReciprocalBasis{D},Char}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(Gs::ReciprocalBasis, cntr::Char) --> Gsâ€²::ReciprocalBasis\n\nCalculates the primitive reciprocal basis associated with a  ReciprocalBasis Gs derived from a lattice with centering type cntr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{SymOperation{D},Char}, Tuple{SymOperation{D},Char,Bool}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --> SymOperation\n\nTransforms a symmetry operation op = Ww from a conventional cell to a primitive cell (specified by its centering character cntr), then denoted Ww; i.e. performs a basis change Ww = PpÂ¹WwPp where P and p describe basis change and origin shifts, respectively, of the coordinate transformation.\n\nBy default, translation parts of opâ€², i.e. w are reduced modulo 1 (modw = true); to disable this, set modw = false.\n\nFor additional details, see ITA6 Sec. 1.5.2.3, p. 84.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D},1}}, Tuple{D}, Tuple{AbstractArray{LGIrrep{D},1},Bool}} where D","page":"API","title":"Crystalline.realify","text":"realify(lgirs::AbstractVector{<:LGIrrep}, verbose::Bool=false)\n                                                    --> AbstractVector{<:LGIrrep}\n\nFrom lgirs, a vector of LGIrreps, determine the associated (gray) co-representations, i.e. the \"real\", or \"physical\" irreps that are relevant in scenarios with time-reversal symmetry.\n\nFor LGIrrep that are real (type=1), or that characterize a k-point ğ¤ which is not equivalent to -ğ¤ (i.e. its star does not include both ğ¤ and -ğ¤; equivalently, the little group includes time-reversal symmetry), the associated co-representations are just the  original irreps themselves.  For pseudo-real (type=2) and complex (type=3) LGIrreps where Â±ğ¤ are equivalent, the associated co-representations are built from pairs of irreps that \"stick\" together. This method computes this pairing and sets the LGIrrep field iscorep to true, to indicate that the resulting \"paired irrep\" (i.e. the co-representation) should be doubled with  itself (pseudo-real type) or its complex conjugate (complex type).\n\nBackground\n\nFor background, see p. 650-652 (and 622-626 for point groups) in Bradley & Cracknell's book. Their discussion is for magnetic groups (the \"realified\" irreps are really correspond to co-representations of \"gray\" magnetic groups).  Cornwell's book also does a good job of explicating this, as does Inui (p. 296-299).\n\nKeyword arguments\n\nverbose::Bool: if set to true, prints details about mapping from small irrep to small\n\ncorep for each LGIrrep (default: false).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.reciprocalbasis-Union{Tuple{Union{Tuple{Vararg{Array{var\"#s131\",1} where var\"#s131\"<:Real,D}}, DirectBasis{D}}}, Tuple{D}} where D","page":"API","title":"Crystalline.reciprocalbasis","text":"reciprocalbasis(Rs::DirectBasis{D}) --> Gs::ReciprocalBasis{D}\n\nCalculates the reciprocal basis associated with a DirectBasis Rs (alternatively supplied as an NTuple of Vectors). Returns a ReciprocalBasis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.schoenflies-Tuple{Integer}","page":"API","title":"Crystalline.schoenflies","text":"schoenflies(sgnum::Integer) --> String\n\nReturns the Schoenflies notation for a given space group number sgnum. Schoenflies notation only applies to point groups and  space groups, not plane groups, so this notation is only relevant in three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D","page":"API","title":"Crystalline.seitz","text":"seitz(op::SymOperation) --> String\n\nComputes the correponding Seitz notation {Î²|Ï„} for a symmetry operation in  triplet form.\n\nImplementation based on ITA5 Table 11.2.1.1 (for 3D)\n\n________________________________________________ |detW|trW|-3|-2 |-1 |0_|1|__2|3_| |  1         |    |    |  2 |  3 |  4 |  6 |  1 | |1_________|-1|-6|-4|-3|__m_|____|____|\n\nwith the elements of the table giving the type of symmetry operation in in Hermann-Mauguin notation. The rotation axis and the rotation sense are  computed following the rules in ITA6 Sec. 1.2.2.4(1)(b-c). The implementation has been checked against the Tables 1.4.2.1-5 of ITA6.\n\nNote that the orientation of axis (i.e. its sign) is not necessarily equal to the orientation picked in those tables; it is a matter of convention, and the conventions have not been explicated in ITA6.\n\nFor 2D operations, we elevate the operation to one in 3D that leaves the  3rd coordinate invariant, and then compute results using the 3D procedure.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D","page":"API","title":"Crystalline.spacegroup","text":"spacegroup(sgnum::Integer, D::Integer=3) --> SpaceGroup{D}\n\nReturn the space group symmetry operations in for a given space group number sgnum and  dimensionality D as a SpaceGroup{D}. The returned symmetry operations are specified relative to the conventional basis choice, i.e. are not necessarily primitive (see centering). If desired, operations for the primitive unit cell can be subsequently generated using  primitivize or reduce_ops.\n\nThe default choices for the conventional basis vectors are specified in Bilbao as: \n\nUnique axis b (cell choice 1) for space groups within the monoclinic system.\nObverse triple hexagonal unit cell for R space groups.\nOrigin choice 2: inversion center at (0,0,0). (Relevant for the centrosymmetric space groups where there are two origin choices, in the orthorhombic, tetragonal and cubic  systems)\n\nSee also directbasis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.splice_kvpath-Tuple{AbstractArray{var\"#s16\",1} where var\"#s16\"<:(AbstractArray{var\"#s15\",1} where var\"#s15\"<:Real),Integer}","page":"API","title":"Crystalline.splice_kvpath","text":"splice_kvpath(kvs::AbstractVector{<:AbstractVector{<:Real}}, Nsplice::Integer) \n                                                            --> Vector{Vector{Float64}}\n\nComputes an interpolated k-path between the discrete k-points in kvs, inserting Nsplice points between each pair of adjacent k-points.\n\nSee also interpolate_kvpath.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.subduction_count-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Union{Nothing, Array{var\"#s128\",1} where var\"#s128\"<:Real}}} where T<:Crystalline.AbstractIrrep","page":"API","title":"Crystalline.subduction_count","text":"subduction_count(Dá´³áµ¢, Dá´´â±¼[, Î±Î²Î³á´´â±¼]) --> Int64\n\nFor two groups G and H, where H is a subgroup of G, i.e. G>H, with associated  irreducible representations Dá´³áµ¢(g) and Dá´´â±¼(h) for elements gâˆˆG and hâˆˆH<G, compute  the compatibility relation between the two irreps from the subduction reduction  formula (or \"magic\" formula/Schur orthogonality relation): this is essentially how many times ná´³á´´áµ¢â±¼ the subduced representation Dá´³áµ¢â†“H contains the irrep Dá´´â±¼;  in other words, this gives the compatibility between the two irreps.\n\nOptionally, a vector Î±Î²Î³á´´â±¼ may be provided, to evaluate the characters/irreps  of Dá´³áµ¢ at a concrete value of Î±Î²Î³. This is e.g. meaningful for LGIrreps at non- special k-vectors. Defaults to nothing.\n\nThe reduction formula [e.g. Eq. (15) of https://arxiv.org/pdf/1706.09272.pdf] is:\n\n    ná´³á´´áµ¢â±¼ = |H|â»Â¹âˆ‘â‚â‚•â‚ Ï‡á´³áµ¢(h)Ï‡á´´â±¼(h)*\n\nAs an example, consider space group 207 and the two compatible k-vectors  Î“ (a point) and Î£ (a line):\n\n    lgirsd  = get_lgirreps(207, Val(3));\n    Î“_lgirs = lgirsd[\"Î“\"]; # at Î“ â‰¡ [0.0, 0.0, 0.0]\n    Î£_lgirs = lgirsd[\"Î£\"]; # at Î£ â‰¡ [Î±, Î±, 0.0]\n\nWe can test their compatibility like so:\n\n    [[subduction_count(Î“i, Î£j) for Î“i in Î“_lgirs] for Î£j in Î£_lgirs]\n    > # Î“â‚ Î“â‚‚ Î“â‚ƒ Î“â‚„ Î“â‚…\n    >  [ 1, 0, 1, 1, 2] # Î£â‚\n    >  [ 0, 1, 1, 2, 1] # Î£â‚‚\n\nThis entails the following compatibility relations between irreps at Î“ and Î£:\n\n    Î“â‚ â†’ Î£â‚           degeneracies: 1 â†’ 1\n    Î“â‚‚ â†’ Î£â‚‚                         1 â†’ 1\n    Î“â‚ƒ â†’ Î£â‚ + Î£â‚‚                    2 â†’ 1 + 1\n    Î“â‚„ â†’ Î£â‚ + 2Î£â‚‚                   3 â†’ 1 + 2\n    Î“â‚… â†’ 2Î£â‚ + Î£â‚‚                   3 â†’ 2 + 1\n\nwhere, in this case, all the small irreps are one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.transform-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{var\"#s22\",2} where var\"#s22\"<:Real}, Tuple{SymOperation{D},AbstractArray{var\"#s20\",2} where var\"#s20\"<:Real,Union{Nothing, AbstractArray{var\"#s17\",1} where var\"#s17\"<:Real}}, Tuple{SymOperation{D},AbstractArray{var\"#s16\",2} where var\"#s16\"<:Real,Union{Nothing, AbstractArray{var\"#s15\",1} where var\"#s15\"<:Real},Bool}} where D","page":"API","title":"Crystalline.transform","text":"transform(op::SymOperation, P::Matrix{<:Real}, \n          p::Union{Vector{<:Real}, Nothing}=nothing,\n          modw::Bool=true)                          --> SymOperation\n\nTransforms a symmetry operation op = Ww by a rotation matrix P and a translation vector p (can be nothing for zero-translations), producing a new symmetry operation  opâ€² = Ww: (see ITA6, Sec. 1.5.2.3.)\n\nWw = PpÂ¹WwPp with  W = PÂ¹WP and w = PÂ¹(w+Wp-p)\n\nBy default, the translation part of opâ€², i.e. w, is reduced to the range 01),  i.e. computed modulo 1. This can be disabled by setting modw = false (default, modw = true).\n\nSee also primitivize and conventionalize. \n\n\n\n\n\n","category":"method"},{"location":"api/#Unexported-API","page":"API","title":"Unexported API","text":"","category":"section"},{"location":"api/#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = true\nFilter  = t->any(tâ€²->basename(dirname(string(tâ€².file)))===\"src\", methods(t)) # restrict to methods in /src/ (e.g. exclude /build/)","category":"page"},{"location":"api/#Crystalline.BandRep","page":"API","title":"Crystalline.BandRep","text":"struct BandRep <: AbstractArray{Int64,1}\n\nwyckpos::String\nsitesym::String\nlabel::String\ndim::Integer\ndecomposable::Bool\nspinful::Bool\nirvec::Array{Int64,1}\nirlabs::Array{String,1}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.BandRepSet","page":"API","title":"Crystalline.BandRepSet","text":"struct BandRepSet <: AbstractArray{BandRep,1}\n\nsgnum::Integer\nbandreps::Array{BandRep,1}\nkvs::Array{KVec,1}\nklabs::Array{String,1}\nirlabs::Array{String,1}\nallpaths::Bool\nspinful::Bool\ntimeinvar::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.CharacterTable","page":"API","title":"Crystalline.CharacterTable","text":"struct CharacterTable{D}\n\nops::Array{SymOperation{D},1} where D\nirlabs::Array{String,1}\nchartable::Array{Complex{Float64},2}\ntag::String\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.CharacterTable-Union{Tuple{AbstractArray{var\"#s13\",1} where var\"#s13\"<:Crystalline.AbstractIrrep{D}}, Tuple{D}, Tuple{AbstractArray{var\"#s12\",1} where var\"#s12\"<:Crystalline.AbstractIrrep{D},Union{Nothing, AbstractArray{var\"#s45\",1} where var\"#s45\"<:Real}}} where D","page":"API","title":"Crystalline.CharacterTable","text":"CharacterTable(irs::AbstractVector{<:AbstractIrrep}, Î±Î²Î³=nothing)\n\nReturns a CharacterTable associated with vector of AbstractIrreps irs. \n\nOptionally, an Î±Î²Î³::AbstractVector{<:Real} variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for LGIrreps, a concrete k-vector sampled from a \"line-irrep\"). Defaults to nothing, indicating it being either  irrelevant (e.g., for PGIrreps) or all free parameters implicitly set to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.DirectBasis","page":"API","title":"Crystalline.DirectBasis","text":"DirectBasis{D} <: Basis{D}\n\nvecs:NTuple{D, SVector{D, Float64}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.KVec","page":"API","title":"Crystalline.KVec","text":"struct KVec\n\nkâ‚€::Array{Float64,1}\nkabc::Array{Float64,2}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.KVec-Tuple{AbstractString}","page":"API","title":"Crystalline.KVec","text":"KVec(str::AbstractString) --> KVec\n\nConstruct a KVec struct from a string representations of a k-vector, supplied  in either of the formats         \"($x,$y,$z)\", \"[$x,$y,$z]\", \"$x,$y,$z\", where the coordinates x,y, and z are strings that can contain fractions, decimal numbers, and \"free\" parameters {'Î±','Î²','Î³'} (or, alternatively, {'u','v','w'}). Returns the associated KVec.\n\nAny \"fixed\"/constant part of a coordinate must precede any free parts, e.g., x=\"1+Î±\" is allowable but x=\"Î±+1\" is not.\n\nFractions such as 1/2 can be parsed: but use of any other special operator besides / will result in faulty operations (e.g. do not use *).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.LGIrrep","page":"API","title":"Crystalline.LGIrrep","text":"struct LGIrrep{D} <: Crystalline.AbstractIrrep{D}\n\ncdml::String\nlg::LittleGroup{D} where D\nmatrices::Array{Array{Complex{Float64},2},1}\ntranslations::Array{Array{Float64,1},1}\ntype::Int64\niscorep::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.LittleGroup","page":"API","title":"Crystalline.LittleGroup","text":"struct LittleGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\nkv::KVec\nklab::String\noperations::Array{SymOperation{D},1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.ModulatedFourierLattice","page":"API","title":"Crystalline.ModulatedFourierLattice","text":"ModulatedFourierLattice{D} <: AbstractFourierLattice{D}\n\nA D-dimensional concrete Fourier/plane wave lattice, derived from  a UnityFourierLattice by scaling/modulating its orbit coefficients  by complex numbers; in general, the coefficients do not have unit norm.\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.MultTable","page":"API","title":"Crystalline.MultTable","text":"struct MultTable{D} <: AbstractArray{Int64,2}\n\noperations::Array{SymOperation{D},1} where D\nindices::Array{Int64,2}\nisgroup::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.PGIrrep","page":"API","title":"Crystalline.PGIrrep","text":"struct PGIrrep{D} <: Crystalline.AbstractIrrep{D}\n\ncdml::String\npg::PointGroup{D} where D\nmatrices::Array{Array{Complex{Float64},2},1}\ntype::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.PointGroup","page":"API","title":"Crystalline.PointGroup","text":"struct PointGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\nlabel::String\noperations::Array{SymOperation{D},1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.ReciprocalBasis","page":"API","title":"Crystalline.ReciprocalBasis","text":"ReciprocalBasis{D} <: Basis{D}\n\nvecs:NTuple{D, SVector{D, Float64}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.SpaceGroup","page":"API","title":"Crystalline.SpaceGroup","text":"struct SpaceGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\noperations::Array{SymOperation{D},1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.SymOperation","page":"API","title":"Crystalline.SymOperation","text":"struct SymOperation{D} <: AbstractArray{Float64,2}\n\nmatrix::Array{Float64,2}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.UnityFourierLattice","page":"API","title":"Crystalline.UnityFourierLattice","text":"UnityFourierLatticeFourierLattice{D} <: AbstractFourierLattice{D}\n\nA general D-dimensional Fourier/plane wave lattice (specified  by G-orbits and coefficient interrelations); specifies the allowable  interrelations between coefficients within each orbit. The norm of  all orbit coefficients is unity. The G-orbits orbits (& associated coefficients) are sorted in order of increasing |G| (low to high).\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.inv-Union{Tuple{T}, Tuple{T}} where T<:SymOperation","page":"API","title":"Base.inv","text":"inv(op::SymOperation{D}) --> SymOperation{D}\n\nCompute the inverse {W|w}â»Â¹ â‰¡ {Wâ»Â¹|-Wâ»Â¹w} of an operator op â‰¡ {W|w}.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Tuple{KVec,KVec,Char}","page":"API","title":"Base.isapprox","text":"isapprox(kv1::KVec, kv2::KVec[, cntr::Char]; kwargs...) --> Bool\n\nCompute approximate equality of two KVec's k1 and k2 modulo any  primitive G-vectors. To ensure that primitive G-vectors are used,  the centering type cntr (see centering(cntr, dim)) must be given (the dimensionality is inferred from kv1 and kv2). Optionally, keyword arguments (e.g., atol and rtol) can be  provided, to include in calls to Base.isapprox.\n\nIf cntr is not provided, the comparison will not account for equivalence by primitive G-vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.:âŠš-Union{Tuple{T}, Tuple{T,T}} where T<:SymOperation","page":"API","title":"Crystalline.:âŠš","text":"(âŠš)(op1::T, op2::T) where T<:SymOperation -->  Vector{Float64}\n\nCompose two symmetry operations op1={Wâ‚|wâ‚} and op2={Wâ‚‚|wâ‚‚} and return the quotient of wâ‚+Wâ‚*wâ‚‚ and 1. This functionality complements op1âˆ˜op2, which yields the translation modulo 1; accordingly,  translation(op1âˆ˜op2) + op1âŠšop2 yields the translation component of the composition op1 and op2 without taking it modulo 1, i.e. including any \"trivial\" lattice translation.\n\nNote that âŠš can be auto-completed in Julia via \\circledcirc+[tab]\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline._findsubgroup-Union{Tuple{T}, Tuple{T,T}} where T<:(AbstractArray{var\"#s45\",1} where var\"#s45\"<:(SymOperation{var\"#s22\"} where var\"#s22\"))","page":"API","title":"Crystalline._findsubgroup","text":"_findsubgroup(opsá´³, opsá´´) --> Bool, Vector{Int64}\n\nDetermine whether the group H (with operators opsá´´) is a subgroup of the group G (with operators opsá´³), i.e. whether H<G, and returns an indexing vector idxs of opsá´³ into opsá´´ (empty if false), such that opsá´³[idxs] â‰¡ H.  The first return argument is a Boolean (whether H<G); the second is idxs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.basis2matrix-Union{Tuple{Crystalline.Basis{D}}, Tuple{D}} where D","page":"API","title":"Crystalline.basis2matrix","text":"basis2matrix(Vs::Basis{D}) where D\n\nCompute a matrix [Vs[1] Vs[2] .. Vs[D]] from Vs::Basis{D}, i.e. a matrix whose columns are the basis vectors in Vs. \n\nNote: Trying to use the iteration interface via hcat(Vs...) does not lead to a correctly       inferred type Matrix::Float64 (and a type-assertion does not improve speed much).       Instead, we just use the .vec field of Vs directly, which achieves good performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D},DirectBasis{D}}} where D","page":"API","title":"Crystalline.cartesianize","text":"cartesianize(op::SymOperation{D}, Rs::DirectBasis{D}) --> SymOperation{D}\n\nConvert a SymOperation opË¡ from the lattice basis to a Cartesian basis, by computing the transformed operators opá¶œ = ğ‘*opË¡*ğ‘â»Â¹ via the Cartesian basis matrix ğ‘ (whose columns are the DirectBasis vectors Rs[i]). \n\nNote 1\n\nThe matrix ğ‘ maps vectors coefficients in a lattice basis ğ¯Ë¡ to coefficients in a Cartesian basis ğ¯á¶œ as ğ¯Ë¡ = ğ‘â»Â¹ğ¯á¶œ and vice versa as ğ¯á¶œ = ğ‘ğ¯Ë¡. Since a general transformation P  transforms an \"original\" vectors with coefficients ğ¯ to new coefficients ğ¯â€² via ğ¯â€² = Pâ»Â¹ğ¯ and since we here here consider the lattice basis as the \"original\" bais we have P = ğ‘â»Â¹.  As such, the transformation of the operator op transforms as opá¶œ = Pâ»Â¹*opË¡*P, i.e. opá¶œ = transform(opË¡,P) = transform(opË¡,ğ‘â»Â¹).\n\nNote 2\n\nThe display (e.g. Seitz and xyzt notation) of SymOperations e.g. in the REPL implicitly assumes integer coefficients for its point-group matrix: as a consequence, displaying  SymOperations in a Cartesian basis may yield undefine behavior. The matrix representation remains valid, however.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.compact_print_matrix","page":"API","title":"Crystalline.compact_print_matrix","text":"compact_print_matrix(io, X, prerow)\ncompact_print_matrix(io, X, prerow, elformat)\ncompact_print_matrix(io, X, prerow, elformat, sep)\n\n\nCanibalized and adapted from Base.print_matrix, specifically to allow a prerow input.\n\nShould never be used for printing very large matrices, as it will not wrap or abbreviate rows/columns.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.compatibility-Union{Tuple{Dict{String,var\"#s120\"} where var\"#s120\"<:AbstractArray{LGIrrep{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.compatibility","text":"compatibility(lgirsd)\n\n\nTODO: Seems entirely broken? Not sure what this is supposed to do.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.connectivity-Union{Tuple{Dict{String,var\"#s118\"} where var\"#s118\"<:AbstractArray{LGIrrep{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.connectivity","text":"connectivity(lgirsd)\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.find_compatible_kvec-Tuple{KVec,Array{KVec,1}}","page":"API","title":"Crystalline.find_compatible_kvec","text":"find_compatible_kvec(kv, kvsâ€²)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.findequiv-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{SymOperation{D},1},Char}} where D","page":"API","title":"Crystalline.findequiv","text":"findequiv(op::SymOperation, ops::AbstractVector{SymOperation{D}}, cntr::Char) \n                                            --> Tuple{Int, Vector{Float64}}\n\nSearch for an operator opâ€² in ops which is equivalent, modulo differences by primitive lattice translations Î”w, to op. Return the index of opâ€² in  ops, as well as the primitive translation difference Î”w. If no match is found returns (nothing, nothing).\n\nThe small irreps of op at wavevector k, Dâ±¼áµ[op], can be computed from  the small irreps of opâ€², Dâ±¼áµ[opâ€²], via Dâ±¼áµ[op] = exp(2Ï€ikâ‹…Î”w)Dâ±¼áµ[opâ€²]\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.fractionify!","page":"API","title":"Crystalline.fractionify!","text":"fractionify!(io::IO, x::Real, forcesign::Bool=true, tol::Real=1e-4)\n\nWrite a string representation of the nearest fraction (within a tolerance tol) of x to  io. If forcesign is true, the sign character of x is printed whether + or -  (otherwise, only printed if -).\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.is_compatible_kvec-Tuple{KVec,KVec}","page":"API","title":"Crystalline.is_compatible_kvec","text":"is_compatible_kvec(kv, kvâ€²)\n\n\nCheck whether a special k-point kv is compatible with a non-special k-point kvâ€². If so, return an Î±Î²Î³â€² value such that kv = kvâ€²(Î±Î²Î³â€²).\n\nTODO: This method should eventually be merged with the equivalently named method in       PhotonicBandConnectivity/src/connectivity.jl, which handles everything more correctly,       but currently has a slightly incompatible API.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.isapproxin-Tuple{Any,Any,Vararg{Any,N} where N}","page":"API","title":"Crystalline.isapproxin","text":"isapproxin(x, itr) --> Bool\n\nDetermine whether x âˆˆ itr with approximate equality.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.lattice_from_mpbparams-Tuple{IO}","page":"API","title":"Crystalline.lattice_from_mpbparams","text":"lattice_from_mpbparams(filepath::String)\n\nThis will load an input file with path filepath that was previously created by prepare_mpbcalc(!) and return the associated lattice as Julia objects.\n\nOutput:\n\n    Rs::DirectBasis,\n    flat::ModulatedFourierLattice,\n    isoval::Float64,\n    epsin::Float64,\n    epsout::Float64\n    kvecs::Vector{SVector{D, Float64}}\n\nNote that flat does not retain information about orbit groupings, since we flatten the  orbits into a single vector in lattice2mpb. This doesn't matter as we typically just want to plot the saved lattice (see plot_lattice_from_mpbparams from compat/pyplot.jl).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.matching_lgs-Tuple{BandRepSet}","page":"API","title":"Crystalline.matching_lgs","text":"matching_lgs(BRS::BandRepSet)\n\nFinds the matching little groups for each k-point referenced in BRS. This is mainly a  a convenience accessor, since e.g. littlegroup(::SpaceGroup, ::KVec) could already give the required little groups. The benefit here is that the resulting operator sorting of the returned little group is identical ISOTROPY's, so we can rely on that later on.\n\nNote that the little groups from ISOTROPY do not include copies of operators that would be  identical when transformed to a primitive basis. The operators are, however, still given in a conventional basis.\n\nAn error is thrown if a referenced little group cannot be found (currently, this can happen for certain k-points in Î¦-Î©, see src/specialrepresentationdomain_kpoints.jl)\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.orbit-Tuple{AbstractArray{var\"#s128\",1} where var\"#s128\"<:(AbstractArray{var\"#s127\",2} where var\"#s127\"<:Real),AbstractArray{var\"#s126\",1} where var\"#s126\"<:Real}","page":"API","title":"Crystalline.orbit","text":"orbit(Ws, x)\n\nComputes the orbit of x under a set of point-group operations Ws, i.e. computes the set {gx | gâˆˆG} where g denotes elements of the group G composed of all operations in Ws (possibly iterated, to ensure full coverage).\n\nAt the moment, we only consider point group operations; i.e. there are  no nonsymmorphic Ws parts. \n\nIt is important that Ws and x are given in the same basis. \n\n[W' = PWPâ»Â¹ if the basis change is from coordinates r to r' = Pr, corresponding  to a new set of basis vectors (xÌ‚')áµ€=xÌ‚áµ€P; e.g., when going from a direct basis representation to a Cartesian one, the basis change matrix is P = [Râ‚ Râ‚‚ Râ‚ƒ], with Ráµ¢ inserted as column vectors]\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.parsefraction-Tuple{AbstractString}","page":"API","title":"Crystalline.parsefraction","text":"parsefraction(str::AbstractString)\n\nParse a string str, allowing fraction inputs (e.g. \"1/2\"), return as Float64.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivebasismatrix","page":"API","title":"Crystalline.primitivebasismatrix","text":"primitivebasismatrix(cntr::Char, D::Integer) -> ::Matrix{Float64}\n\nGiven a centering type cntr and a dimensionality D, calculates a  transformation matrix P from a conventional to a primitive unit cell, using dictionary lookup.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.read_sgops_xyzt","page":"API","title":"Crystalline.read_sgops_xyzt","text":"read_sgops_xyzt(sgnum::Integer, dim::Integer=3)\n\nObtains the symmetry operations in xyzt format for a given space group number sgnum by reading from json files; see spacegroup for additional details. Much faster than crawling; generally preferred.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.relrand-Tuple{Tuple{var\"#s130\",var\"#s130\"} where var\"#s130\"<:Real}","page":"API","title":"Crystalline.relrand","text":"relrand(lims::NTuple{2,Real}, N=1) --> Vector{Float64}\n\nComputes a random number in the range specified by the two-element  tuple lims. The random numbers are sampled from two uniform  distributions, namely [lims[1], 1.0] and [1.0, lims[2]], in such a way as to ensure that the sampling is uniform over the joint   interval [-1/lims[1], -1.0] âˆª [1.0, lims[2]].\n\nThis is useful for ensuring an even sampling of numbers that are either smaller or larger than unity. Eg. for x=relrand((0.2,5.0)), x is equally probable to fall in inv(x)âˆˆ[1,5] or xâˆˆ[1,5].\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.rotation_order_3d-Tuple{Real,Real}","page":"API","title":"Crystalline.rotation_order_3d","text":"rotation_order_3d(detW::Real, trW::Real) --> Int\nrotation_order_3d(W::Matrix{<:Real}) --> Int\n\nDetermine the integer rotation order of a 3D point group operation with a 3Ã—3 matrix  representation W (alternatively specified by its determinant detW and its trace trW).\n\nThe rotation order of\n\nProper rotations is positive.\nImproper (mirrors, inversion, roto-inversions) is negative.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.uniquetol-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T","page":"API","title":"Crystalline.uniquetol","text":"uniquetol(a; kwargs)\n\nComputes approximate-equality unique with tolerance specifiable via keyword arguments kwargs in O(nÂ²) runtime.\n\nCopied from https://github.com/JuliaLang/julia/issues/19147#issuecomment-256981994\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.wyckbasis-Tuple{BandRepSet}","page":"API","title":"Crystalline.wyckbasis","text":"wyckbasis(BRS::BandRepSet) --> Vector{Vector{Int64}}\n\nComputes the (band representation) basis for bands generated by localized orbitals placed at the Wyckoff positions. Any band representation that can be expanded on this basis with positive integer coefficients  correspond to a trivial insulators (i.e. deformable to atomic limit). Conversely, bands that cannot are topological, either fragily (some   negative coefficients) or strongly (fractional coefficients).\n\n\n\n\n\n","category":"method"},{"location":"#Crystalline.jl","page":"Home","title":"Crystalline.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Crystalline.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"api.md\",]","category":"page"}]
}
