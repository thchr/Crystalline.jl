var documenterSearchIndex = {"docs":
[{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"Author = \"Thomas Christensen\"","category":"page"},{"location":"operations/#Symmetry-operations","page":"Symmetry operations","title":"Symmetry operations","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"A SymOperation{D} is a representation of a spatial symmetry operation g=mathbfWmathbfw, composed of a rotational mathbfW and a translation part mathbfw. The rotational and translation parts are assumed to share the same basis setting; by default, operations returned by Crystalline.jl are in the conventional setting of the International Tables of Crystallography, Volume A (ITA).","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"SymOperations can be constructed in two ways, either by explicitly specifying the mathbfW and mathbfw:","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"using Crystalline, StaticArrays\nW, w = (@SMatrix [1 0 0; 0 0 1; 0 1 0]), (@SVector [0, 0.5, 0])\nop = SymOperation(W, w)","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"or by its equivalent triplet form","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"op = SymOperation{3}(\"x,z+1/2,y\")","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"There is also a string macro accessor @S_str that allows triplet input via S\"x,z+1/2,y\".","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"In the above output, three equivalent notations for the symmetry operation are given: first, the Seitz notation {m₀₋₁₁|0,½,0}, then the triplet notation (x,z+1/2,y), and finally the explicit matrix notation.","category":"page"},{"location":"operations/#Components","page":"Symmetry operations","title":"Components","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"The rotation and translation parts mathbfW and mathbfw of a SymOperation{D} mathbfWmathbfw can be accessed via rotation and translation,  returning an SMatrix{D, D, Float64} and an SVector{D, Float64}, respectively. The \"augmented\" matrix mathbfWmathbfw can similarly be obtained via matrix.","category":"page"},{"location":"operations/#Operator-composition","page":"Symmetry operations","title":"Operator composition","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"Composition of two operators g_1 and g_2 is defined by ","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"g_1 circ g_2 = mathbfW_1mathbfw_1 circ mathbfW_2mathbfw_2 = mathbfW_1mathbfW_2mathbfw_1 + mathbfW_1mathbfw_2","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"We can compose two SymOperations in Crystalline via:","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"op1 = S\"z,x,y\" # 3₁₁₁⁺\nop2 = S\"z,y,x\" # m₋₁₀₁\nop1 * op2","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"which is accessed by an overloaded call to Base.*, i.e. the multiplication operator (this enables us to also call derived methods of *, such as integer powers (e.g., S\"-y,x-y,z\"^3 == S\"x,y,z\"). Note that composition is taken modulo integer lattice translations by default, such that","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"op2′ = S\"z,y,x+1\" # {m₋₁₀₁|001}\nop1 * op2′ # equivalent to compose(op1, op2′, true)","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"rather than S\"x+1,z,y\", which is the result of direct application of the above composition rule. To compute \"unreduced\" composition, the more precise compose variant of * can be used with an optional third argument false:","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"compose(op1, op2′, false)","category":"page"},{"location":"operations/#Operator-inverses","page":"Symmetry operations","title":"Operator inverses","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"The operator inverse is defined as mathbfWmathbfw = mathbfW^-1-mathbfW^-1mathbfw and can be computed via","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"inv(op1) # inv(3₁₁₁⁺)","category":"page"},{"location":"operations/#Action-of-symmetry-operators","page":"Symmetry operations","title":"Action of symmetry operators","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"A SymOperation can act on vectors in direct (RVec) or reciprocal (KVec) space. When acting in reciprocal space, translation parts of a SymOperation have no effect.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Crystalline","category":"page"},{"location":"api/#Exported-types","page":"API","title":"Exported types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"api/#Crystalline.BandRep","page":"API","title":"Crystalline.BandRep","text":"struct BandRep <: AbstractVector{Int64}\n\nwyckpos::String\nsitesym::String\nlabel::String\ndim::Int64\ndecomposable::Bool\nspinful::Bool\nirvec::Vector{Int64}\nirlabs::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.BandRepSet","page":"API","title":"Crystalline.BandRepSet","text":"struct BandRepSet <: AbstractVector{BandRep}\n\nsgnum::Int64\nbandreps::Vector{BandRep}\nkvs::Vector{<:KVec}\nklabs::Vector{String}\nirlabs::Vector{String}\nallpaths::Bool\nspinful::Bool\ntimeinvar::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.CharacterTable","page":"API","title":"Crystalline.CharacterTable","text":"struct CharacterTable{D} <: Crystalline.AbstractCharacterTable\n\nops::Array{SymOperation{D}, 1} where D\nirlabs::Vector{String}\ntable::Matrix{ComplexF64}\ntag::String\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D","page":"API","title":"Crystalline.KVec","text":"KVec{D}(str::AbstractString) --> KVec{D}\nKVec(str::AbstractString)    --> KVec\nKVec(::AbstractVector, ::AbstractMatrix) --> KVec\n\nReturn a KVec by parsing the string representations str, supplied in one of the following formats:\n\n\"($1,$2,$3)\"\n\"[$1,$2,$3]\"\n\"$1,$2,$3\"\n\nwhere the coordinates $1,$2, and $3 are strings that may contain fractions, decimal numbers, and \"free\" parameters {'α','β','γ'} (or, alternatively and equivalently, {'u','v','w'} or {'x','y','z'}).\n\nFractions such as 1/2 and decimal numbers can be parsed: but use of any other special operator besides / will produce undefined behavior (e.g. do not use *).\n\nExample\n\njulia> KVec(\"0.25,α,0\")\n[1/4, α, 0]\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.LGIrrep","page":"API","title":"Crystalline.LGIrrep","text":"struct LGIrrep{D} <: Crystalline.AbstractIrrep{D}\n\ncdml::String\ng::LittleGroup\nmatrices::Vector{Matrix{ComplexF64}}\ntranslations::Vector{Vector{Float64}}\nreality::Reality\niscorep::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.LittleGroup","page":"API","title":"Crystalline.LittleGroup","text":"struct LittleGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\nkv::KVec\nklab::String\noperations::Array{SymOperation{D}, 1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.ModulatedFourierLattice","page":"API","title":"Crystalline.ModulatedFourierLattice","text":"ModulatedFourierLattice{D} <: AbstractFourierLattice{D}\n\nA D-dimensional concrete Fourier (plane wave) lattice, derived from  a UnityFourierLattice{D} by scaling and modulating its orbit coefficients  by complex numbers; in general, the coefficients do not have unit norm.\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.MultTable","page":"API","title":"Crystalline.MultTable","text":"struct MultTable{D} <: AbstractArray{SymOperation{D}, 2}\n\noperations::Array{SymOperation{D}, 1} where D\ntable::Matrix{Int64}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.MultTable-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D","page":"API","title":"Crystalline.MultTable","text":"MultTable(ops::AbstractVector{<:SymOperation{D}}, modτ=true)\n\nCompute the multiplication (or Cayley) table of ops, an AbstractVector of SymOperation{D}s. The modτ keyword argument controls whether composition of operations is taken modulo lattice vectors (true, default) or not (false).\n\nA MultTable{D} is returned, which contains symmetry operations resulting from composition  of row and col operators; the table of indices give the symmetry operators relative to the ordering of ops.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.PGIrrep","page":"API","title":"Crystalline.PGIrrep","text":"struct PGIrrep{D} <: Crystalline.AbstractIrrep{D}\n\ncdml::String\ng::PointGroup\nmatrices::Vector{Matrix{ComplexF64}}\nreality::Reality\niscorep::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.PointGroup","page":"API","title":"Crystalline.PointGroup","text":"struct PointGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\nlabel::String\noperations::Array{SymOperation{D}, 1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D","page":"API","title":"Crystalline.RVec","text":"RVec{D}(str::AbstractString) --> RVec{D}\nRVec(str::AbstractString)    --> RVec\nRVec(::AbstractVector, ::AbstractMatrix) --> RVec\n\nReturn a RVec by parsing the string representations str, supplied in one of the following formats:\n\n\"($1,$2,$3)\"\n\"[$1,$2,$3]\"\n\"$1,$2,$3\"\n\nwhere the coordinates $1,$2, and $3 are strings that may contain fractions, decimal numbers, and \"free\" parameters {'α','β','γ'} (or, alternatively and equivalently, {'u','v','w'} or {'x','y','z'}).\n\nFractions such as 1/2 and decimal numbers can be parsed: but use of any other special operator besides / will produce undefined behavior (e.g. do not use *).\n\nExample\n\njulia> RVec(\"0.25,α,0\")\n[1/4, α, 0]\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.Reality","page":"API","title":"Crystalline.Reality","text":"Reality <: Enum{Int8}\n\nEnum type with instances\n\nREAL = 1\nPSEUDOREAL = -1\nCOMPLEX = 0\n\nThe return value of reality(::AbstractIrrep) and calc_reality is an instance of Reality. The reality type of an irrep is relevant for constructing \"physically real\" irreps (co-reps) via realify.\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.SpaceGroup","page":"API","title":"Crystalline.SpaceGroup","text":"struct SpaceGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\noperations::Array{SymOperation{D}, 1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.SubperiodicGroup","page":"API","title":"Crystalline.SubperiodicGroup","text":"struct SubperiodicGroup{D, P} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\noperations::Array{SymOperation{D}, 1} where D\n\nA subperiodic group of embedding dimension D and periodicity dimension P. \n\nFields: \n\noperations: the SymOperations of the finite factor group GT, where G is the\n\nsubperiodic group and T is the translation group of the associated lattice.\n\nnum: the canonical number of the group, following the International Tables for\n\nCrystallography, Volume E.\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.SymOperation","page":"API","title":"Crystalline.SymOperation","text":"struct SymOperation{D} <: AbstractMatrix{Float64}\n\nrotation::Crystalline.SquareStaticMatrices.SqSMatrix{D, Float64} where D\ntranslation::StaticArraysCore.SVector{D, Float64} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Exported-methods","page":"API","title":"Exported methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api/#Bravais.centering-Union{Tuple{Union{LittleGroup{D}, SpaceGroup{D}}}, Tuple{D}} where D","page":"API","title":"Bravais.centering","text":"centering(g::AbstractGroup) --> Char\n\nReturn the conventional centering type of a group. \n\nFor groups without lattice structure (e.g., point groups), return nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D","page":"API","title":"Bravais.conventionalize","text":"conventionalize(flat::AbstractFourierLattice, cntr::Char) --> ::typeof(flat′)\n\nGiven flat referred to a primitive basis with centering cntr, compute the derived (but physically equivalent) lattice flat′ referred to the associated conventional basis. \n\nSee also the complementary method primitivize(::AbstractFourierLattice, ::Char) for additional details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bravais.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D","page":"API","title":"Bravais.conventionalize","text":"conventionalize(v′::AbstractVec, cntr::Char)  -->  v::typeof(v′)\n\nTransforms a primitive coordinate vector v′ back to a standard conventional basis (specified by the centering type cntr), returning the conventional coordinate vector v.\n\nSee also primitivize and transform.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bravais.conventionalize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D","page":"API","title":"Bravais.conventionalize","text":"conventionalize(op′::SymOperation, cntr::Char, modw::Bool=true) --> typeof(op)\n\nReturn a symmetry operation op = Ww in a conventional setting, transformed from an input symmetry operation op′  Ww in a primitive setting.\n\nSee primitivize(::SymOperation, ::Char, ::Bool) for description of the centering argument cntr and optional argument modw.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Char}} where D","page":"API","title":"Bravais.primitivize","text":"primitivize(flat::AbstractFourierLattice, cntr::Char) --> ::typeof(flat)\n\nGiven flat referred to a conventional basis with centering cntr, compute the derived (but physically equivalent) lattice flat′ referred to the associated primitive basis. \n\nSpecifically, if flat refers to a direct conventional basis Rs  (mathbfa mathbfb mathbfc) [with coordinate vectors mathbfr  (r_1 r_2 r_3)^mathrmT] then flat′ refers to a direct primitive basis Rs′  (mathbfa mathbfb mathbfc)  (mathbfa mathbfb mathbfc)mathbfP [with coordinate vectors  mathbfr  (r_1 r_2 r_3)^mathrmT = mathbfP^-1mathbfr], where mathbfP denotes the basis-change matrix obtained from primitivebasismatrix(...).\n\nTo compute the associated primitive basis vectors, see primitivize(::DirectBasis, ::Char) [specifically, Rs′ = primitivize(Rs, cntr)].\n\nExamples\n\nA centered ('c') lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires using PyPlot):\n\njulia> sgnum = 5; D = 2; cntr = centering(sgnum, D)  # 'c' (body-centered)\n\njulia> Rs   = directbasis(sgnum, Val(D))     # conventional basis (rectangular)\njulia> flat = levelsetlattice(sgnum, Val(D)) # Fourier lattice in basis of Rs\njulia> flat = modulate(flat)                 # modulate the lattice coefficients\njulia> plot(flat, Rs)\n\njulia> Rs′   = primitivize(Rs, cntr)    # primitive basis (oblique)\njulia> flat′ = primitivize(flat, cntr)  # Fourier lattice in basis of Rs′\n\njulia> using PyPlot\njulia> plot(flat′, Rs′)\n\n\n\n\n\n","category":"method"},{"location":"api/#Bravais.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D}, Char}} where D","page":"API","title":"Bravais.primitivize","text":"primitivize(v::AbstractVec, cntr::Char)  -->  v′::typeof(v)\n\nTransforms a conventional coordinate vector v to a standard primitive basis (specified by the centering type cntr), returning the primitive coordinate vector v′.\n\nNote that a basis change matrix mathbfP (as returned e.g. by Bravais.primitivebasismatrix) transforms direct coordinate vectors (RVec) as mathbfr = mathbfP^-1mathbfr but transforms reciprocal coordinates (KVec) as mathbfk = mathbfP^textTmathbfk [ITA6]. Recall also the distinction between transforming a basis and the coordinates of a vector.\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bravais.primitivize-Union{Tuple{D}, Tuple{SymOperation{D}, Char}, Tuple{SymOperation{D}, Char, Bool}} where D","page":"API","title":"Bravais.primitivize","text":"primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --> typeof(op)\n\nReturn a symmetry operation op′  Ww in a primitive setting, transformed from an input symmetry operation op = Ww in a conventional setting. The operations Ww and Ww are related by a transformation Pp via (cf. Section 1.5.2.3 of [ITA6]):\n\nWw = Pp¹WwPp\n\nwhere P and p are the basis change matrix and origin shifts, respectively. The relevant transformation Pp is inferred from the centering type, as provided by cntr (see also Bravais.centering).\n\nBy default, translation parts of op′, i.e. w are reduced modulo 1 (modw = true); to disable this, set modw = false.\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).\n\n\n\n\n\n","category":"method"},{"location":"api/#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{<:Real}}","page":"API","title":"Bravais.transform","text":"transform(v::AbstractVec, P::AbstractMatrix)  -->  v′::typeof(v)\n\nReturn a transformed coordinate vector v′ from an original coordinate vector v using a basis change matrix P.\n\nNote that a basis change matrix mathbfP transforms direct coordinate vectors (RVec) as mathbfr = mathbfP^-1mathbfr but transforms reciprocal coordinates (KVec) as mathbfk = mathbfP^mathrmTmathbfk [ITA6]\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Bravais.transform-Union{Tuple{D}, Tuple{SymOperation{D}, AbstractMatrix{<:Real}}, Tuple{SymOperation{D}, AbstractMatrix{<:Real}, Union{Nothing, AbstractVector{<:Real}}}, Tuple{SymOperation{D}, AbstractMatrix{<:Real}, Union{Nothing, AbstractVector{<:Real}}, Bool}} where D","page":"API","title":"Bravais.transform","text":"transform(op::SymOperation, P::AbstractMatrix{<:Real}, \n          p::Union{AbstractVector{<:Real}, Nothing}=nothing,\n          modw::Bool=true)                           --> SymOperation\n\nTransforms a op = mathbfWmathbfw by a rotation matrix P and a translation vector p (can be nothing for zero-translations), producing a new symmetry operation  op′ = mathbfWmathbfw (cf. Section 1.5.2.3 of [ITA6])\n\nmathbfWmathbfw = mathbfPmathbfp^-1mathbfWmathbfw\nmathbfPmathbfp\n\nwith\n\nmathbfW = mathbfP^-1mathbfWmathbfP\ntext and \nmathbfw = mathbfP^-1(mathbfw+mathbfWmathbfp-mathbfp)\n\nBy default, the translation part of op′, i.e. mathbfw, is reduced to the range 01), i.e. computed modulo 1. This can be disabled by setting modw = false (default, modw = true).\n\nSee also Bravais.primitivize(::SymOperation, ::Char, ::Bool) and Bravais.conventionalize(::SymOperation, ::Char, ::Bool).\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.bandreps","page":"API","title":"Crystalline.bandreps","text":"bandreps(sgnum::Integer, D::Integer=3; \n         allpaths::Bool=false, spinful::Bool=false, timereversal::Bool=true)\n\nReturns the elementary band representations (EBRs) as a BandRepSet for space group sgnum and dimension D.\n\nKeyword arguments\n\nallpaths: include a minimal sufficient set (false, default) or all (true)              k-vectors. \nspinful: single- (false, default) or double-valued (true) irreps, as appropriate for            spinless and spinful particles, respectively. Only available for D=3.\ntimereversal: assume presence (true, default) or absence (false) of time-reversal                 symmetry.\n\nReferences\n\n3D EBRs are obtained from the Bilbao Crystallographic Server's  BANDREP program; please reference the original research papers noted there if used in published work.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.basisdim-Tuple{BandRepSet}","page":"API","title":"Crystalline.basisdim","text":"basisdim(BRS::BandRepSet) --> Int\n\nReturn the dimension of the (linearly independent parts) of a band representation set. This is d^textbs = d^textai in the notation of Po, Watanabe, & Vishwanath, Nature Commun. 8, 50 (2017), or  equivalently, the rank of matrix(BRS) over the ring of integers. This is the number of linearly independent basis vectors that span the expansions of a band structure viewed as symmetry data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.calc_reality-Union{Tuple{D}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}}, Tuple{LGIrrep{D}, AbstractArray{SymOperation{D}, 1}, Union{Nothing, Vector{<:Real}}}} where D","page":"API","title":"Crystalline.calc_reality","text":"calc_reality(lgir::LGIrrep, \n             sgops::AbstractVector{SymOperation{D}},\n             αβγ::Union{Vector{<:Real},Nothing}=nothing) --> ::(Enum Reality)\n\nCompute and return the reality of a lgir::LGIrrep using the Herring criterion.\n\nThe computed value is one of three integers in 1-10. In practice, this value is returned via a member of the Enum Reality, which has instances REAL = 1, PSEUDOREAL = -1, and COMPLEX = 0.\n\nOptional arguments\n\nAs a sanity check, a value of αβγ can be provided to check for invariance along a symmetry symmetry line/plane/general point in k-space. The reality must be invariant to this choice.\n\nNote\n\nThe provided space group operations sgops must be the set reduced by primitive translation vectors; i.e. using spacegroup(...) directly is not allowable in general (since the irreps we reference only include these \"reduced\" operations). This reduced set of operations can be obtained e.g. from the Γ point irreps of ISOTROPY's dataset, or alternatively, from reduce_ops(spacegroup(...), true).\n\nImplementation\n\nThe Herring criterion evaluates the following sum\n\n χ(βb²)g_0M(k)\n\nover symmetry operations βb that take k  -k. Here g_0 is the order of the point group of the space group and M(k) is the order of star(k) [both in a primitive basis].\n\nSee e.g. Cornwell, p. 150-152 & 187-188 (which we mainly followed), Inui Eq. (13.48),  Dresselhaus, p. 618, or Herring's original paper.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D}, DirectBasis{D}}} where D","page":"API","title":"Crystalline.cartesianize","text":"cartesianize(op::SymOperation{D}, Rs::DirectBasis{D}) --> SymOperation{D}\n\nConverts opˡ from a lattice basis to a Cartesian basis, by computing the transformed operators opᶜ = 𝐑*opˡ*𝐑⁻¹ via the Cartesian basis matrix 𝐑 (whose columns are the DirectBasis vectors Rs[i]). \n\nNote 1\n\nThe matrix 𝐑 maps vectors coefficients in a lattice basis 𝐯ˡ to coefficients in a Cartesian basis 𝐯ᶜ as 𝐯ˡ = 𝐑⁻¹𝐯ᶜ and vice versa as 𝐯ᶜ = 𝐑𝐯ˡ. Since a general transformation P  transforms an \"original\" vectors with coefficients 𝐯 to new coefficients 𝐯′ via 𝐯′ = P⁻¹𝐯 and since we here here consider the lattice basis as the \"original\" basis we have P = 𝐑⁻¹.  As such, the transformation of the operator op transforms as opᶜ = P⁻¹*opˡ*P, i.e. opᶜ = transform(opˡ,P) = transform(opˡ,𝐑⁻¹).\n\nNote 2\n\nThe display (e.g. Seitz and xyzt notation) of SymOperations e.g. in the REPL implicitly assumes integer coefficients for its point-group matrix: as a consequence, displaying  SymOperations in a Cartesian basis may produce undefined behavior. The matrix representation remains valid, however.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.characters-Union{Tuple{AbstractVector{<:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{<:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{<:Real}}}} where D","page":"API","title":"Crystalline.characters","text":"characters(irs::AbstractVector{<:AbstractIrrep}, αβγ=nothing)\n\nCompute the character table associated with vector of AbstractIrreps irs, returning a CharacterTable.\n\nOptional arguments\n\nOptionally, an αβγ::AbstractVector{<:Real} variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for LGIrreps, a concrete k-vector sampled from a \"line-irrep\"). Defaults to nothing, indicating it being either  irrelevant (e.g., for PGIrreps) or all free parameters implicitly set to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.classcharacters-Union{Tuple{AbstractVector{<:Crystalline.AbstractIrrep{D}}}, Tuple{D}, Tuple{AbstractVector{<:Crystalline.AbstractIrrep{D}}, Union{Nothing, AbstractVector{<:Real}}}} where D","page":"API","title":"Crystalline.classcharacters","text":"classcharacters(irs::AbstractVector{<:AbstractIrrep}, αβγ=nothing)\n\nCompute the character table associated with the conjugacy classes of a vector of AbstractIrreps irs, returning a ClassCharacterTable.\n\nSince characters depend only on the conjugacy class (this is not true for ray, or projective, irreps), the class-specific characters often more succintly communicate the same information as the characters for each operation (as returned by characters).\n\nSee also: classes.\n\nOptional arguments\n\nOptionally, an αβγ::AbstractVector{<:Real} variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for LGIrreps, a concrete k-vector sampled from a \"line-irrep\"). Defaults to nothing, indicating it being either  irrelevant (e.g., for PGIrreps) or all free parameters implicitly set to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.classes-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D","page":"API","title":"Crystalline.classes","text":"classes(ops::AbstractVector{SymOperation{D}}, [cntr::Union{Char, Nothing}])\n                                                -->  Vector{Vector{SymOperation{D}}}\n\nReturn the conjugacy classes of a group G defined by symmetry operations ops.\n\nDefinitions\n\nTwo elements a and b in G are considered conjugate if there exists a g  G such that gag^-1 = b. This defines an equivalence relation sim, i.e., we say that a sim b if a and b are conjugate. The conjugacy classes of G are the distinct equivalence classes that can be identified under this equivalence relation, i.e. the grouping of G into subsets that are equivalent under conjugacy.\n\nExtended help\n\nIf ops describe operations in a crystal system that is not primitive (i.e., if its centering type is not p or P) but is presented in a conventional setting, the centering symbol cntr must be given. If ops is not in a centered crystal system, or if ops is already reduced to a primitive setting, cntr should be given as nothing (default behavior) or, alternatively, as P or p (depending on dimensionality).\n\nA single-argument calls to classes with SpaceGroup or LittleGroup types will assume that ops is provided in a conventional setting, i.e., will forward the method call to classes(ops, centering(ops, dim(ops))). To avoid this behavior (if ops was already reduced to a primitive setting prior to calling classes), cntr should be provided explicitly as nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.classification-Tuple{AbstractVector{<:Integer}}","page":"API","title":"Crystalline.classification","text":"classification(BRS_or_F::Union{BandRepSet, Smith}) --> String\n\nReturn the symmetry indicator group X^textBS of an EBR basis F_or_BRS, provided as a BandRepSet or Smith decomposition.\n\nTechnically, the calculation answers the question \"what direct product of  mathbbZ_n groups is the the quotient group X^textBS = textBStextAI isomorphic to?\" (see Po, Watanabe, & Vishwanath, Nature Commun. 8, 50 (2017) for more information).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, KVec{D}}, Tuple{SymOperation{D}, KVec{D}, Bool}} where D","page":"API","title":"Crystalline.compose","text":"compose(op::SymOperation, kv::KVec[, checkabc::Bool=true])  -->  KVec\n\nReturn the composition op = mathbfWmathbfw and a reciprocal-space vector kv = mathbfk.\n\nThe operation is taken to act directly, returning\n\n    mathbfk = mathbfWmathbfwmathbfk = mathbfW^textTmathbfk\n\nNote the transposition of mathbfW, arising as a result of the implicit real-space basis of mathbfWmathbfw versus the reciprocal-space basis specification of mathbfk. Note also that the composition of mathbfWmathbfw with mathbfk is invariant under mathbfw, i.e., translations do not act in reciprocal space.\n\nExtended help\n\nIf checkabc = false, the free part of KVec is not transformed (can be improve  performance in situations when kabc is zero, and several transformations are requested).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.compose-Union{Tuple{D}, Tuple{SymOperation{D}, RVec{D}}} where D","page":"API","title":"Crystalline.compose","text":"compose(op::SymOperation, rv::RVec)  -->  RVec\n\nReturn the composition of op = mathbfWmathbfw and a real-space vector rv = mathbfr.\n\nThe operation is taken to act directly, returning\n\n    mathbfr = mathbfWmathbfwmathbfr = mathbfWmathbfr + mathbfw\n\nThe corresponding inverse action mathbfWmathbfw^-1mathbfr =  mathbfW^-1mathbfr - mathbfW^-1mathbfw can be obtained via  compose(inv(op), rv).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.compose-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Bool}} where T<:SymOperation","page":"API","title":"Crystalline.compose","text":"compose(op1::T, op2::T, modτ::Bool=true) where T<:SymOperation\n\nCompose two symmetry operations op1 = W₁w₁ and op2 = W₂w₂ using the composition rule (in Seitz notation)\n\nW₁w₁W₂w₂ = W₁W₂w₁+W₁w₂\n\nBy default, the translation part of the W₁W₂w₁+W₁w₂ is reduced to the range 01, i.e. computed modulo 1. This can be toggled off (or on) by the Boolean flag modτ (enabled, i.e. true, by default). Returns another SymOperation.\n\nThe multiplication operator * is overloaded for SymOperations to call compose, in the manner op1 * op2 = compose(op1, op2, modτ=true).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.cosets-Tuple{SiteGroup}","page":"API","title":"Crystalline.cosets","text":"cosets(g::SiteGroup) -> Array{SymOperation{D}, 1} where D\n\n\nReturn the cosets of a SiteGroup g.\n\nThe cosets generate the orbit of the Wyckoff position position(g) (see orbit(::SiteGroup)) and furnish a left-coset decomposition of the underlying space group, jointly with the operations in g itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.dim-Tuple{BandRep}","page":"API","title":"Crystalline.dim","text":"dim(BR::BandRep) --> Int\n\nReturn the number of bands included in the provided BandRep.\n\nIf the bands are \"nondetachable\" (i.e. if BR.decomposable = false), this is equal to a band connectivity μ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.find_isomorphic_parent_pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D","page":"API","title":"Crystalline.find_isomorphic_parent_pointgroup","text":"find_isomorphic_parent_pointgroup(g::AbstractVector{SymOperation{D}}) \n                                                --> PointGroup{D}, Vector{Int}, Bool\n\nGiven a group g (or a collection of operators, defining a group), identifies a \"parent\" point group that is isomorphic to g.\n\nThree variables are returned:\n\npg: the identified \"parent\" point group, with operators sorted to match the sorting of g's operators.\nIᵖ²ᵍ: a permutation vector which transforms the standard sorting of point group operations (as returned by pointgroup(::String)) to the operator sorting of g.\nequal: a boolean, identifying whether the point group parts of g operations are identical (true) or merely isomorphic to the point group operations in g. In practice, this indicates whether pg and g are in the same setting or not.\n\nImplementation\n\nThe identification is made partly on the basis of comparison of operators (this is is sufficient for the equal = true case) and partly on the basis of comparison of  multiplication tables (equal = false case); the latter can be combinatorially slow if the sorting of operators is unlucky (i.e., if permutation between sortings in g and pg differ by many pairwise permutations).\n\nBeyond mere isomorphisms of multiplication tables, the search also guarantees that all rotation orders are shared between pg and g. This disambiguates point groups that are intrinsically isomorphic to eachother, e.g. \"m\" and \"-1\", but which still differ in their spatial interpretation.\n\nProperties\n\nThe following properties hold for g, pg, and Iᵖ²ᵍ:\n\npg, Iᵖ²ᵍ, equal = find_isomorphic_parent_pointgroup(g)\n@assert MultTable(pg) == MultTable(pointgroup(g))\npg′ = pointgroup(label(pg), dim(pg)) # \"standard\" sorting\n@assert pg′[Iᵖ²ᵍ] == pg\n\nIf equal = true, the following also holds:\n\npointgroup(g) == operations(pg) == operations(pg′)[Iᵖ²ᵍ]\n\nExample\n\nsgnum = 141\nwp    = wyckoffs(sgnum, Val(3))[end] # 4a Wyckoff position\nsg    = spacegroup(sgnum, Val(3))\nsiteg = sitegroup(sg, wp)\npg, Iᵖ²ᵍ, equal = find_isomorphic_parent_pointgroup(siteg)\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.find_representation","page":"API","title":"Crystalline.find_representation","text":"find_representation(symvals::AbstractVector{Number}, \n                    lgirs::AbstractVector{<:AbstractIrrep},\n                    αβγ::Union{AbstractVector{<:Real},Nothing}=nothing,\n                    assert_return_T::Type{<:Union{Integer, AbstractFloat}}=Int),\n                    atol::Real=DEFAULT_ATOL,\n                    maxresnorm::Real=1e-3,\n                    verbose::Bool=false)\n\n                    --> Vector{assert_return_T}\n\nFrom a vector (or vector of vectors) of symmetry eigenvalues symvals sampled along all the operations of a group gᵢ, whose irreps are contained in irs (evaluated with optional free  parameters αβγ), return the multiplicities of each irrep.\n\nOptionally, the multiciplities' element type can be specified via the assert_return_T argument (performing checked conversion; returns nothing if representation in  assert_return_T is impossible). This can be useful if one suspects a particular band to  transform like a fraction of an irrep (i.e., the specified symmetry data is incomplete).\n\nIf no valid set of multiplicities exist (i.e., is solvable, and has real-valued and assert_return_T representible type), the sentinel value nothing is returned. Optional debugging information can in this case be shown by setting verbose=true.\n\nExtended help\n\nEffectively, this applies the projection operator P⁽ʲ⁾ of each irrep's character set χ⁽ʲ⁾(gᵢ) (j = 1, ... , Nⁱʳʳ) to the symmetry data sᵢ ≡ symvals:\n\nP⁽ʲ⁾  ≡ (dⱼ/|g|) ∑ᵢ χ⁽ʲ⁾(gᵢ)*gᵢ         [characters χ⁽ʲ⁾(gᵢ), irrep dimension dⱼ]\nP⁽ʲ⁾s = (dⱼ/|g|) ∑ᵢ χ⁽ʲ⁾(gᵢ)*sᵢ = nⱼ,   [number of bands that transform like jth irrep]\n\nreturning the irrep multiplicities mⱼ ≡ nⱼ/dⱼ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.findmaximal-Union{Tuple{AbstractArray{SiteGroup{D}, 1}}, Tuple{D}} where D","page":"API","title":"Crystalline.findmaximal","text":"findmaximal(sitegs::AbstractVector{<:SiteGroup})\n\nGiven a vector of SiteGroups associated with the Wyckoff positions of a space group, return those SiteGroups that are associated with a maximal Wyckoff positions.\n\nResults are returned as a view into the input vector (i.e. as an  AbstractVector{<:SiteGroup}). The associated Wyckoff positions can subsequently be retrieved via wyck.\n\nDefinition\n\nA Wyckoff position is maximal if its site symmetry group has higher order than the site symmetry groups of any \"nearby\" Wyckoff positions (i.e. Wyckoff positions that can be  connected, i.e. made equivalent, through parameter variation to the considered Wyckoff position).\n\nExample\n\njulia> sgnum = 5;\n\njulia> D = 2;\n\njulia> wps = wyckoffs(sgnum, Val(D));\n\njulia> sg  = spacegroup(sgnum, Val(D));\n\n\njulia> sitegs = SiteGroup.(Ref(sg), wps)\n2-element Vector{SiteGroup{2}}:\n [1] (4b: [α, β])\n [1, m₁₀] (2a: [0, β])\n\njulia> only(findmaximal(sitegs))\nSiteGroup{2} ⋕5 (c1m1) at 2a = [0, β] with 2 operations:\n 1\n m₁₀\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D","page":"API","title":"Crystalline.generate","text":"Generate a group from a finite set of generators gens. Returns a GenericGroup.\n\nKeyword arguments\n\nmodτ (default, true): the group composition operation can either be taken modulo lattice vectors (true) or not (false, useful e.g. for site symmetry groups). In this case, the provided generators will also be taken modulo integer lattice translations.\nNmax (default, 256): the maximum size of the generated group. This is essentially a cutoff set to ensure halting of execution in case the provided set of generators do not define a finite group (especially relevant if modτ=false). If more operations than Nmax are generated, the method throws an overflow error.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.generators-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Type{SpaceGroup{D}}}} where D","page":"API","title":"Crystalline.generators","text":"generators(num::Integer, T::Type{AbstractGroup{D}}[, optargs])\ngenerators(pgiuc::String, T::PointGroup{D}})              -->  Vector{SymOperation{D}}\n\nReturn the generators of the group type T which may be a SpaceGroup{D} or a  PointGroup{D} parameterized by its dimensionality D. Depending on T, the group is determined by inputting as the first argument:\n\nSpaceGroup{D}: the space group number num::Integer.\nPointGroup{D}: the point group IUC label pgiuc::String (see also [pointgroup(::String)) or the canonical point group number num::Integer, which can optionally be supplemented by an integer-valued setting choice setting::Integer (see also pointgroup(::Integer, ::Integer, ::Integer)]).\nSubperiodicGroup{D}: the subperiodic group number num::Integer.\n\nSetting choices match those in spacegroup, pointgroup, and subperiodicgroup.\n\nIterated composition of the returned symmetry operations will generate all operations of the associated space or point group (see generate). As an example, generate(generators(num,SpaceGroup{D}))andspacegroup(num, D)` return identical operations (with different sorting typically); and similarly so for point and subperiodic groups.\n\nExample\n\nGenerators of space group 200:\n\njulia> generators(200, SpaceGroup{3})\n4-element Vector{SymOperation{3}}:\n 2₀₀₁\n 2₀₁₀\n 3₁₁₁⁺\n -1\n\nGenerators of point group m-3m:\n\njulia> generators(\"2/m\", PointGroup{3})\n2-element Vector{SymOperation{3}}:\n 2₀₁₀\n -1\n\nGenerators of the Frieze group 𝓅2mg:\n\njulia> generators(7, SubperiodicGroup{2, 1})\n2-element Vector{SymOperation{2}}:\n 2\n {m₁₀|½,0}\n\nCiting\n\nPlease cite the original data sources if used in published work:\n\nSpace groups: Aroyo et al., Z. Kristallogr. Cryst. Mater. 221, 15 (2006);\nPoint group: Bilbao Crystallographic Server's 2D and 3D GENPOS;\nSubperiodic groups: Bilbao Crystallographic Server's SUBPERIODIC GENPOS.\n\nExtended help\n\nNote that the returned generators are not guaranteed to be the smallest possible set of generators; i.e., there may exist other generators with fewer elements (an example is space group 168 (P6), for which the returned generators are [2₀₀₁, 3₀₀₁⁺] even though the group could be generated by just [6₀₀₁⁺]). The returned generators, additionally, are not guaranteed to be minimal, i.e., they may include proper subsets that generate the group themselves (e.g., in space group 75 (P4), the returned generators are [2₀₀₁, 4₀₀₁⁺] although the subset [4₀₀₁⁺] is sufficient to generate the group). The motivation for this is to expose as similar generators as possible for similar crystal systems (see e.g. Section 8.3.5 of the International Tables of Crystallography, Vol. A, Ed. 5 (ITA) for further background).\n\nNote also that, contrary to conventions in ITA, the identity operation is excluded among the returned generators (except in space group 1) since it composes trivially and adds no additional context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.generators-Union{Tuple{P}, Tuple{D}, Tuple{Integer, Type{SubperiodicGroup{D, P}}}} where {D, P}","page":"API","title":"Crystalline.generators","text":"generators(num::Integer, ::Type{SubperiodicGroup{D,P}})  -->  ::Vector{SymOperation{D}}\n\nReturn a canonical set of generators for the subperiodic group num of embedding dimension D and periodicity dimension P. See also subperiodicgroup.\n\nSee also generators(::Integer, ::Type{SpaceGroup{D}}) and information therein.\n\nExample\n\njulia> generators(7, SubperiodicGroup{2, 1})\n2-element Vector{SymOperation{2}}:\n 2\n {m₁₀|½,0}\n\nData sources\n\nThe generators returned by this function were originally retrieved from the Bilbao Crystallographic Database, SUBPERIODIC GENPOS.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.is_abelian-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Nothing, Char}}} where D","page":"API","title":"Crystalline.is_abelian","text":"is_abelian(ops::AbstractVector{SymOperation}, [cntr::Union{Char, Nothing}])  -->  Bool\n\nReturn the whether the group composed of the elements ops is Abelian.\n\nA group G is Abelian if all its elements commute mutually, i.e., if g = hgh^-1 for all gh  G.\n\nSee discussion of the setting argument cntr in classes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.isnormal-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D","page":"API","title":"Crystalline.isnormal","text":"isnormal(opsᴳ::AbstractVector{<:SymOperation},\n         opsᴴ::AbstractVector{<:SymOperation};\n         verbose::Bool=false)                    --> Bool\n\nDetermine whether the operations in group H are normal in the group G (each with  operations opsᴳ and opsᴴ), in the sense that \n\nghg¹  H  gG  hH\n\nReturns a Boolean answer (true if normal, false if not).\n\nNote\n\nThis compares space groups rather than space group types, i.e. the comparison assumes a matching setting choice between H and G. To compare space group types with different conventional settings, they must first be transformed to a shared setting.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.israyrep","page":"API","title":"Crystalline.israyrep","text":"israyrep(lgir::LGIrrep, αβγ=nothing) -> (::Bool, ::Matrix)\n\nComputes whether a given little group irrep ir is a ray representation  by computing the coefficients αᵢⱼ in DᵢDⱼ=αᵢⱼDₖ; if any αᵢⱼ differ  from unity, we consider the little group irrep a ray representation (as opposed to the simpler \"vector\" representations where DᵢDⱼ=Dₖ). The function returns a boolean (true => ray representation) and the coefficient matrix αᵢⱼ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.issubgroup-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, AbstractArray{SymOperation{D}, 1}}} where D","page":"API","title":"Crystalline.issubgroup","text":"issubgroup(opsᴳ::T, opsᴴ::T′) where T⁽′⁾<:AbstractVector{SymOperation} --> Bool\n\nDetermine whether the operations in group H are a subgroup of the group G (each with  operations opsᴳ and opsᴴ, respectively), i.e. whether HG. Specifically, this requires that G and H are both groups and that for every hH there exists an element gG such that h=g.\n\nReturns a Boolean answer (true if normal, false if not).\n\nNote\n\nThis compares space groups rather than space group types, i.e. the comparison assumes a matching setting choice between H and G. To compare space group types with different conventional settings, they must first be transformed to a shared setting.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.issymmorph","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(sgnum::Integer, D::Integer=3) --> Bool\n\nReturn whether the space group with number sgnum and dimensionality D is symmorphic  (true) or nonsymmorphic (false).\n\nEquivalent to issymmorph(spacegroup(sgnum, D)) but uses memoization for performance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.issymmorph-Tuple{Crystalline.AbstractGroup}","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(sg::Union{SpaceGroup, LittleGroup}) --> Bool\n\nReturn whether a given space group sg is symmorphic (true) or nonsymmorphic (false).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.issymmorph-Union{Tuple{D}, Tuple{SymOperation{D}, Char}} where D","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(op::SymOperation, cntr::Char) --> Bool\n\nReturn whether a given symmetry operation op is symmorphic (true) or nonsymmorphic (false). \n\nThe operation is assumed provided in conventional basis with centering type cntr:  checking symmorphism is then equivalent to checking whether the operation's translation part is zero or a lattice vector in the associated primitive basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.iuc","page":"API","title":"Crystalline.iuc","text":"iuc(sgnum::Integer, D::Integer=3) --> String\n\nReturn the IUC (International Union of Crystallography) notation for space group number sgnum in dimension D (1, 2, or 3), as used in the International Tables of Crystallography.\n\nThe notation is sometimes also known as the Hermann-Mauguin notation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.levelsetlattice-Union{Tuple{Integer}, Tuple{D′}, Tuple{Integer, Integer}, Tuple{Integer, Integer, Tuple{Vararg{Int64, D′}}}} where D′","page":"API","title":"Crystalline.levelsetlattice","text":"levelsetlattice(sgnum::Integer, D::Integer=2, idxmax::NTuple=ntuple(i->2,D))\n    --> UnityFourierLattice{D}\n\nCompute a \"neutral\"/uninitialized Fourier lattice basis, a UnityFourierLattice, consistent with the symmetries of the space group sgnum in dimension D.  The resulting lattice flat is expanded in a Fourier basis split into symmetry-derived orbits, with intra-orbit coefficients constrained by the symmetries of the space-group. The inter-orbit coefficients are, however, free and unconstrained.\n\nThe Fourier resolution along each reciprocal lattice vector is controlled by idxmax: e.g., if D = 2 and idxmax = (2, 3), the resulting Fourier lattice may contain  reciprocal lattice vectors (k₁, k₂) with k₁∈[0,±1,±2] and k₂∈[0,±1,±2,±3], referred  to a 𝐆-basis.\n\nThis \"neutral\" lattice can, and usually should, be subsequently modulated by modulate (which modulates the inter-orbit coefficients, which may eliminate \"synthetic symmetries\" that can exist in the \"neutral\" configuration, due to all  inter-orbit coefficients being set to unity).\n\nExamples\n\nCompute a UnityFourierLattice, modulate it with random inter-orbit coefficients  via modulate, and finally plot it (via PyPlot.jl):\n\njulia> uflat = levelsetlattice(16, Val(2))\njulia> flat  = modulate(uflat)\njulia> Rs    = directbasis(16, Val(2)) \njulia> using PyPlot\njulia> plot(flat, Rs)\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}, Tuple{Integer, Val{D}, JLD2.JLDFile, JLD2.JLDFile}} where D","page":"API","title":"Crystalline.lgirreps","text":"lgirreps(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3))\n                                                -> Dict{String, Vector{LGIrrep{D}}}\n\nFor given space group number sgnum and dimension D, return the associated little group (or \"small\") irreps (LGIrrep{D}s) at high-symmetry k-points, lines, and planes. \n\nReturns a Dict with little group k-point labels as keys and vectors of LGIrrep{D}s as values.\n\nNotes\n\nThe returned irreps are complex in general. Real irreps (as needed in time-reversal invariant settings) can subsequently be obtained with the realify method.\nReturned irreps are spinless.\nThe irrep labelling follows CDML conventions.\nIrreps along lines or planes may depend on free parameters αβγ that parametrize the k point. To evaluate the irreps at a particular value of αβγ and return the associated matrices, use (lgir::LGIrrep)(αβγ). If αβγ is an empty tuple in this call, the matrices associated with lgir will be evaluated assuming αβγ = [0,0,...].\n\nReferences\n\nThe underlying data is sourced from the ISOTROPY ISO-IR dataset. Please cite original reference material associated with ISO-IR:\n\nStokes, Hatch, & Campbell,  ISO-IR, ISOTROPY Software Suite.\nStokes, Campbell, & Cordes, Acta Cryst. A. 69, 388-395 (2013).\n\nThe ISO-IR dataset is occasionally missing some k-points that lie outside the basic domain but still resides in the representation domain (i.e. k-points with postscripted 'A', 'B', etc. labels, such as 'ZA'). In such cases, the missing irreps may instead have been manually sourced from the Bilbao Crystallographic Database.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, JLD2.JLDFile}} where D","page":"API","title":"Crystalline.littlegroups","text":"littlegroups(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3)) \n                                                    -> Dict{String, LittleGroup{D}}\n\nFor given space group number sgnum and dimension D, return the associated little groups (LittleGroups{D}s) at high-symmetry k-points, lines, and planes (see also lgirreps).\n\nReturns a Dict with little group k-point labels as keys and vectors of LittleGroup{D}s as values.\n\nNotes\n\nA conventional crystallographic setting is assumed (as in spacegroup).\n\nUnlike spacegroup, \"centering\"-copies of symmetry operations are not included in the returned LittleGroups; as an example, space group 110 (body-centered, with centering symbol 'I') has a centering translation [1/2,1/2,1/2] in the conventional setting: the symmetry operations returned by spacegroup thus includes e.g. both {1|0} and  {1|½,½,½} while the symmetry operations returned by littlegroups only include {1|0} (and so on).\n\nCurrently, only D = 3 is supported.\n\nReferences\n\nThe underlying data is sourced from the ISOTROPY dataset: see also lgirreps.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.matrix-Tuple{BandRepSet}","page":"API","title":"Crystalline.matrix","text":"matrix(BRS::BandRepSet; includedim::Bool=true)\n\nReturn a matrix representation of BRS::BandRepSet, with band representations as columns  and irreps over rows.\n\nBy default, the last row will give the \"filling\" of each BandRep (or, more precisely, number of included bands per BandRep, i.e. dim.(BRS). To toggle this off, set the keyword argument includedim to false (default is includedim = true).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}, Union{Nothing, Real}}, Tuple{Crystalline.AbstractFourierLattice{D}, Union{Nothing, AbstractVector{ComplexF64}}, Union{Nothing, Real}, Union{Nothing, ReciprocalBasis{D}}}} where D","page":"API","title":"Crystalline.modulate","text":"modulate(flat::UnityFourierLattice{D},\nmodulation::AbstractVector{ComplexF64}=rand(ComplexF64, length(getcoefs(flat))),\nexpon::Union{Nothing, Real}=nothing, Gs::Union{ReciprocalBasis{D}, Nothing}=nothing)\n                        --> ModulatedFourierLattice{D}\n\nDerive a concrete, modulated Fourier lattice from a UnityFourierLattice flat (containing the interrelations between orbit coefficients), by  multiplying the \"normalized\" orbit coefficients by a modulation, a complex modulating vector (in general, should be complex; otherwise restores unintended symmetry to the lattice). Distinct modulation vectors produce distinct  realizations of the same lattice described by the original flat. By default, a random complex vector is used.\n\nAn exponent expon can be provided, which introduces a penalty term to short- wavelength features (i.e. high-|G| orbits) by dividing the orbit coefficients by |G|^expon; producing a \"simpler\" and \"smoother\" lattice boundary when expon > 0 (reverse for expon < 0). This basically amounts to a  continuous \"simplifying\" operation on the lattice (it is not necessarily a  smoothing operation; it simply suppresses \"high-frequency\" components). If expon = nothing, no rescaling is performed. If Gs is provided as nothing, the orbit norm is computed in the reciprocal lattice basis (and, so, may not strictly speaking be a norm if the lattice basis is not cartesian); to account for the basis explicitly, Gs must be provided as a ReciprocalBasis, see also normscale.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.mulliken-Union{Tuple{PGIrrep{D}}, Tuple{D}} where D","page":"API","title":"Crystalline.mulliken","text":"Return the Mulliken label of a point group irrep pgir.\n\nNotes\n\nThis functionality is a simple mapping between the tabulated CDML point group irrep labels and associated Mulliken labels, using the listings at the Bilbao Crystallographic Database [1].\n\nIgnoring subscript, the rough rules associated with assignment of Mulliken labels are:\n\nIrrep dimensionality: \n1D irreps: if a real irrep, assign A or B (B if antisymmetric under a principal  rotation); if a complex irrep, assigned label ¹E or ²E.\n2D irreps: assign label E\n3D irreps: assign label T\nu and g subscripts: if the group contains inversion, indicate whether irrep is symmetric (g ~ gerade) or antisymmetric (ᵤ ~ ungerade) under inversion.\nPrime superscripts: if the group contains a mirror m aligned with a principal  rotation axis, but does not contain inversion, indicate whether irrep is symmetric (′)  or antisymmetric (′′) under this mirror.\nNumeral subscripts: the rules for assignment of numeral subscripts are too too complicated in general - and indeed, we are unaware of a general coherent rule – to describe here.\n\nReferences\n\n[1]: Bilbao Crystallographic Database's   Representations PG program.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.nontrivial_factors-Tuple{Smith}","page":"API","title":"Crystalline.nontrivial_factors","text":"nontrivial_factors(F::Smith) -> Any\n\n\nReturn the nontrivial (i.e., ≠ {0,1}) elementary factors of an EBR basis, provided as a BandRepSet or Smith decomposition.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.normscale!-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D","page":"API","title":"Crystalline.normscale!","text":"normscale!(flat::ModulatedFourierLattice, expon::Real,\n           Gs::Union{ReciprocalBasis, Nothing} = nothing) --> ModulatedFourierLattice\n\nIn-place equivalent of normscale: mutates flat.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.normscale-Union{Tuple{D}, Tuple{ModulatedFourierLattice{D}, Real}, Tuple{ModulatedFourierLattice{D}, Real, Union{Nothing, ReciprocalBasis{D}}}} where D","page":"API","title":"Crystalline.normscale","text":"normscale(flat::ModulatedFourierLattice, expon::Real, \n          Gs::Union{ReciprocalBasis, Nothing} = nothing)  --> ModulatedFourierLattice\n\nApplies inverse-orbit norm rescaling of expansion coefficients with a norm exponent expon. If Gs is nothing, the orbit norm is computed in the lattice basis (and, so, is not strictly a norm); by providing Gs as ReciprocalBasis, the norm is evaluated correctly in cartesian setting. See further discussion in modulate.\n\nAn in-place equivalent is provided in normscale!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.orbit-Tuple{SiteGroup}","page":"API","title":"Crystalline.orbit","text":"orbit(g::SiteGroup)  -->  Vector{WyckoffPosition}\n\nCompute the orbit of the Wyckoff position associated with the site symmetry group g.\n\nExtended help\n\nThe orbit of a Wyckoff position mathbfr in a space group G is defined as the set of inequivalent points in the unit cell that can be obtained by applying the elements of G to mathbfr. Equivalently, every element of the orbit of mathbfr can be written as the composition of a coset representative of the Wyckoff position's site group in G with mathbfr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.orbit-Union{Tuple{D}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}}, Tuple{AbstractArray{SymOperation{D}, 1}, Union{Crystalline.AbstractVec{D}, AbstractPoint{D}}, Union{Nothing, AbstractMatrix{<:Real}}}} where D","page":"API","title":"Crystalline.orbit","text":"orbit(g::AbstractVector{<:SymOperation}, kv::KVec, cntr::Char)  -->  Vector{KVec{D}}\norbit(lg::LittleGroup)\norbit(lgir::LGIrrep)\n\nReturn the orbit of of the reciprocal-space vector kv under the action of the group g, also known as the star of k.\n\nThe orbit of kv in g is the set of inequivalent k-points obtained by composition of all the symmetry operations of g with kv. Two reciprocal vectors mathbfk and mathbfk are equivalent if they differ by a primitive reciprocal lattice vector.\n\nIf kv and g are specified in a conventional basis but refer to a non-primitive lattice, the centering type cntr must be provided to ensure that only equivalence by primitive (not conventional) reciprocal lattice vectors are considered. If the centering type of the group g can be inferred from g (e.g., if g is a SpaceGroup), orbit will assume a conventional setting and use the inferred centering type; otherwise, if cntr is neither explicitly set nor inferrable, a primitive setting is assumed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.pgirreps","page":"API","title":"Crystalline.pgirreps","text":"pgirreps(iuclab::String, ::Val{D}=Val(3); mullikken::Bool=false) where D ∈ (1,2,3)\npgirreps(iuclab::String, D; mullikken::Bool=false)\n\nReturn the (crystallographic) point group irreps of the IUC label iuclab of dimension D as a Vector{PGIrrep{D}}.\n\nNotation\n\nThe irrep labelling follows the conventions of CDML [1] [which occasionally differ from those in e.g. Bradley and Cracknell, The Mathematical Theory of Symmetry in Solids  (1972)].\n\nTo use Mulliken (\"spectroscopist\") irrep labels instead, set the keyword argument mulliken = true (default, false). See also [mulliken`](@ref).\n\nData sources\n\nThe data is sourced from the Bilbao Crystallographic Server [2]. If you are using this  functionality in an explicit fashion, please cite the original reference [3].\n\nReferences\n\n[1]: Cracknell, Davies, Miller, & Love, Kronecher Product Tables 1 (1979).\n\n[2]: Bilbao Crystallographic Database's   Representations PG program.\n\n[3]: Elcoro et al.,    J. of Appl. Cryst. 50, 1457 (2017)\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D}, 1}}, Tuple{D}} where D","page":"API","title":"Crystalline.pointgroup","text":"pointgroup(ops:AbstractVector{SymOperation{D}})\npointgroup(sg::AbstractGroup)\n\nComputes the point group associated with a space group sg (characterized by a set of operators ops, which, jointly with lattice translations generate  the space group), obtained by \"taking away\" any translational parts and  then reducing to the resulting unique rotational operations. (technically, in the language of Bradley & Cracknell, this is the so-called isogonal point group of sg; see Sec. 1.5).\n\nReturns a Vector of SymOperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.pointgroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Integer}} where D","page":"API","title":"Crystalline.pointgroup","text":"pointgroup(pgnum::Integer, ::Union{Val{D}, Integer}=Val(3), setting::Integer=1)\n                                                                  -->  PointGroup{D}\n\nReturn the symmetry operations associated with the point group identfied with canonical number pgnum in dimension D as a PointGroup{D}. The connection between a point group's numbering and its IUC label is enumerated in Crystalline.PG_NUM2IUC[D] and Crystalline.IUC2NUM[D].\n\nCertain point groups feature in multiple setting variants: e.g., IUC labels 321 and 312 both correspond to pgnum = 18 and correspond to the same group structure expressed in two different settings. The setting argument allows choosing between these setting variations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.pointgroup-Union{Tuple{String}, Tuple{D}, Tuple{String, Val{D}}} where D","page":"API","title":"Crystalline.pointgroup","text":"pointgroup(iuclab::String, ::Union{Val{D}, Integer}=Val(3))  -->  PointGroup{D}\n\nReturn the symmetry operations associated with the point group identified with label iuclab in dimension D as a PointGroup{D}.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D}, 1}}, Tuple{D}} where D","page":"API","title":"Crystalline.realify","text":"realify(lgirs::AbstractVector{<:LGIrrep}; verbose::Bool=false)\n                                                    --> AbstractVector{<:LGIrrep}\n\nFrom lgirs, a vector of LGIrreps, determine the associated (gray) co-representations, i.e. the \"real\", or \"physical\" irreps that are relevant in scenarios with time-reversal symmetry.\n\nFor LGIrrep that are REAL, or that characterize a k-point 𝐤 which is not equivalent to -𝐤 (i.e. its star does not include both 𝐤 and -𝐤; equivalently, the little group includes time-reversal symmetry), the associated co-representations are just the  original irreps themselves.  For PSEUDOREAL and COMPLEX LGIrreps where ±𝐤 are equivalent, the associated co-representations are built from pairs of irreps that \"stick\" together. This method computes this pairing and sets the LGIrrep field iscorep to true, to indicate that the resulting \"paired irrep\" (i.e. the co-representation) should be doubled with  itself (PSEUDOREAL reality) or its complex conjugate (COMPLEX reality).\n\nBackground\n\nFor background, see p. 650-652 (and p. 622-626 for point groups) in Bradley & Cracknell's book. Their discussion is for magnetic groups (the \"realified\" irreps are, in fact, simply co-representations of the \"gray\" magnetic groups).  Cornwell's book also explicates this at some length as does Inui et al. (p. 296-299).\n\nKeyword arguments\n\nverbose::Bool: if set to true, prints details about mapping from small irrep to small\n\ncorep for each LGIrrep (default: false).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.realify-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Crystalline.AbstractIrrep","page":"API","title":"Crystalline.realify","text":"realify(pgirs::AbstractVector{T}) where T<:AbstractIrrep --> Vector{T}\n\nReturn physically real irreps (coreps) from a set of conventional irreps (as produced by e.g. pgirreps). Fallback method for point-group-like AbstractIrreps.\n\nExample\n\njulia> pgirs = pgirreps(\"4\", Val(3));\njulia> characters(pgirs)\nCharacterTable{3}: ⋕9 (4)\n───────┬────────────────────\n       │ Γ₁  Γ₂    Γ₃    Γ₄ \n───────┼────────────────────\n     1 │  1   1     1     1\n  2₀₀₁ │  1   1    -1    -1\n 4₀₀₁⁺ │  1  -1   1im  -1im\n 4₀₀₁⁻ │  1  -1  -1im   1im\n───────┴────────────────────\n\njulia> characters(realify(pgirs))\nCharacterTable{3}: ⋕9 (4)\n───────┬──────────────\n       │ Γ₁  Γ₂  Γ₃Γ₄ \n───────┼──────────────\n     1 │  1   1     2\n  2₀₀₁ │  1   1    -2\n 4₀₀₁⁺ │  1  -1     0\n 4₀₀₁⁻ │  1  -1     0\n───────┴──────────────\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.schoenflies-Tuple{Integer}","page":"API","title":"Crystalline.schoenflies","text":"schoenflies(sgnum::Integer) --> String\n\nReturn the Schoenflies notation for space group number sgnum in dimension 3.\n\nNote that Schoenflies notation is well-defined only for 3D point and space groups.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D","page":"API","title":"Crystalline.seitz","text":"seitz(op::SymOperation) --> String\n\nComputes the correponding Seitz notation for a symmetry operation in triplet/xyzt form.\n\nImplementation based on ITA5 Table 11.2.1.1, with 3D point group parts inferred from the trace and determinant of the matrix mathbW in the triplet mathbfWmathbfw.\n\ndetW/trW -3 -2 -1 0 1 2 3\n1   2 3 4 6 1\n-1 -1 -6 -4 -3 m  \n\nwith the elements of the table giving the type of symmetry operation in in Hermann-Mauguin notation. The rotation axis and the rotation sense are computed following the rules in ITA6 Sec. 1.2.2.4(1)(b-c). See also .\n\nNote that the orientation of the axis (i.e. its sign) does not necessarily match the orientation picked in Tables 1.4.2.1-5 of ITA6; it is a matter of (arbitrary) convention, and the conventions have not been explicated in ITA.\n\n2D operations are treated by the same procedure, by elevation in a third dimension; 1D operations by a simple inspection of sign.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.sitegroup-Union{Tuple{D}, Tuple{SpaceGroup{D}, WyckoffPosition{D}}} where D","page":"API","title":"Crystalline.sitegroup","text":"sitegroup(\n    sg::SpaceGroup{D},\n    wp::WyckoffPosition{D}\n) -> SiteGroup\n\n\nReturn the site symmetry group g::SiteGroup for a Wyckoff position wp in space group sg (or with space group number sgnum; in this case, the dimensionality is inferred from wp).\n\ng is a group of operations that are isomorphic to the those listed in sg (in the sense that they might differ by lattice vectors) and that leave the Wyckoff position wp invariant, such that all(op -> wp == op*wp, g) == true.\n\nThe returned SiteGroup also contains the coset representatives of the Wyckoff position (that are again isomorphic to those featured in sg), accessible via cosets, which e.g. generate the orbit of the Wyckoff position (see orbit(::SiteGroup)) and define a left-coset decomposition of sg jointly with the elements in g.\n\nExample\n\njulia> sgnum = 16;\n\njulia> D = 2;\n\njulia> wp = wyckoffs(sgnum, D)[3] # pick a Wyckoff position\n2b: [1/3, 2/3]\n\njulia> sg = spacegroup(sgnum, D);\n\njulia> g  = sitegroup(sg, wp)\nSiteGroup{2} ⋕16 (p6) at 2b = [1/3, 2/3] with 3 operations:\n 1\n {3⁺|1,1}\n {3⁻|0,1}\n\nThe group structure of a SiteGroup can be inspected with MultTable:\n\njulia> MultTable(g)\n3×3 MultTable{2}:\n──────────┬──────────────────────────────\n          │        1  {3⁺|1,1}  {3⁻|0,1} \n──────────┼──────────────────────────────\n        1 │        1  {3⁺|1,1}  {3⁻|0,1} \n {3⁺|1,1} │ {3⁺|1,1}  {3⁻|0,1}         1\n {3⁻|0,1} │ {3⁻|0,1}         1  {3⁺|1,1}\n──────────┴──────────────────────────────\n\nThe original space group can be reconstructed from a left-coset decomposition, using the operations and cosets contained in a SiteGroup:\n\njulia> ops = [opʰ*opᵍ for opʰ in cosets(g) for opᵍ in g];\n\njulia> Set(sg) == Set(ops)\ntrue\n\nTerminology\n\nMathematically, the site symmetry group is a stabilizer group for a Wyckoff position, in the same sense that the little group of k is a stabilizer group for a k-point.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D","page":"API","title":"Crystalline.spacegroup","text":"spacegroup(sgnum::Integer, ::Val{D}=Val(3))\nspacegroup(sgnum::Integer, D::Integer)          --> SpaceGroup{D}\n\nReturn the space group symmetry operations for a given space group number sgnum and  dimensionality D as a SpaceGroup{D}. The returned symmetry operations are specified relative to the conventional basis vectors, i.e. are not necessarily primitive (see centering). If desired, operations for the primitive unit cell can subsequently be generated using  primitivize or Crystalline.reduce_ops.\n\nThe default choices for the conventional basis vectors follow the conventions of the Bilbao Crystallographic Server (or, equivalently, the International Tables of Crystallography),  which are:\n\nUnique axis b (cell choice 1) for monoclinic space groups.\nObverse triple hexagonal unit cell for rhombohedral space groups.\nOrigin choice 2: inversion centers are placed at (0,0,0). (relevant for certain centrosymmetric space groups with two possible choices; e.g., in the orthorhombic, tetragonal or cubic crystal systems).\n\nSee also directbasis.\n\nData sources\n\nThe symmetry operations returned by this function were originally retrieved from the Bilbao Crystallographic Server, SPACEGROUP GENPOS. The associated citation is: (Aroyo et al., Z. Kristallogr. Cryst. Mater. 221, 15 (2006).).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.subduction_count-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Union{Nothing, Vector{<:Real}}}} where T<:Crystalline.AbstractIrrep","page":"API","title":"Crystalline.subduction_count","text":"subduction_count(Dᴳᵢ, Dᴴⱼ[, αβγᴴⱼ]) --> Int\n\nFor two groups G and H, where H is a subgroup of G, i.e. HG, with associated irreducible representations Dᴳᵢ = D^G_i(g) and Dᴴⱼ = D^H_j(g) over operations gG and hHG, compute the compatibility relation between the two irreps from the subduction reduction formula (or \"magic\" formula/Schur orthogonality relation), returning how many times n^GH_ij the subduced representation D^G_iH contains  the irrep D^H_j; in other words, this gives the compatibility between the two irreps.\n\nOptionally, a vector αβγᴴⱼ may be provided, to evaluate the characters/irreps  of Dᴳᵢ at a concrete value of (αβγ). This is e.g. meaningful for LGIrreps at non-special k-vectors. Defaults to nothing.\n\nThe result is computed using the reduction formula [see e.g. Eq. (15) of arXiv:1706.09272v2]:\n\nn^GH_ij = H^-1 sum_h chi^G_i(h)chi^H_j(h)^*\n\nExample\n\nConsider the two compatible k-vectors Γ (a point) and Σ (a line) in space group 207:\n\nlgirsd  = lgirreps(207, Val(3));\nΓ_lgirs = lgirsd[\"Γ\"]; # at Γ ≡ [0.0, 0.0, 0.0]\nΣ_lgirs = lgirsd[\"Σ\"]; # at Σ ≡ [α, α, 0.0]\n\nWe can test their compatibility via:\n\n[[subduction_count(Γi, Σj) for Γi in Γ_lgirs] for Σj in Σ_lgirs]\n> # Γ₁ Γ₂ Γ₃ Γ₄ Γ₅\n>  [ 1, 0, 1, 1, 2] # Σ₁\n>  [ 0, 1, 1, 2, 1] # Σ₂\n\nWith following enterpretatation for compatibility relations between irreps at Γ and Σ:\n\nCompatibility relation Degeneracies\nΓ₁ → Σ₁ 1 → 1\nΓ₂ → Σ₂ 1 → 1\nΓ₃ → Σ₁ + Σ₂ 2 → 1 + 1\nΓ₄ → Σ₁ + 2Σ₂ 3 → 1 + 2\nΓ₅ → 2Σ₁ + Σ₂ 3 → 2 + 1\n\nwhere, in this case, all the small irreps are one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.subperiodicgroup-Union{Tuple{Integer}, Tuple{P}, Tuple{D}, Tuple{Integer, Val{D}}, Tuple{Integer, Val{D}, Val{P}}} where {D, P}","page":"API","title":"Crystalline.subperiodicgroup","text":"subperiodicgroup(num::Integer, ::Val{D}=Val(3), ::Val{P}=Val(2))\nsubperiodicgroup(num::Integer, D::Integer, P::Integer)\n                                                        --> ::SubperiodicGroup{D,P}\n\nReturn the operations of the subperiodic group num of embedding dimension D and periodicity dimension P as a SubperiodicGroup{D,P}.\n\nThe setting choices are those of the International Tables for Crystallography, Volume E.\n\nAllowed combinations of D and P and their associated group names are:\n\nD = 3, P = 2: Layer groups (num = 1, …, 80).\nD = 3, P = 1: Rod groups (num = 1, …, 75).\nD = 2, P = 1: Frieze groups (num = 1, …, 7).\n\nExample\n\njulia> subperiodicgroup(7, Val(2), Val(1))\nSubperiodicGroup{2, 1} ⋕7 (𝓅2mg) with 4 operations:\n 1\n 2\n {m₁₀|½,0}\n {m₀₁|½,0}\n\nData sources\n\nThe symmetry operations returned by this function were originally retrieved from the Bilbao Crystallographic Database, SUBPERIODIC GENPOS.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.wyckoffs-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer, Val{D}}} where D","page":"API","title":"Crystalline.wyckoffs","text":"wyckoffs(sgnum::Integer) -> Vector{WyckoffPosition{3}}\nwyckoffs(sgnum::Integer, ::Val{D}) -> Any\n\n\nReturn the Wyckoff positions of space group sgnum in dimension D as a  Vector{WyckoffPosition{D}.\n\nThe positions are given in the conventional basis setting, following the conventions of the Bilbao Crystallographic Server (from which the underlying data is sourced [1]).\n\nExample\n\njulia> wps = wyckoffs(16, 2)\n4-element Vector{WyckoffPosition{2}}:\n 6d: [α, β]\n 3c: [1/2, 0]\n 2b: [1/3, 2/3]\n 1a: [0, 0]\n\nReferences\n\n[1]: Aroyo, et al.,   Z. Kristallogr. 221, 15-27 (2006)\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-constants","page":"API","title":"Exported constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"api/#Crystalline.ENANTIOMORPHIC_PAIRS","page":"API","title":"Crystalline.ENANTIOMORPHIC_PAIRS","text":"ENANTIOMORPHIC_PAIRS :: NTuple{11, Pair{Int,Int}}\n\nReturn the space group numbers of the 11 enantiomorphic space group pairs in 3D.\n\nThe space group types associated with each such pair (sgnum, sgnum') are related by a mirror transformation: i.e. there exists a transformation  mathbbP = mathbfPmathbfp between the two groups G = g and G = g such that G = mathbbP^-1GmathbbP where mathbfP is improper (i.e. mathrmdetmathbfP  0).\n\nWe define distinct space group types as those that cannot be related by a proper transformation (i.e. with mathrmdetmathbfP  0). With that view, there are 230 space group types. If the condition is relaxed to allow improper rotations, there are  230-11 = 219 distinct affine space group types. See e.g. ITA5 Section 8.2.2.\n\nThe enantiomorphic space group types are also chiral space group types in 3D. There are no enantiomorphic pairs in lower dimensions; in 3D all enantiomorphic pairs involve screw symmetries, whose direction is inverted between pairs (i.e. have opposite handedness).\n\n\n\n\n\n","category":"constant"},{"location":"api/#Crystalline.MAX_SGNUM","page":"API","title":"Crystalline.MAX_SGNUM","text":"MAX_SGNUM :: Tuple{Int,Int,Int}\n\nReturn the number of distinct space group types across dimensions 1, 2, and 3 (indexable by dimensionality).\n\n\n\n\n\n","category":"constant"},{"location":"groups/#Groups","page":"Groups","title":"Groups","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"All groups in Crystalline are concrete instances of the abstract supertype AbstractGroup{D}, referring to a group in D dimensions. AbstractGroup{D} is itself a subtype of AbstractVector{SymOperation{D}}. Crystalline currently supports five group types: SpaceGroup, PointGroup, LittleGroup, SubperiodicGroup and SiteGroup.","category":"page"},{"location":"groups/#Example:-space-groups","page":"Groups","title":"Example: space groups","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"The one, two, and three-dimensional space groups are accessible via spacegroup, which takes the space group number sgnum and dimensino D as input (ideally, the dimension is provided as a Val{D} for the sake of type stability) and returns a SpaceGroup{D} structure:","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"using Crystalline\n\nD     = 3  # dimension\nsgnum = 16 # space group number (≤2 in 1D, ≤17 in 2D, ≤230 in 3D)\nsg    = spacegroup(sgnum, D) # where practical, `spacegroup` should be called with a `Val{D}` dimension to ensure type stability; here we have D::Int instead for simplicity","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"By default, the returned operations are given in the conventional setting of the International Tables of Crystallography, Volume A (ITA). Conversion to a primitive basis (in the CDML setting) can be accomplished via primitivize.","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"In addition to space groups, Crystalline.jl provides access to the operations of point groups (pointgroup](@ref)), little groups (littlegroups](@ref)), subperiodic groups (subperiodicgroup](@ref); including rod, layer, and frieze groups), and site symmetry groups (sitegroup).","category":"page"},{"location":"groups/#Multiplication-tables","page":"Groups","title":"Multiplication tables","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"We can compute the multiplication table of a space group (under the previously defined notion of operator composition) using MultTable:","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"MultTable(sg)","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"Alternatively, exploiting overloading of the *-operator, \"raw\" multiplication tables can be constructed via a simple outer product:","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"sg .* permutedims(sg) # equivalent to `reshape(kron(sg, sg), (length(sg), length(sg)))`","category":"page"},{"location":"groups/#Symmorphic-vs.-nonsymorphic-space-groups","page":"Groups","title":"Symmorphic vs. nonsymorphic space groups","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"To determine whether a space group is symmorphic or not, use issymmorph taking either a SpaceGroup, LittleGroup, or SubperiodicGroup (or a SpaceGroup identified by its number and dimensionality; in this case, using tabulated look-up). To test whether a given SymOperation is symmorphic in a given centering setting, use issymmorph(::SymOperation, ::Char)","category":"page"},{"location":"groups/#Group-generators","page":"Groups","title":"Group generators","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"Generators of SpaceGroups, PointGroups, and SubperiodicGroups are accessible via generators, e.g.:","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"ops = generators(sgnum, SpaceGroup{D})","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"To generate a group from a list of generators, we can use the generate method. As an example, we can verify that ops in fact returns symmetry operations identical to those in sg:","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"generate(ops)","category":"page"},{"location":"lattices/#Isosurfaces-with-space-group-symmetry","page":"Lattices","title":"Isosurfaces with space group symmetry","text":"","category":"section"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"CurrentModule = Crystalline","category":"page"},{"location":"lattices/","page":"Lattices","title":"Lattices","text":"UnityFourierLattice\nModulatedFourierLattice\nlevelsetlattice\nmodulate\nprimitivize(::AbstractFourierLattice, ::Char)\nconventionalize(::AbstractFourierLattice, ::Char)\nAbstractFourierLattice(::Any)","category":"page"},{"location":"lattices/#Crystalline.UnityFourierLattice","page":"Lattices","title":"Crystalline.UnityFourierLattice","text":"UnityFourierLattice{D} <: AbstractFourierLattice{D}\n\nA general D-dimensional Fourier (plane wave) lattice specified by orbits of reciprocal lattice vectors (orbits) and coefficient interrelations (orbitcoefs)). The norm of all elements in orbitcoefs is unity. orbits (and associated coefficients) are sorted in order of increasing norm (low to high).\n\n\n\n\n\n","category":"type"},{"location":"lattices/#Crystalline.levelsetlattice","page":"Lattices","title":"Crystalline.levelsetlattice","text":"levelsetlattice(sgnum::Integer, D::Integer=2, idxmax::NTuple=ntuple(i->2,D))\n    --> UnityFourierLattice{D}\n\nCompute a \"neutral\"/uninitialized Fourier lattice basis, a UnityFourierLattice, consistent with the symmetries of the space group sgnum in dimension D.  The resulting lattice flat is expanded in a Fourier basis split into symmetry-derived orbits, with intra-orbit coefficients constrained by the symmetries of the space-group. The inter-orbit coefficients are, however, free and unconstrained.\n\nThe Fourier resolution along each reciprocal lattice vector is controlled by idxmax: e.g., if D = 2 and idxmax = (2, 3), the resulting Fourier lattice may contain  reciprocal lattice vectors (k₁, k₂) with k₁∈[0,±1,±2] and k₂∈[0,±1,±2,±3], referred  to a 𝐆-basis.\n\nThis \"neutral\" lattice can, and usually should, be subsequently modulated by modulate (which modulates the inter-orbit coefficients, which may eliminate \"synthetic symmetries\" that can exist in the \"neutral\" configuration, due to all  inter-orbit coefficients being set to unity).\n\nExamples\n\nCompute a UnityFourierLattice, modulate it with random inter-orbit coefficients  via modulate, and finally plot it (via PyPlot.jl):\n\njulia> uflat = levelsetlattice(16, Val(2))\njulia> flat  = modulate(uflat)\njulia> Rs    = directbasis(16, Val(2)) \njulia> using PyPlot\njulia> plot(flat, Rs)\n\n\n\n\n\n","category":"function"},{"location":"lattices/#Crystalline.modulate","page":"Lattices","title":"Crystalline.modulate","text":"modulate(flat::UnityFourierLattice{D},\nmodulation::AbstractVector{ComplexF64}=rand(ComplexF64, length(getcoefs(flat))),\nexpon::Union{Nothing, Real}=nothing, Gs::Union{ReciprocalBasis{D}, Nothing}=nothing)\n                        --> ModulatedFourierLattice{D}\n\nDerive a concrete, modulated Fourier lattice from a UnityFourierLattice flat (containing the interrelations between orbit coefficients), by  multiplying the \"normalized\" orbit coefficients by a modulation, a complex modulating vector (in general, should be complex; otherwise restores unintended symmetry to the lattice). Distinct modulation vectors produce distinct  realizations of the same lattice described by the original flat. By default, a random complex vector is used.\n\nAn exponent expon can be provided, which introduces a penalty term to short- wavelength features (i.e. high-|G| orbits) by dividing the orbit coefficients by |G|^expon; producing a \"simpler\" and \"smoother\" lattice boundary when expon > 0 (reverse for expon < 0). This basically amounts to a  continuous \"simplifying\" operation on the lattice (it is not necessarily a  smoothing operation; it simply suppresses \"high-frequency\" components). If expon = nothing, no rescaling is performed. If Gs is provided as nothing, the orbit norm is computed in the reciprocal lattice basis (and, so, may not strictly speaking be a norm if the lattice basis is not cartesian); to account for the basis explicitly, Gs must be provided as a ReciprocalBasis, see also normscale.\n\n\n\n\n\n","category":"function"},{"location":"lattices/#Crystalline.AbstractFourierLattice-Tuple{Any}","page":"Lattices","title":"Crystalline.AbstractFourierLattice","text":"(flat::AbstractFourierLattice)(xyz) --> Float64\n(flat::AbstractFourierLattice)(xyzs...) --> Float64\n\nEvaluate an AbstractFourierLattice at the point xyz and return its real part, i.e.\n\n    mathopmathrmResum_i c_i exp(2pi imathbfG_icdotmathbfr)\n\nwith mathrmG_i denoting reciprocal lattice vectors in the allowed orbits of flat, with c_i denoting the associated coefficients (and mathbfr equiv xyz).\n\nxyz may be any iterable object with dimension matching flat consisting of real numbers (e.g., a Tuple, Vector, or SVector). Alternatively, the coordinates can be supplied individually (i.e., as flat(x, y, z)).\n\n\n\n\n\n","category":"method"},{"location":"bandreps/#Elementary-band-representations","page":"Band representations","title":"Elementary band representations","text":"","category":"section"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"Crystalline.jl provides an interface to access the elementary band representations (EBRs) hosted by the Bilbao Crystallographic Server's BANDREP  program via bandreps. Please cite the original research (listed in the associated docstrings).","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"As an example, we can obtain the all inequivalent EBRs in space group 219 (F-43c) with:","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"using Crystalline\n\nbrs = bandreps(219, 3) # space group 219 (dimension 3)","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"which returns a BandRepSet, which itself is an AbstractVector of BandReps. This allows us to index into brs easily:","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"brs[1] # obtain the EBR induced by Wyckoff position 8a with irrep A","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"By default, bandreps returns the spinless EBRs with time-reversal symmetry. This behavior can be controlled with the keyword arguments spinful (default, false) and timereversal (default, true). By default, only minimal paths are included in the sampling of k-vectors; additional paths can be obtained by setting the keyword argument allpaths = true (default, false).","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"The distinct topological classes identifiable from symmetry can can be calculated via classification, which uses the Smith normal form's principle factors:","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"classification(brs)","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"Which demonstrates that the symmetry indicator group of spinless particles with time-reversal symmetry in space group 219 is trivial.","category":"page"},{"location":"bandreps/#Topology-and-associated-bases","page":"Band representations","title":"Topology and associated bases","text":"","category":"section"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"The SymmetryBases.jl package provides tools to analyze topology of symmetry vectors and compute associated Hilbert bases.","category":"page"},{"location":"bandreps/#API","page":"Band representations","title":"API","text":"","category":"section"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"CurrentModule = Crystalline","category":"page"},{"location":"bandreps/","page":"Band representations","title":"Band representations","text":"bandreps\nclassification\nnontrivial_factors\nbasisdim","category":"page"},{"location":"bandreps/#Crystalline.bandreps","page":"Band representations","title":"Crystalline.bandreps","text":"bandreps(sgnum::Integer, D::Integer=3; \n         allpaths::Bool=false, spinful::Bool=false, timereversal::Bool=true)\n\nReturns the elementary band representations (EBRs) as a BandRepSet for space group sgnum and dimension D.\n\nKeyword arguments\n\nallpaths: include a minimal sufficient set (false, default) or all (true)              k-vectors. \nspinful: single- (false, default) or double-valued (true) irreps, as appropriate for            spinless and spinful particles, respectively. Only available for D=3.\ntimereversal: assume presence (true, default) or absence (false) of time-reversal                 symmetry.\n\nReferences\n\n3D EBRs are obtained from the Bilbao Crystallographic Server's  BANDREP program; please reference the original research papers noted there if used in published work.\n\n\n\n\n\n","category":"function"},{"location":"bandreps/#Crystalline.classification","page":"Band representations","title":"Crystalline.classification","text":"classification(BRS_or_F::Union{BandRepSet, Smith}) --> String\n\nReturn the symmetry indicator group X^textBS of an EBR basis F_or_BRS, provided as a BandRepSet or Smith decomposition.\n\nTechnically, the calculation answers the question \"what direct product of  mathbbZ_n groups is the the quotient group X^textBS = textBStextAI isomorphic to?\" (see Po, Watanabe, & Vishwanath, Nature Commun. 8, 50 (2017) for more information).\n\n\n\n\n\n","category":"function"},{"location":"bandreps/#Crystalline.nontrivial_factors","page":"Band representations","title":"Crystalline.nontrivial_factors","text":"nontrivial_factors(F::Smith) -> Any\n\n\nReturn the nontrivial (i.e., ≠ {0,1}) elementary factors of an EBR basis, provided as a BandRepSet or Smith decomposition.\n\n\n\n\n\n","category":"function"},{"location":"bandreps/#Crystalline.basisdim","page":"Band representations","title":"Crystalline.basisdim","text":"basisdim(BRS::BandRepSet) --> Int\n\nReturn the dimension of the (linearly independent parts) of a band representation set. This is d^textbs = d^textai in the notation of Po, Watanabe, & Vishwanath, Nature Commun. 8, 50 (2017), or  equivalently, the rank of matrix(BRS) over the ring of integers. This is the number of linearly independent basis vectors that span the expansions of a band structure viewed as symmetry data.\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Bravais.jl","page":"Bravais types & bases","title":"Bravais.jl","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"Bravais types, basis systems, and transformations between conventional and primitive settings.","category":"page"},{"location":"bravais/#API","page":"Bravais types & bases","title":"API","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"CurrentModule = Bravais","category":"page"},{"location":"bravais/#Types","page":"Bravais types & bases","title":"Types","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"DirectBasis\nReciprocalBasis\nDirectPoint\nReciprocalPoint","category":"page"},{"location":"bravais/#Bravais.DirectBasis","page":"Bravais types & bases","title":"Bravais.DirectBasis","text":"DirectBasis{D} <: AbstractBasis{D}\n\nA wrapper type over D distinct D-dimensional vectors (given as a SVector{D, SVector{D,Float64}}), defining a lattice basis in direct space.\n\n\n\n\n\n","category":"type"},{"location":"bravais/#Bravais.ReciprocalBasis","page":"Bravais types & bases","title":"Bravais.ReciprocalBasis","text":"ReciprocalBasis{D} <: AbstractBasis{D}\n\nA wrapper type over D distinct D-dimensional vectors (given as a SVector{D, SVector{D,Float64}}), defining a lattice basis in reciprocal space.\n\n\n\n\n\n","category":"type"},{"location":"bravais/#Bravais.DirectPoint","page":"Bravais types & bases","title":"Bravais.DirectPoint","text":"DirectPoint{D} <: AbstractPoint{D}\n\nA wrapper type over an SVector{D, Float64}, defining a single point in D-dimensional direct space. \n\nThe coordinates of a DirectPoint are generally assumed specified relative to an associated DirectBasis.\n\n\n\n\n\n","category":"type"},{"location":"bravais/#Bravais.ReciprocalPoint","page":"Bravais types & bases","title":"Bravais.ReciprocalPoint","text":"ReciprocalPoint{D} <: AbstractPoint{D}\n\nA wrapper type over an SVector{D, Float64}, defining a single point in D-dimensional reciprocal space. \n\nThe coordinates of a ReciprocalPoint are generally assumed specified relative to an associated ReciprocalBasis.\n\n\n\n\n\n","category":"type"},{"location":"bravais/#Crystal-systems-and-Bravais-types","page":"Bravais types & bases","title":"Crystal systems & Bravais types","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"crystalsystem\nbravaistype\ncentering","category":"page"},{"location":"bravais/#Bravais.crystalsystem","page":"Bravais types & bases","title":"Bravais.crystalsystem","text":"crystalsystem(Rs::DirectBasis{D})  -->  String\n\nDetermine the crystal system of a point lattice Rs, assuming the conventional setting choice defined in the International Tables of Crystallography [ITA6].\n\nThere are 4 crystal systems in 2D and 7 in 3D (see Section 2.1.2(iii) of [ITA5]):\n\nD System Conditions Free parameters\n1D linear none a\n2D square a=b & γ=90° a\n rectangular γ=90° a,b\n hexagonal a=b & γ=120° a\n oblique none a,b,γ\n3D cubic a=b=c & α=β=γ=90° a\n hexagonal a=b & α=β=90° & γ=120° a,c\n trigonal a=b & α=β=90° & γ=120° a,c (a,α for hR)\n tetragonal a=b & α=β=γ=90° a,c\n orthorhombic α=β=γ=90° a,b,c\n monoclinic α=γ=90° a,b,c,β≥90°\n triclinic none a,b,c,α,β,γ\n\nThe Rs must specify a set of conventional basis vectors, i.e., not generally primitive. For primitive basis vectors, the crystal system can be further reduced into 5 Bravais types in 2D and 14 in 3D (see @bravaistype).\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016): Tables      3.1.2.1 and 3.1.2.2 (or Tables 2.1.2.1, 9.1.7.1, and 9.1.7.2 of [ITA5]).\n\n[ITA5]: T. Hahn, International Tables of Crystallography, Vol. A, 5th ed. (2005).\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Bravais.bravaistype","page":"Bravais types & bases","title":"Bravais.bravaistype","text":"bravaistype(sgnum::Integer, D::Integer=3; normalize::Bool=false)  -->  String\n\nReturn the Bravais type of sgnum in dimension D as a string (as the concatenation of the single-character crystal abbreviation and the centering type).\n\nKeyword arguments\n\nnormalize: If the centering type associated with sgnum is 'A', we can choose (depending on the keyword argument normalize, defaulting to false) to \"normalize\" to the centering type 'C', since the difference between 'A' and 'C' centering only amounts to a basis change. With normalize=true we then have only the canonical 14 Bravais type, i.e.  unique(bravaistype.(1:230, 3), normalize=true) returns only 14 distinct types, rather than 15.\nThis only affects space groups 38-41 (normalizing their conventional Bravais types from \"oA\" to \"oC\").\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Bravais.centering","page":"Bravais types & bases","title":"Bravais.centering","text":"centering(g::AbstractGroup) --> Char\n\nReturn the conventional centering type of a group. \n\nFor groups without lattice structure (e.g., point groups), return nothing.\n\n\n\n\n\ncentering(sgnum::Integer, D::Integer=3)  -->  Char\n\nReturn the conventional centering type cntr of the space group with number sgnum and dimension D.\n\nThe centering type is equal to the first letter of the Hermann-Mauguin notation's label, i.e., centering(sgnum, D) == first(Crystalline.iuc(sgnum, D)). Equivalently, the centering type is the second and last letter of the Bravais type (bravais), i.e., centering(sgnum, D) == bravaistype(sgnum, D).\n\nPossible values of cntr, depending on dimensionality D, are (see ITA Sec. 9.1.4):\n\nD = 1:\ncntr = 'p': no centering (primitive)\nD = 2:\ncntr = 'p': no centring (primitive)\ncntr = 'c': face centered\nD = 3: \ncntr = 'P': no centring (primitive)\ncntr = 'I': body centred (innenzentriert)\ncntr = 'F': all-face centred\ncntr = 'A' or 'C': one-face centred, (b,c) or (a,b)\ncntr = 'R': hexagonal cell rhombohedrally centred\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Basis-construction","page":"Bravais types & bases","title":"Basis construction","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"crystal\ndirectbasis\nreciprocalbasis","category":"page"},{"location":"bravais/#Bravais.crystal","page":"Bravais types & bases","title":"Bravais.crystal","text":"crystal(a, b, c, α, β, γ)  -->  DirectBasis{3}\n\nCalculate basis vectors mathbfR_1, mathbfR_2, mathbfR_3 in a 3D Cartesian basis for a right-handed coordinate system with specified basis vector lengths a, b, c (associated with mathbfR_1, mathbfR_2, & mathbfR_3, respectively) and specified interaxial angles  α = (mathbfR_2mathbfR_3), β = (mathbfR_3mathbfR_1),  γ = (mathbfR_1mathbfR_2), with  denoting the angle between two vectors.\n\nFor definiteness, the mathbfR_1 basis vector is oriented along the x-axis of the Cartesian coordinate system, and the mathbfR_2 axis is placed in the xy-plane.\n\n\n\n\n\ncrystal(a, b, γ)  -->  DirectBasis{2}\n\nCalculate basis vectors mathbfR_1, mathbfR_2 in a 2D Cartesian basis for a  right-handed coordinate system with specified basis vector lengths a, b (associated with mathbfR_1 & mathbfR_2, respectively) and specified interaxial angle γ = (mathbfR_1mathbfR_2).\n\nFor definiteness, the mathbfR_1 basis vector is oriented along the x-axis of the Cartesian coordinate system.\n\n\n\n\n\ncrystal(a)  -->  DirectBasis{1}\n\nReturn a one-dimensional crystal with lattice period a.\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Bravais.directbasis","page":"Bravais types & bases","title":"Bravais.directbasis","text":"directbasis(sgnum, D=3;    abclims, αβγlims)\ndirectbasis(sgnum, Val(D); abclims, αβγlims) --> DirectBasis{D}\n\nReturn a random (conventional) DirectBasis for a crystal compatible with the space group number sgnum and dimensionality D. Free parameters in the lattice vectors are chosen randomly, with limits optionally supplied in abclims (lengths) and αβγlims (angles). By convention, the length of the first lattice vector (a) is set to unity, such that the second and third (b and c) lattice vectors' lengths are relative to the first.\n\nLimits on the relative uniform distribution of lengths b and c can be specified as  2-tuple kwarg abclims; similarly, limits on the angles α, β, γ can be set via αβγlims (only affects oblique, monoclinic, & triclinic lattices).\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Bravais.reciprocalbasis","page":"Bravais types & bases","title":"Bravais.reciprocalbasis","text":"reciprocalbasis(Rs)  -->  ::ReciprocalBasis{D}\n\nReturn the reciprocal basis of a direct basis Rs in D dimensions, provided as a DirectBasis{D}, a D-dimensional NTuple, or a StaticVector of AbstractVectors (or, type-unstably, as any iterable of AbstractVectors).\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Transformations","page":"Bravais types & bases","title":"Transformations","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"primitivebasismatrix\ntransform(::DirectBasis, ::AbstractMatrix{<:Real})\ntransform(::ReciprocalBasis, ::AbstractMatrix{<:Real})\ntransform(::DirectPoint, ::AbstractMatrix{<:Real})\ntransform(::ReciprocalPoint, ::AbstractMatrix{<:Real})\nprimitivize(::Union{AbstractBasis, AbstractPoint}, ::Union{Char, <:Integer})\nprimitivize(::DirectBasis, ::Union{Char, <:Integer})\nprimitivize(::ReciprocalBasis, ::Union{Char, <:Integer})\nprimitivize(::DirectPoint, ::Union{Char, <:Integer})\nprimitivize(::ReciprocalPoint, ::Union{Char, <:Integer})\nconventionalize(::Union{AbstractBasis, AbstractPoint}, ::Union{Char, <:Integer})\nconventionalize(::DirectBasis, ::Union{Char, <:Integer})\nconventionalize(::ReciprocalBasis, ::Union{Char, <:Integer})\nconventionalize(::DirectPoint, ::Union{Char, <:Integer})\nconventionalize(::ReciprocalPoint, ::Union{Char, <:Integer})","category":"page"},{"location":"bravais/#Bravais.primitivebasismatrix","page":"Bravais types & bases","title":"Bravais.primitivebasismatrix","text":"primitivebasismatrix(cntr::Char, ::Val{D}=Val(3)) --> SMatrix{D,D,Float64}\n\nReturn the transformation matrix P that transforms a conventional unit cell with centering cntr to the corresponding primitive unit cell (in dimension D) in CDML setting.\n\nTransformations in direct and reciprocal space\n\nBases\n\nThe returned transformation matrix mathbfP transforms a direct-space conventional basis (mathbfa mathbfb mathbfc) to the direct-space primitive basis\n\n    (mathbfa mathbfb mathbfc) =\n    (mathbfa mathbfb mathbfc)mathbfP\n\nAnalogously, mathbfP transforms a reciprocal-space conventional basis (mathbfa^* mathbfb^* mathbfc^*) to \n\n(mathbfa^*prime mathbfb^*prime mathbfc^*prime) =\n(mathbfa^* mathbfb^* mathbfc^*)(mathbfP^-1)^textT\n\nsee also transform(::DirectBasis, ::AbstractMatrix{<:Real}) and transform(::ReciprocalBasis, ::AbstractMatrix{<:Real})).\n\nCoordinates\n\nThe coordinates of a point in either direct or reciprocal space, each referred to a basis, also transform under mathbfP. Concretely, direct- and reciprocal-space conventional points mathbfr = (r_1 r_2 r_3)^textT and mathbfk = (k_1 k_2 k_3)^textT, respectively, transform to a primitive setting under mathbfP according to:\n\nmathbfr = mathbfP^-1mathbfr\nmathbfk = mathbfP^textTmathbfk\n\nSee also transform(::DirectPoint, ::AbstractMatrix{<:Real}) and transform(::ReciprocalPoint, ::AbstractMatrix{<:Real})).\n\nSetting conventions\n\nThe setting choice for the primitive cell implied by the returned mathbfP follows the widely adopted Cracknell-Davies-Miller-Love (CDML) convention.[CDML] This convention is explicated e.g. in Table 2 of [Aroyo] (or, alternatively, can be inferred from Tables 1.5.4.1 and 1.5.4.2 of [ITB2]) and is followed e.g. on the Bilbao Crystallographic Server[BCS], in the CDML reference work on space group irreps[CDML], and in the C library spglib.[spglib]\n\nNote that this setting choice is not what is frequently referred to as the \"ITA primitive setting\", from which it differs for hP, hR, and oA Bravais types.\n\nThe setting choice is usually referred to as the CDML primitive setting, or, less frequently and more ambiguously, as the crystallographic primitive setting.\n\n[CDML]: Cracknell, Davies, Miller, & Love, Kroenecker Product Tables, Vol. 1 (1979).\n\n[BCS]: Bilbao Crystallographic Server, KVEC.\n\n[Aroyo]: Aroyo et al., Acta Cryst. A70, 126 (2014): Table 2 gives       (mathbfP^-1)^textT.\n\n[ITB2]: Hahn, International Tables of Crystallography, Vol. B, 2nd edition (2001).\n\n[spglib]: Spglib documentation: Transformation to the primitive setting.        Thus, Bravais.jl and Spglib.jl        transform to identical primitive settings and are hence mutually compatible.\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Bravais.transform-Tuple{DirectBasis, AbstractMatrix{<:Real}}","page":"Bravais types & bases","title":"Bravais.transform","text":"transform(Rs::DirectBasis, P::AbstractMatrix{<:Real})\n\nTransform a direct basis Rs = (mathbfa mathbfb mathbfc) under the transformation matrix P = mathbfP, returning  Rs′ = (mathbfa mathbfb mathbfc) = (mathbfa mathbfb mathbfc) mathbfP.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.transform-Tuple{ReciprocalBasis, AbstractMatrix{<:Real}}","page":"Bravais types & bases","title":"Bravais.transform","text":"transform(Gs::ReciprocalBasis, P::AbstractMatrix{<:Real})\n\nTransform a reciprocal basis Gs = (mathbfa^* mathbfb^* mathbfc^*) under the transformation matrix P = mathbfP, returning  Gs′ = (mathbfa^*prime mathbfb^*prime mathbfc^*prime) = (mathbfa^* mathbfb^* mathbfc^*)(mathbfP^-1)^textT.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.transform-Tuple{DirectPoint, AbstractMatrix{<:Real}}","page":"Bravais types & bases","title":"Bravais.transform","text":"transform(r::DirectPoint, P::AbstractMatrix{<:Real})  -->  r′::typeof(r)\n\nTransform a point in direct space r = (r_1 r_2 r_3)^textT under the transformation matrix P = mathbfP, returning r′ = (r_1 r_2 r_3)^textT = mathbfP^-1(r_1 r_2 r_3)^textT.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.transform-Tuple{ReciprocalPoint, AbstractMatrix{<:Real}}","page":"Bravais types & bases","title":"Bravais.transform","text":"transform(k::ReciprocalPoint, P::AbstractMatrix{<:Real})  -->  k′::typeof(k)\n\nTransform a point in reciprocal space k = (k_1 k_2 k_3)^textT under the transformation matrix P = mathbfP, returning k′ = (k_1 k_2 k_3)^textT = mathbfP^textT(k_1 k_2 k_3)^textT.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.primitivize-Tuple{Union{AbstractBasis, AbstractPoint}, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.primitivize","text":"primitivize(V::Union{AbstractBasis, AbstractPoint}, \n            cntr_or_sgnum::Union{Char, <:Integer})   -->  V′::typeof(V)\n\nReturn the primitive basis or point V′ associated with the input conventional AbstractBasis or AbstractPoint V.\n\nThe assumed centering type is specified by cntr_or_sgnum, given either as a centering character (::Char) or inferred from a space group number (::Integer) and the dimensionality of V (see also centering(::Integer, ::Integer)).\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.primitivize-Tuple{DirectBasis, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.primitivize","text":"primitivize(Rs::DirectBasis, cntr_or_sgnum::Union{Char, <:Integer}) --> Rs′::typeof(Rs)\n\nReturn the primitive direct basis Rs′ corresponding to the input conventional direct basis Rs.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.primitivize-Tuple{ReciprocalBasis, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.primitivize","text":"primitivize(Gs::ReciprocalBasis, cntr_or_sgnum::Union{Char, <:Integer}) --> Gs′::typeof(Gs)\n\nReturn the primitive reciprocal basis Gs′ corresponding to the input conventional reciprocal basis Gs.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.primitivize-Tuple{DirectPoint, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.primitivize","text":"primitivize(r::DirectPoint, cntr_or_sgnum::Union{Char, <:Integer}) --> r′::typeof(r)\n\nReturn the direct point r′ with coordinates in a primitive basis, corresponding to the input point r with coordinates in a conventional basis. \n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.primitivize-Tuple{ReciprocalPoint, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.primitivize","text":"primitivize(k::ReciprocalPoint, cntr_or_sgnum::Union{Char, <:Integer}) --> k′::typeof(k)\n\nReturn the reciprocal point k′ with coordinates in a primitive basis, corresponding to the input point k with coordinates in a conventional basis. \n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.conventionalize-Tuple{Union{AbstractBasis, AbstractPoint}, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.conventionalize","text":"conventionalize(V′::Union{AbstractBasis, AbstractPoint}, \n                cntr_or_sgnum::Union{Char, <:Integer})    -->  V::typeof(V′)\n\nReturn the conventional basis or point V associated with the input primitive AbstractBasis or AbstractPoint V′.\n\nThe assumed centering type is specified by cntr_or_sgnum, given either as a centering character (::Char) or inferred from a space group number (::Integer) and the dimensionality of V′ (see also centering(::Integer, ::Integer)).\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.conventionalize-Tuple{DirectBasis, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.conventionalize","text":"conventionalize(Rs′::DirectBasis, cntr_or_sgnum::Union{Char, <:Integer}) --> Rs::typeof(Rs′)\n\nReturn the conventional direct basis Rs corresponding to the input primitive direct basis Rs′.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.conventionalize-Tuple{ReciprocalBasis, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.conventionalize","text":"conventionalize(Gs′::ReciprocalBasis, cntr_or_sgnum::Union{Char, <:Integer}) --> Gs::typeof(Gs′)\n\nReturn the conventional reciprocal basis Gs corresponding to the input primitive reciprocal basis Gs′.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.conventionalize-Tuple{DirectPoint, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.conventionalize","text":"conventionalize(r′::DirectPoint, cntr_or_sgnum::Union{Char, <:Integer}) --> r::typeof(r′)\n\nReturn the direct point r with coordinates in a conventional basis, corresponding to the input point r′ with coordinates in a primitive basis.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.conventionalize-Tuple{ReciprocalPoint, Union{Char, Integer}}","page":"Bravais types & bases","title":"Bravais.conventionalize","text":"conventionalize(k′::ReciprocalPoint, cntr_or_sgnum::Union{Char, <:Integer}) --> k::typeof(k′)\n\nReturn the reciprocal point k with coordinates in a conventional basis, corresponding to the input point k′ with coordinates in a primitive basis. \n\n\n\n\n\n","category":"method"},{"location":"bravais/#Crystalline.jl-extensions-of-Bravais.jl-functions","page":"Bravais types & bases","title":"Crystalline.jl extensions of Bravais.jl functions","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"CurrentModule = Crystalline","category":"page"},{"location":"bravais/#SymOperation","page":"Bravais types & bases","title":"SymOperation","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"transform(::SymOperation, ::AbstractMatrix{<:Real}, ::Union{AbstractVector{<:Real}, Nothing}, ::Bool=true)\nprimitivize(::SymOperation, ::Char, ::Bool)\nconventionalize(::SymOperation, ::Char, ::Bool)","category":"page"},{"location":"bravais/#Bravais.transform","page":"Bravais types & bases","title":"Bravais.transform","text":"transform(op::SymOperation, P::AbstractMatrix{<:Real}, \n          p::Union{AbstractVector{<:Real}, Nothing}=nothing,\n          modw::Bool=true)                           --> SymOperation\n\nTransforms a op = mathbfWmathbfw by a rotation matrix P and a translation vector p (can be nothing for zero-translations), producing a new symmetry operation  op′ = mathbfWmathbfw (cf. Section 1.5.2.3 of [ITA6])\n\nmathbfWmathbfw = mathbfPmathbfp^-1mathbfWmathbfw\nmathbfPmathbfp\n\nwith\n\nmathbfW = mathbfP^-1mathbfWmathbfP\ntext and \nmathbfw = mathbfP^-1(mathbfw+mathbfWmathbfp-mathbfp)\n\nBy default, the translation part of op′, i.e. mathbfw, is reduced to the range 01), i.e. computed modulo 1. This can be disabled by setting modw = false (default, modw = true).\n\nSee also Bravais.primitivize(::SymOperation, ::Char, ::Bool) and Bravais.conventionalize(::SymOperation, ::Char, ::Bool).\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).\n\n\n\n\n\n","category":"function"},{"location":"bravais/#Bravais.primitivize-Tuple{SymOperation, Char, Bool}","page":"Bravais types & bases","title":"Bravais.primitivize","text":"primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --> typeof(op)\n\nReturn a symmetry operation op′  Ww in a primitive setting, transformed from an input symmetry operation op = Ww in a conventional setting. The operations Ww and Ww are related by a transformation Pp via (cf. Section 1.5.2.3 of [ITA6]):\n\nWw = Pp¹WwPp\n\nwhere P and p are the basis change matrix and origin shifts, respectively. The relevant transformation Pp is inferred from the centering type, as provided by cntr (see also Bravais.centering).\n\nBy default, translation parts of op′, i.e. w are reduced modulo 1 (modw = true); to disable this, set modw = false.\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th ed. (2016).\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.conventionalize-Tuple{SymOperation, Char, Bool}","page":"Bravais types & bases","title":"Bravais.conventionalize","text":"conventionalize(op′::SymOperation, cntr::Char, modw::Bool=true) --> typeof(op)\n\nReturn a symmetry operation op = Ww in a conventional setting, transformed from an input symmetry operation op′  Ww in a primitive setting.\n\nSee primitivize(::SymOperation, ::Char, ::Bool) for description of the centering argument cntr and optional argument modw.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#AbstractFourierLattice","page":"Bravais types & bases","title":"AbstractFourierLattice","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"primitivize(::AbstractFourierLattice, ::Char)\nconventionalize(::AbstractFourierLattice, ::Char)","category":"page"},{"location":"bravais/#Bravais.primitivize-Tuple{Crystalline.AbstractFourierLattice, Char}","page":"Bravais types & bases","title":"Bravais.primitivize","text":"primitivize(flat::AbstractFourierLattice, cntr::Char) --> ::typeof(flat)\n\nGiven flat referred to a conventional basis with centering cntr, compute the derived (but physically equivalent) lattice flat′ referred to the associated primitive basis. \n\nSpecifically, if flat refers to a direct conventional basis Rs  (mathbfa mathbfb mathbfc) [with coordinate vectors mathbfr  (r_1 r_2 r_3)^mathrmT] then flat′ refers to a direct primitive basis Rs′  (mathbfa mathbfb mathbfc)  (mathbfa mathbfb mathbfc)mathbfP [with coordinate vectors  mathbfr  (r_1 r_2 r_3)^mathrmT = mathbfP^-1mathbfr], where mathbfP denotes the basis-change matrix obtained from primitivebasismatrix(...).\n\nTo compute the associated primitive basis vectors, see primitivize(::DirectBasis, ::Char) [specifically, Rs′ = primitivize(Rs, cntr)].\n\nExamples\n\nA centered ('c') lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires using PyPlot):\n\njulia> sgnum = 5; D = 2; cntr = centering(sgnum, D)  # 'c' (body-centered)\n\njulia> Rs   = directbasis(sgnum, Val(D))     # conventional basis (rectangular)\njulia> flat = levelsetlattice(sgnum, Val(D)) # Fourier lattice in basis of Rs\njulia> flat = modulate(flat)                 # modulate the lattice coefficients\njulia> plot(flat, Rs)\n\njulia> Rs′   = primitivize(Rs, cntr)    # primitive basis (oblique)\njulia> flat′ = primitivize(flat, cntr)  # Fourier lattice in basis of Rs′\n\njulia> using PyPlot\njulia> plot(flat′, Rs′)\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.conventionalize-Tuple{Crystalline.AbstractFourierLattice, Char}","page":"Bravais types & bases","title":"Bravais.conventionalize","text":"conventionalize(flat::AbstractFourierLattice, cntr::Char) --> ::typeof(flat′)\n\nGiven flat referred to a primitive basis with centering cntr, compute the derived (but physically equivalent) lattice flat′ referred to the associated conventional basis. \n\nSee also the complementary method primitivize(::AbstractFourierLattice, ::Char) for additional details.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#AbstractVec","page":"Bravais types & bases","title":"AbstractVec","text":"","category":"section"},{"location":"bravais/","page":"Bravais types & bases","title":"Bravais types & bases","text":"transform(::Crystalline.AbstractVec, ::AbstractMatrix{<:Real})\nprimitivize(::Crystalline.AbstractVec, ::Char)\nconventionalize(::Crystalline.AbstractVec, ::Char)","category":"page"},{"location":"bravais/#Bravais.transform-Tuple{Crystalline.AbstractVec, AbstractMatrix{<:Real}}","page":"Bravais types & bases","title":"Bravais.transform","text":"transform(v::AbstractVec, P::AbstractMatrix)  -->  v′::typeof(v)\n\nReturn a transformed coordinate vector v′ from an original coordinate vector v using a basis change matrix P.\n\nNote that a basis change matrix mathbfP transforms direct coordinate vectors (RVec) as mathbfr = mathbfP^-1mathbfr but transforms reciprocal coordinates (KVec) as mathbfk = mathbfP^mathrmTmathbfk [ITA6]\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.primitivize-Tuple{Crystalline.AbstractVec, Char}","page":"Bravais types & bases","title":"Bravais.primitivize","text":"primitivize(v::AbstractVec, cntr::Char)  -->  v′::typeof(v)\n\nTransforms a conventional coordinate vector v to a standard primitive basis (specified by the centering type cntr), returning the primitive coordinate vector v′.\n\nNote that a basis change matrix mathbfP (as returned e.g. by Bravais.primitivebasismatrix) transforms direct coordinate vectors (RVec) as mathbfr = mathbfP^-1mathbfr but transforms reciprocal coordinates (KVec) as mathbfk = mathbfP^textTmathbfk [ITA6]. Recall also the distinction between transforming a basis and the coordinates of a vector.\n\n[ITA6]: M.I. Aroyo, International Tables of Crystallography, Vol. A, 6th edition (2016):      Secs. 1.5.1.2 and 1.5.2.1.\n\n\n\n\n\n","category":"method"},{"location":"bravais/#Bravais.conventionalize-Tuple{Crystalline.AbstractVec, Char}","page":"Bravais types & bases","title":"Bravais.conventionalize","text":"conventionalize(v′::AbstractVec, cntr::Char)  -->  v::typeof(v′)\n\nTransforms a primitive coordinate vector v′ back to a standard conventional basis (specified by the centering type cntr), returning the conventional coordinate vector v.\n\nSee also primitivize and transform.\n\n\n\n\n\n","category":"method"},{"location":"#Crystalline.jl","page":"Home","title":"Crystalline.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Crystalline.jl and Bravais.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nCrystalline.jl remains a work-in-progress research package.  Breaking changes are likely (but will respect semver conventions).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"operations.md\",\n         \"groups.md\",\n         \"irreps.md\",\n         \"bravais.md\",\n         \"bandreps.md\",\n         \"lattices.md\",\n         \"api.md\"]","category":"page"},{"location":"irreps/#Irreducible-representations","page":"Irreps","title":"Irreducible representations","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"Crystalline.jl provides easy access to crystallographic point group irreps, site symmetry group irreps, and the little group irreps of space groups. Currently, we only provide access to spinless (or \"single-valued\") irreps.","category":"page"},{"location":"irreps/#Point-group-irreps","page":"Irreps","title":"Point group irreps","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"Irreps for the crystallographic point groups are accessible via pgirreps, with the point group specified either by IUC label and dimensionality. As an example, we may load the irreps of the 6mm (C₆ᵥ in Schoenflies notation; see also schoenflies(::PointGroup)) point group in 3D.","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"using Crystalline\n\npgirs = pgirreps(\"6mm\", Val(3))","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"Frequently, the character table of the associated irreps is more informative than the irrep matrices themselves. We can construct this table using characters, which returns a CharacterTable:","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"characters(pgirs)","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"The characters are functions of the conjugacy class (i.e., the characters of operations in the same conjugacy class are equal). Thus, a more compact representation of the character table can be achieved by a class-resolved table, achievable via classcharacters:","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"classcharacters(pgirs)","category":"page"},{"location":"irreps/#Notation","page":"Irreps","title":"Notation","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"The default point group irrep labeling follows the Bilbao Crystallographic Server's labeling, which in turn follows the 1963 labelling of Koster, Dimmock, Wheeler, & Statz [2] (which is also followed e.g. by CDML [1] labeling as well as Bradley and Cracknell's book). Associated Muliken (or \"spectroscopist's\") notation can be obtained via mulliken.","category":"page"},{"location":"irreps/#Little-group-irreps","page":"Irreps","title":"Little group irreps","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"Little group irreps, sometimes called ''small'' irreps, are accessible via lgirreps and provided with CDML [1] labels (courtesy of ISOTROPY). As an example, we can obtain the irreps of space group 183 (P6mm; the trivial 3D extension of plane group 17, which in turn is the space group extension of point group 6mm from above) by:","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"using Crystalline\n\nlgirsd = lgirreps(183, Val(3))","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"which returns a dictionary of LGIrreps, indexed by k-labels given as Strings, corresponding to different little groups. In general, we include all the little groups included in ISOTROPY; unfortunately, there is no strict guarantee that this includes a full listing of all inequivalent irreps (although it is typically true). The listing typically contains both special points, lines, and planes (and also always the general point).","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"We can inspect the little group irreps of any particular k-point, accessing it via its canonical label. As before, we can inspect the associated character tables to get an overview of the irreps:","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"lgirs = lgirsd[\"Γ\"] # little group irreps at the Γ point\ncharacters(lgirs)","category":"page"},{"location":"irreps/#Space-group-irreps","page":"Irreps","title":"Space group irreps","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"We currently do not provide access to \"full\" space group irreps. They can, however, be readily built by induction from little group irreps. Specifically, every little group irrep D_mathbfk^alpha associated with the little group G_mathbfk, induces a space group irrep, sometimes denoted ^*D_mathbfk^alpha or D^alpha_mathbfkuparrow G, in the full space group G:[Inui]","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"    ^*D_mathbfk^alpha(g)_ij\n    =\n    begincases\n    D_mathbfk^alpha(h_i^-1gh_j)  textif h_i^-1gh_j in G_mathbfk\n    boldsymbol0_d_mathbfk^alphatimes d_mathbfk^alpha  textotherwise\n    endcases","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"where d_mathbfk^alpha is the dimension of the little group irrep D^alpha_mathbfk, boldsymbol0_d_mathbfk^alphatimes d_mathbfk^alpha is a d_mathbfk^alphatimes d_mathbfk^alpha zero matrix, and h_i and h_j iterate over the (left) coset representatives of G_mathbfk in G (of which there are mathrmstarmathbfk, i.e., the order of the star of mathbfk). The induced irrep ^*D_mathbfk^alpha is consequently a d_mathbfk^alphamathrmstarmathbfktimes d_mathbfk^alphamathrmstarmathbfk matrix.","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"[Inui]: Inui, Tanabe, & Onodera, Group Theory and its Applications in Physics, Springer (1990). Section 11.9.","category":"page"},{"location":"irreps/#Site-symmetry-irreps","page":"Irreps","title":"Site symmetry irreps","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"To obtain irreps associated with a given site symmetry group (see SiteGroup, use the find_isomorphic_parent_pointgroup to obtain the \"parent\" point group and any relevant permutation differences between the two groups. Associated irreps can then be inferred by a suitable permuation of results obtained from pgirreps.","category":"page"},{"location":"irreps/#Time-reversal-symmetry-and-\"physically-real\"-irreps","page":"Irreps","title":"Time-reversal symmetry & \"physically real\" irreps","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"Irreps returned in Crystalline.jl do not assume time-reversal symmetry by default.  To incorporate time-reversal symmetry (or, equivalently, to obtain associated \"physically real\" irreps - or, more technically, co-representations), which may cause irreps to \"stick together\", see realify (which takes a vector of PGIrreps or LGIrreps).","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"As an example, the Γ₃, Γ₄, Γ₅, and Γ₆ irreps of point group 6 (C₆) are intrinsically complex in the absence of time-reversal symmetry:","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"using Crystalline\n\npgirs = pgirreps(\"6\", Val(3))\ncharacters(pgirs)","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"When time-reversal symmetry is incorporated, the irreps stick together pairwise and have real characters:","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"pgirs′ = realify(pgirs)\ncharacters(pgirs′)","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"To inspect the reality type of a given irrep, see reality. Possible types are REAL, COMPLEX, and PSEUDOREAL (the latter does not arise for point groups):","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"label.(pgirs) .=> reality.(pgirs)","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"The reality type can be computed ab initio via calc_reality, using the Frobenius criterion for PGIrreps and SiteIrreps and the Herring criterion for LGIrreps.","category":"page"},{"location":"irreps/#Data-sources","page":"Irreps","title":"Data sources","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"Point group irreps are obtained from the Bilbao Crystallographic Server's Representations PG program and little group irreps of space groups are obtained from ISOTROPY's 2011 ISO-IR dataset.","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"If these functionalities are used in published research, please cite the original publications (listed in associated function docstrings).","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"[1]: Cracknell, A.P., Davies, B.L., Miller, S.C., & Love, W.F., Kronecker Product Tables, Vol. 1. General Introduction and Tables of Irreducible Representations of Space Groups, New York: IFI/Plenum (1979).","category":"page"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"[2]: Koster, G.F., Dimmock, J.O., Wheeler, R.G., & Statz, H., Properties of the Thirty-two Point Groups, Cambridge: MIT Press (1963).","category":"page"}]
}
