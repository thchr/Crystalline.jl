# probably ought to do this with show/repr and a custom mime type to be idiomatic
function lattice2mpb(flat::AbstractFourierLattice)
    orbits = getorbits(flat); coefs = getcoefs(flat)
    Nterms = sum(length, coefs)
    orbits_mpb_vec = Vector{String}(undef, Nterms)
    coefs_mpb_vec  = Vector{String}(undef, Nterms)
    idx = 1
    for (G, c) in zip(Iterators.flatten(orbits), Iterators.flatten(coefs))
        orbits_mpb_vec[idx] = "(vector3"*mapfoldl(x-> " "*string(x), *, G)*")"
        c_re = real(c); c_im = imag(c);
        coefs_mpb_vec[idx]  = string(real(c))*signaschar(c_im)*string(abs(c_im))*"i"
        idx += 1
    end
    orbits_mpb = "(list"*mapfoldl(x->" "*x, *, orbits_mpb_vec)*")"
    coefs_mpb  = "(list"*mapfoldl(x->" "*x, *, coefs_mpb_vec)*")"
    return orbits_mpb, coefs_mpb
end

function filling2isoval(flat::AbstractFourierLattice{D}, filling::Real=0.5, nsamples::Int64=51) where D
    step = 1.0/nsamples
    samples = range(-0.5, 0.5-step, length=nsamples)
    if D == 2
        itr = (real(calcfourier((x,y), flat)) for x in samples for y in samples)
    elseif D == 3
        itr = (real(calcfourier((x,y,z), flat)) for x in samples for y in samples for z in samples)
    end
    return quantile(itr, filling)
end

crystal2mpb(Rs::DirectBasis) = _vecofvecs2ctl(Rs)

function mpb_calcname!(io, dim, sgnum, id, res, runtype="all")
    write(io, "dim",  string(dim),
              "-sg",  string(sgnum), 
              "-",    string(id),
              "-res", string(res))
    if runtype != "all"
        write(io, "-", runtype)
    end
    return nothing
end
function mpb_calcname(dim, sgnum, id, res, runtype="all")
    io = IOBuffer()
    mpb_calcname!(io, dim, sgnum, id, res, runtype)
    return String(take!(io))
end

function _vecofvecs2ctl(vs)
    io = IOBuffer()
    write(io, "(list")
    dim = 0
    for v in vs
        if dim ≠ 0 && dim ≠ length(v)
            throw("All vectors must have identical size, when writing to a list of vector3 files; either two- or three-dimensional")
        elseif dim == 0
            dim = length(v)
        end
        write(io, " (vector3 ")
        join(io, v, ' ')
        write(io, ')')
    end
    write(io, ')')
    return String(take!(io))
end

""" 
    prepare_mpbcalc!(...)

Formats a set of parameters that uniquely specify an MPB calculation, given a 
space group number `sgnum`, a Fourier lattice `flat`, a DirectBasis `Rs`, a filling
fraction `filling` for `flat`, interior and exterior (above, below the contour)
permittivities `εin` and `εout`, as well as a list of k-vectors `kvecs`, an 
identifying tag `id` (to label the calculation for book-keeping purposes), a 
resolution for the MPB calculation `res`, and a selection of calculation type
`runtype` ("all", "te", or "tm"). The results are written to requested IO `io`.

Our preferred choice is to write these parameters to a bash file, with a name
generated by the `mpb_calcname(...)` method.

The options are expected to be fed to the `fourier-lattice.ctl` file, e.g. through
a bash script of the following kind:
```sh
    IFS=\$'\\n'; # stop command-substitutions from word-splitting at space

    PATH_TO_MPB_EXECUTABLE \\
        (cat \${calcname}.sh)
        ctl/fourier-lattice.ctl 2>&1 | tee logs/\${calcname}.log
        
    unset IFS; # restore usual command-substitution word-splitting practice
```
on gbar, `PATH_TO_MPB_EXECUTABLE` is `~/postdoc/mpb-transform-dev/1.8-dev/bin/mpb`.
Locally, in `mpb-ctl` we have a file `run-fourier-lattice.sh` which performs the 
above, with `calcname` specified as an input parameter (assumed to be a subfolder
`/input/`).
"""
function prepare_mpbcalc!(io::IO, sgnum::Integer, flat::AbstractFourierLattice{D}, Rs::DirectBasis{D}, 
                                  filling::Real=0.5, εin::Real=10.0, εout::Real=1.0, 
                                  kvecs=(zeros(D),), id=1, res::Integer=32, runtype::String="all") where D

    # --- work to actually call mpb ---
    calcname = mpb_calcname(D, sgnum, id, res, runtype)
    rvecs = crystal2mpb(Rs)
    uc_gvecs, uc_coefs = lattice2mpb(flat)
    uc_level = filling2isoval(flat, filling)
    # symops = symops2mpb(...)   TODO

    # prepare all mpb param-inputs in a single tuple
    input_tuple = (# run-type ("all", "te", or "tm")
                   "run-type=\""*runtype*"\"",
                   # dimension, space group, resolution, and prefix name
                   "dim="*string(D), "sgnum="*string(sgnum), "res="*string(res),
                   "prefix=\""*calcname*"\"",
                   # crystal (basis vectors)
                   "rvecs="*rvecs,  
                   # unitcell/lattice shape
                   "uc-gvecs="*uc_gvecs, "uc-coefs="*uc_coefs, 
                   "uc-level="*string(uc_level),
                   # permittivities
                   "epsin="*string(εin), "epsout="*string(εout),
                   # TODO: k-points
                   "kvecs="*_vecofvecs2ctl(kvecs),
                   # TODO: little group symmetry operations at each k-point (a list of lists)
                   # "symops=\""*symops*"\""
                  )
    # write inputs to io, separated by newlines and tabs
    join(io, input_tuple, "\n")

    return nothing
end

function prepare_mpbcalc(sgnum::Integer, flat::AbstractFourierLattice{D}, Rs::DirectBasis{D}, 
                  filling::Real, epsin::Real=10.0, epsout::Real=1.0,
                  kvecs=(zeros(D),), id=1, res::Integer=32, runtype::String="all") where D
    io = IOBuffer()
    prepare_mpbcalc!(io, sgnum, flat, Rs, filling, epsin, epsout, kvecs, id, res, runtype)
    return String(take!(io))
end


"""
    lattice_from_mpbparams(filepath::String)

This will load an input file with path `filepath` that was previously created 
by `prepare_mpbcalc(!)` and return the associated lattice as Julia objects.

Output:
```
    Rs::DirectBasis, flat::ModulatedFourierLattice, 
    isoval::Float64, epsin::Float64, epsout::Float64
```
Note that `flat` does not retain information about orbit groupings, since we 
flatten the orbits into a single vector in `lattice2mpb`. This doesn't matter
as we typically just want to plot the saved lattice (see `plot_lattice_from_mpbparams`).
"""
function lattice_from_mpbparams(io::IO)
    mark(io) # mark the beginning of stream so we can return to it (otherwise we must assume a fixed order of parameters in input)

    # --- dimension ---
    readuntil(io, "dim=")
    D = parse(Int64, readline(io))

    # --- basis vectors ---
    readuntil(io, "rvecs=")
    if eof(io); reset(io); readuntil(io, "rvecs="); end # try to be robust to arbitrary ordering
    vecs = Tuple(Vector{Float64}(undef, D) for _ in Base.OneTo(D))
    for R in vecs
        readuntil(io, "(vector3 ")
        coords = split.(readuntil(io, ')'))
        R .= parse.(Ref(Float64), coords)
    end
    Rs = DirectBasis{D}(vecs)

    # --- ("flattened") orbits ---
    readuntil(io, "uc-gvecs=")
    if eof(io); reset(io); readuntil(io, "uc-gvecs="); end # try to be robust to arbitrary ordering
    gvecs = Vector{SVector{D, Int64}}() 
    while true
        readuntil(io, "(vector3 ")
        coords = split.(readuntil(io, ')'))
        next_gvec = parse.(Ref(Int64), coords)
        push!(gvecs, next_gvec)
        (read(io, Char) == ')') && break # look for a closing (double) parenthesis to match the assumed opening "(list "
    end

    # --- ("flattened") orbit coefficients --- 
    readuntil(io, "uc-coefs=")
    if eof(io); reset(io); readuntil(io, "uc-coefs="); end # try to be robust to arbitrary ordering
    readuntil(io, "(list ")
    gcoefs = Vector{ComplexF64}(undef, length(gvecs)) 
    for n in eachindex(gcoefs)
        gcoefs[n] = parse(ComplexF64, readuntil(io, x -> isspace(x) || x==')'))
    end

    # --- ("flattened") Fourier Lattice ---
    # note that we've lost info about orbit groupings (since we flatten on exporting 
    # to mpb in lattice2mpb(...)) but it doesn't matter much, as we only ever need
    # to reload these to see the lattice itself.
    flat = ModulatedFourierLattice{D}([gvecs], [gcoefs])

    # --- iso-level ---
    readuntil(io, "uc-level=")
    if eof(io); reset(io); readuntil(io, "uc-level="); end # try to be robust to arbitrary ordering
    isoval = parse(Float64, readline(io))

    # --- epsilon values ---
    readuntil(io, "epsin=")
    if eof(io); reset(io); readuntil(io, "epsin="); end # try to be robust to arbitrary ordering
    epsin = parse(Float64, readline(io))
    readuntil(io, "epsout=")
    if eof(io); reset(io); readuntil(io, "epsout="); end # try to be robust to arbitrary ordering
    epsout = parse(Float64, readline(io))

    unmark(io)
    return Rs, flat, isoval, epsin, epsout
end
lattice_from_mpbparams(filepath::String) = open(filepath) do io; lattice_from_mpbparams(io); end

function plot_lattice_from_mpbparams(filepath::String; kwargs...)
    Rs, flat, isoval, epsin, epsout = lattice_from_mpbparams(filepath)
    plot(flat, Rs; isoval=isoval, kwargs...)
    return nothing
end