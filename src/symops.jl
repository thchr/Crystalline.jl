""" 
    read_symops_xyzt(sgnum::Integer, dim::Integer=3)

Obtains the symmetry operations in xyzt format for a given space group
number `sgnum` by reading from json files; see `get_symops` for additional
details. Much faster than crawling; generally preferred.
"""
function read_symops_xyzt(sgnum::Integer, dim::Integer=3)
    if all(dim .!= [2,3]); throw(DomainError(dim, "dim must be 2 or 3")); end
    if sgnum < 1 || dim == 3 && sgnum > 230 || dim == 2 && sgnum > 17; 
        throw(DomainError(sgnum, "sgnum must be in range 1:17 in 2D and in 1:230 in 3D")) 
    end

    filepath = (@__DIR__)*"/../data/symops/"*string(dim)*"d/"*string(sgnum)*".json"
    symops_str = open(filepath) do io
        JSON2.read(io)
    end
    return symops_str
end

""" 
    get_symops(sgnum::Integer, dim::Integer=3; verbose::Bool=false) --> SpaceGroup

Obtains the symmetry operations in xyzt and matrix format for a 
given space group number (`= sgnum`). The symmetry operations are 
specified relative to the conventional basis vector choices, i.e.
not necessarily primitive. If desired, operations on a primitive
unit cell can be generated by multiplying with an appropriate 
transformation matrix.

The default choices for basis vectors are specified in Bilbao as:
- Unique axis b (cell choice 1) for space groups within the
    monoclinic system.
- Obverse triple hexagonal unit cell for R space groups.
- Origin choice 2 - inversion center at (0,0,0) - for the
    centrosymmetric space groups for which there are two origin
    choices, within the orthorhombic, tetragonal and cubic systems.
"""
function get_symops(sgnum::Integer, dim::Integer=3; verbose::Bool=false)
    if verbose; print(sgnum, '\n'); end
    sgops_str = read_symops_xyzt(sgnum, dim)
    symops = SymOperation.(sgops_str)

    return SpaceGroup(sgnum, symops, dim)
end

function xyzt2matrix(s::String)
    ssub = split(s, ",")
    dim = length(ssub)
    xyzt2matrix!(zeros(Float64, dim, dim+1), ssub)
end

function xyzt2matrix!(O::Matrix{Float64}, s::Union{T, Array{T}} where T<:AbstractString)
    if s isa AbstractString
        itr = split(s,",")
    elseif s isa Array
        itr = s
    end

    for (i,op) in enumerate(itr)
        # rotation/inversion/reflection part
        nextidx = 1
        while true
            idx = findnext(r"x|y|z", op, nextidx);
            if !isnothing(idx)
                opchar = op[idx]
                if     opchar == "x"; j = 1; 
                elseif opchar == "y"; j = 2;
                elseif opchar == "z"; j = 3; end
                
                if idx[1] == 1 || op[prevind(op, idx[1])] == '+'
                    O[i,j] = 1.0
                elseif op[prevind(op, idx[1])] == '-'
                    O[i,j] = -1.0
                end
                nextidx = nextind(op, idx[end])
            else
                break
            end
        end
        
        # nonsymmorphic part/fractional translation part
        nonsymmorph = op[nextidx:end]
        if !isempty(nonsymmorph)
            slashidx = findfirst(x->x=='/',nonsymmorph)
            num=nonsymmorph[1:prevind(nonsymmorph, slashidx)]
            den=nonsymmorph[nextind(nonsymmorph, slashidx):end]
            O[i,end] = parse(Int64, num)/parse(Int64, den)
        end
    end
        
    return O
end

signaschar(x::Number) = signbit(x) ? '-' : '+'
const idx2xyz = ['x', 'y', 'z']

function matrix2xyzt(O::Matrix{T}) where T<:Real
    dim = size(O,1)
    buf = IOBuffer()
    # rotation/inversion/reflection part
    for (i, row) in enumerate(eachrow(O))
        # rotation/inversion/reflection part
        firstchar = true
        for j = 1:dim
            if !iszero(row[j])
                if !firstchar || signbit(row[j])
                    write(buf, signaschar(row[j]))
                end
                write(buf, idx2xyz[j]) 
                firstchar = false
            end
        end

        # nonsymmorphic/fractional translation part
        if size(O,2) == dim+1 # for size(O) = dim√ódim+1, interpret as a space-group operation and check for nonsymmorphic parts; otherwise, assume a point-group operation
            if !iszero(row[end])
                write(buf, signaschar(row[end]))
                t = rationalize(float(row[end]), tol=1e-2) # convert to "minimal" Rational fraction (within nearest 1e-2 neighborhood)
                write(buf, string(abs(numerator(t)), '/', denominator(t)))
            end
        end
        if i != dim; write(buf, ','); end
    end

    return String(take!(buf))
end


function stripnum(s)
    if occursin(' ', s) # if the operation "number" is included as part of s
        _,s = split(s, isspace; limit=2)
    end
    return String(s) # ensure we return a String, rather than possibly a SubString
end



"""
    issymmorph(sg::SpaceGroup) --> Bool

Checks whether a given space group `sg` is symmorphic (true) or
nonsymmorphic (false).
"""
issymmorph(sg::SpaceGroup) = all(issymmorph.(operations(sg)))

"""
    issymmorph(sgnum::SpaceGroup, dim::Integer=3) --> Bool

Checks whether a given space group `sgnum` is symmorphic (true) or
nonsymmorphic (false).
"""
issymmorph(sgnum::Integer, dim::Integer=3) = issymmorph(get_symops(sgnum, dim; verbose=false))

# ----- POINT GROUP ASSOCIATED WITH SPACE/PLANE GROUP (FULL OR LITTLE) ---
"""
    pointgroup(ops:AbstractVector{SymOperation})

Computes the point group associated with a space group SG (characterized by
a set of operators `ops`, which, jointly with lattice translations generate 
the space group), obtained by "taking away" any translational parts and 
then reducing to the resulting unique rotational operations.
(technically, in the language of Bradley & Cracknell, this is the so-called
isogonal point group of SG; see Sec. 1.5).
"""
function pointgroup(ops::AbstractVector{SymOperation})
    # find SymOperations that are unique with respect to their rotational parts
    unique_rotation_ops = unique(rotation, ops) 
    # return rotation-only SymOperations from the above unique set
    return SymOperation.(hcat.(rotation.(unique_rotation_ops), Ref([0,0,0]))) 
end
pointgroup(sg::SpaceGroup) = pointgroup(operations(sg))
pointgroup(sgnum::Integer, dim::Integer=3) = pointgroup(get_symops(sgnum, dim))

# ----- GROUP ELEMENT COMPOSITION -----
""" 
    (‚àò)(op1::T, op2::T, modœÑ::Bool=true) where T<:SymOperation

Compose two symmetry operations `op1`={W‚ÇÅ|w‚ÇÅ} and `op2`={W‚ÇÇ|w‚ÇÇ}
using the composition rule (in Seitz notation)

    {W‚ÇÅ|w‚ÇÅ}{W‚ÇÇ|w‚ÇÇ} = {W‚ÇÅ*W‚ÇÇ|w‚ÇÅ+W‚ÇÅ*w‚ÇÇ}

for symmetry operations op·µ¢ = {W·µ¢|w·µ¢}. By default, the translation part of
the {W‚ÇÅ*W‚ÇÇ|w‚ÇÅ+W‚ÇÅ*w‚ÇÇ} is reduced to the range [0,1], i.e. computed modulo 1.
This can be toggled off (or on) by the Boolean flag `modœÑ` (enabled, i.e. 
`true` by default). Returns another `SymOperation`.
"""
(‚àò)(op1::T, op2::T, modœÑ::Bool=true) where T<:SymOperation = SymOperation((‚àò)(matrix(op1), matrix(op2), modœÑ))
function (‚àò)(op1::T, op2::T, modœÑ::Bool=true) where T<:Matrix{Float64}
    W‚Ä≤ = rotation(op1)*rotation(op2)
    w‚Ä≤ = translation(op1) .+ rotation(op1)*translation(op2)
    if modœÑ; w‚Ä≤ .= mod.(w‚Ä≤, 1.0); end

    return [W‚Ä≤ w‚Ä≤]
end
const compose = ‚àò



"""
    (‚äö)(op1::T, op2::T) where T<:SymOperation

Compose two symmetry operations `op1`={W‚ÇÅ|w‚ÇÅ} and `op2`={W‚ÇÇ|w‚ÇÇ} and
return the quotient of w‚ÇÅ+W‚ÇÅ*w‚ÇÇ and 1. This functionality complements
`op1‚àòop2`, which yields the translation modulo 1; accordingly, 
`translation(op1‚àòop2) + op1‚äöop2` yields the translation component
of the composition `op1` and `op2` **without** taking it modulo 1,
i.e. including any "trivial" lattice translation.

Note that ‚äö can be auto-completed in Julia via \\circledcirc+[tab]
""" 
function (‚äö)(op1::T, op2::T) where T<:SymOperation
    # Translation result _without_ taking `mod`
    w‚Ä≤ = translation(op1) .+ rotation(op1)*translation(op2)  
    # Below, we combine `mod` and `rem` to ensure correctness in 
    # case any component `œÑ[i] < 0` (since `mod`, as used in ‚àò, 
    # is not the "partner" of `div`; `rem` is, in the sense 
    # `div(x,1) + rem(x,1) = x`, while `div(x,1) + mod(x,1) = x`
    # is only true for x ‚â• 0).
    w‚Ä≤_lattice = div.(w‚Ä≤, 1.0) + rem.(w‚Ä≤, 1.0) .- mod.(w‚Ä≤, 1.0) 

    return w‚Ä≤_lattice
end


"""
    multtable(symops::T) where T<:Union{Vector{SymOperation}, SpaceGroup}

Computes the multiplication table of a set of symmetry operations.
A MultTable is returned, which contains symmetry operations 
resulting from composition of `row ‚àò col` operators; the table of 
indices give the symmetry operators relative to the ordering of 
`symops`.
"""
function multtable(symops::AbstractVector{SymOperation}; verbose::Bool=false)
    havewarned = false
    N = length(symops)
    indices = Matrix{Int64}(undef, N,N)
    for (row,oprow) in enumerate(symops)
        for (col,opcol) in enumerate(symops)
            op‚Ä≤ = matrix(oprow) ‚àò matrix(opcol)
            match = findfirst(op‚Ä≤‚Ä≤ -> op‚Ä≤‚âàmatrix(op‚Ä≤‚Ä≤), symops)
            if isnothing(match)
                if !havewarned
                    if verbose; @warn "The given operations do not form a group!"; end
                    havewarned = true
                end
                match = 0
            end
            @inbounds indices[row,col] = match
        end
    end
    return MultTable(symops, indices, !havewarned)
end
multtable(sg::SpaceGroup) = multtable(operations(sg))


checkmulttable(lgir::LGIrrep, Œ±Œ≤Œ≥=nothing; verbose::Bool=false) = checkmulttable(multtable(operations(lgir)), lgir, Œ±Œ≤Œ≥; verbose=verbose)
function checkmulttable(mt::MultTable, lgir::LGIrrep, Œ±Œ≤Œ≥=nothing; verbose::Bool=false)
    havewarned = false
    irs = irreps(lgir, Œ±Œ≤Œ≥)
    ops = operations(lgir)
    k = kvec(lgir)(Œ±Œ≤Œ≥)
    N = length(ops)
    mtindices = indices(mt)
    checked = trues(N, N)
    for (row,irrow) in enumerate(irs)
        for (col,ircol) in enumerate(irs)
            @inbounds mtidx = mtindices[row,col]
            if iszero(mtidx) && !havewarned
                @warn "Provided multtable is not a group; cannot compare with irreps"
                checked[row,col] = false
                havewarned = true
            end
            ir‚Ä≤ = irrow*ircol
            # If ùê§ is on the BZ boundary and if the little group is nonsymmorphic
            # the representation could be a ray representation (see Inui, p. 89),
            # such that D·µ¢D‚±º = Œ±·µ¢‚±º·µèD‚Çñ with a phase factor Œ±·µ¢‚±º·µè = exp(i*ùê§‚ãÖùê≠‚ÇÄ) where
            # ùê≠‚ÇÄ is a lattice vector ùê≠‚ÇÄ = œÑ·µ¢ + Œ≤·µ¢œÑ‚±º - œÑ‚Çñ, for symmetry operations
            # {Œ≤·µ¢|œÑ·µ¢}. To ensure we capture this, we include this phase here.
            # See Inui et al. Eq. (5.29) for explanation.   
            t‚ÇÄ = translation(ops[row]) + rotation(ops[row])*translation(ops[col]) - translation(ops[mtidx])
            œï =  2œÄ*k'*t‚ÇÄ # include factor of 2œÄ here due to normalized bases
            match = ir‚Ä≤ ‚âà exp(1im*œï)*irs[mtidx]           
            if !match
                checked[row,col] = false
                if !havewarned
                    if verbose
                        @info """Provided irreps do not match group multiplication table:
                                 First failure at (row,col) = ($(row),$(col));
                                 Expected idx $(mtidx), got idx $(findall(ir‚Ä≤‚Ä≤ -> ir‚Ä≤‚Ä≤‚âà ir‚Ä≤, irs))
                                 Expected irrep = $(exp(1im*œï)*irs[mtidx])
                                 Got irrep      = $(ir‚Ä≤)"""

                    end
                    havewarned = true
                end
            end
        end
    end
    return checked
end


# ----- LITTLE GROUP OF ùê§ -----
# A symmetry operation g acts on a wave vector as (ùê§‚Ä≤)·µÄ = ùê§·µÄg‚Åª¬π since we 
# generically operate with g on functions f(ùê´) via gf(ùê´) = f(g‚Åª¬πùê´), such that 
# the operation on a plane wave creates exp(iùê§‚ãÖg‚Åª¬πùê´); invariant plane waves 
# then define the little group elements {g}‚Çñ associated with wave vector ùê§. 
# The plane waves are evidently invariant if ùê§·µÄg‚Åª¬π = ùê§·µÄ, or since g‚Åª¬π = g·µÄ 
# (orthogonal transformations), if (ùê§·µÄg‚Åª¬π)·µÄ = ùê§ = (g‚Åª¬π)·µÄùê§ = gùê§; corresponding
# to the requirement that ùê§ = gùê§). Because we have g and ùê§ in different bases
# (in the direct {ùêë} and reciprocal {ùêÜ} bases, respectively), we have to take 
# a little extra care here. Consider each side of the equation ùê§·µÄ = ùê§·µÄg‚Åª¬π, 
# originally written in Cartesian coordinates, and rewrite each Cartesian term
# through basis-transformation to a representation we know (w/ P(ùêó) denoting 
# a matrix with columns of ùêóm that facilitates this transformation):
#   ùê§·µÄ = [P(ùêÜ)ùê§(ùêÜ)]·µÄ = ùê§(ùêÜ)·µÄP(ùêÜ)·µÄ                    (1)
#   ùê§·µÄg‚Åª¬π = [P(ùêÜ)ùê§(ùêÜ)]·µÄ[P(ùêë)g(ùêë)P(ùêë)‚Åª¬π]‚Åª¬π
#         = ùê§(ùêÜ)·µÄP(ùêÜ)·µÄ[P(ùêë)‚Åª¬π]‚Åª¬πg(ùêë)‚Åª¬πP(ùêë)‚Åª¬π
#         = ùê§(ùêÜ)·µÄ2œÄg(ùêë)‚Åª¬πP(ùêë)‚Åª¬π                       (2)
# (1+2): ùê§‚Ä≤(ùêÜ)·µÄP(ùêÜ)·µÄ = ùê§(ùêÜ)·µÄ2œÄg(ùêë)‚Åª¬πP(ùêë)‚Åª¬π
#     ‚áî ùê§‚Ä≤(ùêÜ)·µÄ = ùê§(ùêÜ)·µÄ2œÄg(ùêë)‚Åª¬πP(ùêë)‚Åª¬π[P(ùêÜ)·µÄ]‚Åª¬π 
#               = ùê§(ùêÜ)·µÄ2œÄg(ùêë)‚Åª¬πP(ùêë)‚Åª¬π[2œÄP(ùêë)‚Åª¬π]‚Åª¬π
#               = ùê§(ùêÜ)·µÄg(ùêë)‚Åª¬π
#     ‚áî  ùê§‚Ä≤(ùêÜ) = [g(ùêë)‚Åª¬π]·µÄùê§(ùêÜ) = [g(ùêë)·µÄ]‚Åª¬πùê§(ùêÜ) 
# where we have used that P(ùêÜ)·µÄ = 2œÄP(ùêë)‚Åª¬π several times. Importantly, this
# essentially shows that we can consider g(ùêÜ) and g(ùêë) mutually interchangeable
# in practice.
# By similar means, one can show that 
#   [g(ùêë)‚Åª¬π]·µÄ = P(ùêë)·µÄP(ùêë)g(ùêë)[P(ùêë)·µÄP(ùêë)]‚Åª¬π
#             = [P(ùêÜ)·µÄP(ùêÜ)]‚Åª¬πg(ùêë)[P(ùêÜ)·µÄP(ùêÜ)],
# by using that g(C)·µÄ = g(C)‚Åª¬π is an orthogonal matrix in the Cartesian basis.
# [ *) We transform from a Cartesian basis to an arbitrary ùêó‚±º basis via a 
# [    transformation matrix P(ùêó) = [ùêó‚ÇÅ ùêó‚ÇÇ ùêó‚ÇÉ] with columns of ùêó‚±º; a vector 
# [    v(ùêó) in the ùêó-representation corresponds to a Cartesian vector v(C)‚â°v via
# [      v(C) = P(ùêó)v(ùêó)
# [    while an operator O(ùêó) corresponds to a Cartesian operator O(C)‚â°O via
# [      O(C) = P(ùêó)O(ùêó)P(ùêó)‚Åª¬π
function littlegroup(symops::Vector{SymOperation}, kv::KVec, cntr::Char='P')
    k‚ÇÄ, kabc = parts(kv)
    checkabc = !iszero(kabc)
    idxlist = [1]
    dim = length(k‚ÇÄ)
    for (idx, op) in enumerate(@view symops[2:end]) # note: `idx` is offset by 1 relative to position of op in symops
        k‚ÇÄ‚Ä≤, kabc‚Ä≤ = parts(compose(op, kv, checkabc)) # this is k‚ÇÄ(ùêÜ)‚Ä≤ = [g(ùêë)·µÄ]‚Åª¬πk‚ÇÄ(ùêÜ)  
        diff = k‚ÇÄ‚Ä≤ .- k‚ÇÄ
        diff = primitivebasismatrix(cntr, dim)'*diff 
        kbool = all(el -> isapprox(el, round(el), atol=DEFAULT_ATOL), diff) # check if k‚ÇÄ and k‚ÇÄ‚Ä≤ differ by a _primitive_ reciprocal vector
        abcbool = checkabc ? isapprox(kabc‚Ä≤, kabc, atol=DEFAULT_ATOL) : true # check if kabc == kabc‚Ä≤; no need to check for difference by a reciprocal vec, since kabc is in interior of BZ

        if kbool && abcbool # ‚áí part of little group
            push!(idxlist, idx+1) # `idx+1` is due to previously noted `idx` offset 
        end
    end
    return idxlist, view(symops, idxlist)
end
littlegroup(symops::SpaceGroup, kv::KVec, cntr::Char='P') = littlegroup(operations(symops), parts(kv)..., cntr)

function starofk(symops::Vector{SymOperation}, kv::KVec, cntr::Char='P')
    # we denote kv by (k‚ÇÄ, kabc) in comments below
    kstar = [kv] 
    checkabc = !iszero(kv.kabc)
    d = dim(kv)
    for op in (@view symops[2:end])
        k‚ÇÄ‚Ä≤, kabc‚Ä≤ = parts(compose(op, kv, checkabc))

        newkbool = true
        for kv‚Ä≤‚Ä≤ in kstar
            k‚ÇÄ‚Ä≤‚Ä≤, kabc‚Ä≤‚Ä≤ = parts(kv‚Ä≤‚Ä≤)
            diff = k‚ÇÄ‚Ä≤ .- k‚ÇÄ‚Ä≤‚Ä≤
            diff = primitivebasismatrix(cntr, d)'*diff
            kbool = all(el -> isapprox(el, round(el), atol=DEFAULT_ATOL), diff) # check if k‚ÇÄ and k‚ÇÄ‚Ä≤ differ by a _primitive_ reciprocal vector
            abcbool = checkabc ? isapprox(kabc‚Ä≤, kabc‚Ä≤‚Ä≤, atol=DEFAULT_ATOL) : true   # check if kabc == kabc‚Ä≤; no need to check for difference by a reciprocal vec, since kabc is in interior of BZ

            if kbool && abcbool # ‚áí we've already seen this KVec for (mod ùêÜ) - we can skip it and go to next operator
                newkbool = false
                break # no need to check the rest of the kvecs currently in kstar; already found a match
            end
        end

        if newkbool
            push!(kstar, KVec(k‚ÇÄ‚Ä≤, kabc‚Ä≤))
        end
    end
    return kstar
end
starofk(sg::SpaceGroup, kv::KVec) = starofk(operations(sg), kv, centering(num(sg), dim(sg)))

"""
    (‚àò)(op::SymOperation, kv::KVec, checkabc::Bool=true) --> KVec

Computes the action of the SymOperation `op`=g on a KVec `kv`=k
using that g acts on k-vectors as k(G)‚Ä≤ = [g(R)·µÄ]‚Åª¬πk(G), with g 
in an R-basis and k in a G-basis. Returns a new KVec, that is 
possibly distinct from its original only by a reciprocal lattice
vector (i.e. multiple of integers).

If `checkabc` = false, the free part of KVec is not transformed
(can be useful in situation where `kabc` is zero, and several 
transformations are requested).
"""
@inline function (‚àò)(op::SymOperation, kv::KVec, checkabc::Bool=true)
    k‚ÇÄ, kabc = parts(kv)
    k‚ÇÄ‚Ä≤ = rotation(op)'\k‚ÇÄ      
    kabc‚Ä≤ = checkabc ? rotation(op)'\kabc : kabc
    return KVec(k‚ÇÄ‚Ä≤, kabc‚Ä≤)
end



"""
    primitivize(op::SymOperation, cntr::Char, dim::Integer) --> SymOperation

Transforms a symmetry operation `op`={W|w} from a conventional cell 
to a primitive cell (specified by its centering character `cntr`), 
then denoted {W‚Ä≤|w‚Ä≤}; i.e. performs a basis change 
    {W‚Ä≤|w‚Ä≤} = {P|p}‚Åª¬π{W|w}{P|p}
where P and p describe basis change and origin shifts, respectively,
associated with the coordinate transformation. 

For additional details, see ITA6 Sec. 1.5.2.3, p. 84.
"""
function primitivize(op::SymOperation, cntr::Char)
    P = primitivebasismatrix(cntr, dim(op))
    transform(op, P, zeros(dim(op)))
end

function conventionalize(op::SymOperation, cntr::Char)
    P = primitivebasismatrix(cntr, dim(op))
    transform(op, inv(P), zeros(dim(op)))
end

function transform(op::SymOperation, P::Matrix{<:Real}, p::Vector{<:Real}=zeros(dim(op)))
    W = rotation(op)
    w = translation(op)

    W‚Ä≤ = P\(W*P)        # = P‚Åª¬πWP
    # clean up rounding-errors introduced by transformation (e.g. 
    # occassionally produces -0.0). The rotational part should 
    # always have integer coefficients in a valid lattice basis.
    @inbounds for (idx, el) in enumerate(W‚Ä≤) 
        rel = round(el)
        if !isapprox(el, rel, atol=DEFAULT_ATOL)
            throw(ErrorException("The transformed operator must have integer coefficients in its rotational part; got $(W‚Ä≤)"))
        end
        # since round(x) takes positive values x‚àà[0,0.5] to 0.0 and negative
        # values x‚àà[-0.5,-0.0] to -0.0 -- and since it is bad for us to have
        # both 0.0 and -0.0 -- we convert -0.0 to 0.0 here
        if rel===-zero(Float64); rel = zero(Float64); end

        W‚Ä≤[idx] = rel
    end

    w‚Ä≤ = P\(w+W*p-p)    # = P‚Åª¬π(w+Wp-p)
    w‚Ä≤ .= mod.(w‚Ä≤, 1.0)
    return SymOperation([W‚Ä≤ w‚Ä≤])
end

function reduce_symops(ops::AbstractVector{SymOperation}, cntr::Char, conv_or_prim::Bool=true)
    ops‚Ä≤ = primitivize.(ops, cntr)
    ops‚Ä≤_reduced = SymOperation.(uniquetol(matrix.(ops‚Ä≤), atol=SGOps.DEFAULT_ATOL))

    if conv_or_prim # (true) return in conventional basis
        return conventionalize.(ops‚Ä≤_reduced, cntr)
    else            # (false) return in primitive basis
        return ops‚Ä≤_reduced
    end
end



# --- INVERSE OF SYMMETRY OPERATION ---
function inv(op::SymOperation)
    W = rotation(op)
    w = translation(op)

    W‚Åª¬π = inv(W)
    w‚Åª¬π = -W‚Åª¬π*w

    return SymOperation([W‚Åª¬π w‚Åª¬π])
end