""" 
    read_symops_xyzt(sgnum::Integer, dim::Integer=3)

    Obtains the symmetry operations in xyzt format for a given space group
    number `sgnum` by reading from json files; see `get_symops` for additional
    details. Much faster than crawling; generally preferred.
"""
function read_symops_xyzt(sgnum::Integer, dim::Integer=3)
    if all(dim .!= [2,3]); error(DomainError(dim, "dim must be 2 or 3")); end
    if sgnum < 1 || dim == 3 && sgnum > 230 || dim == 2 && sgnum > 17; 
        error(DomainError(sgnum, "sgnum must be in range 1:17 in 2D and in 1:230 in 3D")) 
    end

    filepath = (@__DIR__)*"/../data/symops/"*string(dim)*"d/"*string(sgnum)*".json"
    symops_str = open(filepath) do io
        JSON2.read(io)
    end
    return symops_str
end

""" 
    get_symops(sgnum::Integer, dim::Integer=3; verbose::Bool=false) --> SpaceGroup

    Obtains the symmetry operations in xyzt and matrix format for a 
    given space group number (`= sgnum`). The symmetry operations are 
    specified relative to the conventional basis vector choices, i.e.
    not necessarily primitive. If desired, operations on a primitive
    unit cell can be generated by multiplying with an appropriate 
    transformation matrix.
    The default choices for basis vectors are specified in Bilbao as:
        - Unique axis b (cell choice 1) for space groups within the 
          monoclinic system.
        - Obverse triple hexagonal unit cell for R space groups.
        - Origin choice 2 - inversion center at (0,0,0) - for the 
          centrosymmetric space groups for which there are two origin
          choices, within the orthorhombic, tetragonal and cubic systems.
"""
function get_symops(sgnum::Integer, dim::Integer=3; verbose::Bool=false)
    if verbose; print(sgnum, "\n"); end
    sgops_str = read_symops_xyzt(sgnum, dim)
    symops =  SymOperation.(sgops_str)

    return SpaceGroup(sgnum, symops, dim)
end



function xyzt2matrix(s::String)
    ssub = split(s,",")
    dim = length(ssub)
    xyzt2matrix!(zeros(Float64, dim, dim+1), ssub)
end

function xyzt2matrix!(O::Matrix{Float64}, s::Union{T, Array{T}} where T<:AbstractString)
    if s isa AbstractString
        itr = split(s,",")
    elseif s isa Array
        itr = s
    end

    for (i,op) in enumerate(itr)
        # rotation/inversion/reflection part
        nextidx = 1
        while true
            idx = findnext(r"x|y|z", op, nextidx);
            if !isnothing(idx)
                opchar = op[idx]
                if     opchar == "x"; j = 1; 
                elseif opchar == "y"; j = 2;
                elseif opchar == "z"; j = 3; end
                
                if idx[1] == 1 || op[prevind(op, idx[1])] == '+'
                    O[i,j] = 1.0
                elseif op[prevind(op, idx[1])] == '-'
                    O[i,j] = -1.0
                end
                nextidx = nextind(op, idx[end])
            else
                break
            end
        end
        
        # nonsymmorphic part/fractional translation part
        nonsymmorph = op[nextidx:end]
        if !isempty(nonsymmorph)
            slashidx = findfirst("/",nonsymmorph)[1]
            num=nonsymmorph[1:prevind(nonsymmorph, slashidx)]
            den=nonsymmorph[nextind(nonsymmorph, slashidx):end]
            O[i,end] = parse(Int64, num)/parse(Int64, den)
        end
    end
        
    return O
end

signaschar(x::Number) = signbit(x) ? '-' : '+'
const idx2xyz = ['x', 'y', 'z']

function matrix2xyzt(O::Matrix{T}) where T<:Real
    dim = size(O,1)
    buf = IOBuffer()
    # rotation/inversion/reflection part
    for (i,row) in enumerate(eachrow(O))
        # rotation/inversion/reflection part
        firstchar = true
        for j = 1:dim
            if !iszero(row[j])
                if !firstchar || signbit(row[j])
                    write(buf, signaschar(row[j]))
                end
                write(buf, idx2xyz[j]) 
                firstchar = false
            end
        end

        # nonsymmorphic/fractional translation part
        if !iszero(row[4])
            write(buf, signaschar(row[4]))
            t = rationalize(float(row[4]), tol=1e-2) # convert to "minimal" Rational fraction (within nearest 1e-2 neighborhood)
            write(buf, string(abs(numerator(t)), '/', denominator(t)))
        end
        if i != dim; write(buf, ','); end
    end

    return String(take!(buf))
end

fractionstring(x::Rational) = string(x.num) 


function stripnum(s)
    if occursin(' ', s) # if the operation "number" is included as part of s
        _,s = split(s, isspace; limit=2)
    end
    return String(s) # ensure we return a String, rather than possibly a SubString
end





"""
    issymmorph(sg::SpaceGroup) --> Bool

    Checks whether a given space group `sg` is symmorphic (true) or
    nonsymmorphic (false)
"""
issymmorph(sg::SpaceGroup) = all(issymmorph.(operations(sg)))

"""
    issymmorph(sg::SpaceGroup) --> Bool

    Checks whether a given space group `sgnum` is symmorphic (true) or
    nonsymmorphic (false)
"""
issymmorph(sgnum::Integer, dim=3) = issymmorph(get_symops(sgnum, dim; verbose=false))








# ----- NOW REDUNANT FUNCTIONS FOR CRAWLING 3D SPACE GROUPS FROM BILBAO -----
""" 
    crawl_symops_xyzt(sgnum::Integer, dim::Integer=3)

    Obtains the symmetry operations in xyzt format for a given space group
    number `sgnum` by crawling the Bilbao server; see `get_symops` for 
    additional details. Only works for `dim = 3`.
"""
function crawl_symops_xyzt(sgnum::Integer, dim::Integer=3)
    htmlraw = crawl_symops_html(sgnum, dim)

    ops_html = children.(children(last(children(htmlraw.root)))[4:2:end])
    Nops = length(ops_html)
    sgops_str = Vector{String}(undef,Nops)

    for (i,op_html) in enumerate(ops_html)
        sgops_str[i] = stripnum(op_html[1].text) # strip away the space group number
    end
    return sgops_str
end

function crawl_symops_html(sgnum::Integer, dim::Integer=3)
    if dim != 3; error("We do not crawl plane group data; see json files instead; manually crawled.") end
    if sgnum < 1 || sgnum > 230; error(DomainError(sgnum)); end

    if dim == 3
        baseurl = "http://www.cryst.ehu.es/cgi-bin/cryst/programs/nph-getgen?what=text&gnum="
        contents = HTTP.request("GET", baseurl * string(sgnum))
        return parsehtml(String(contents.body))
    else
        error("We did not yet implement 2D plane groups")
    end
end

